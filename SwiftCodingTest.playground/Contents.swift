import Foundation

/*:
 # ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´
 ## ğŸ“Œ ê¸€ì ì´ì–´ ë¶™ì—¬ ë¬¸ìì—´ ë§Œë“¤ê¸°
 MARK: ê¸€ì ì´ì–´ ë¶™ì—¬ ë¬¸ìì—´ ë§Œë“¤ê¸°
 
 - ì£¼ì–´ì§„ ë¬¸ìì—´ `my_string`ì—ì„œ `index_list`ì— í•´ë‹¹í•˜ëŠ” ë¬¸ìë“¤ì„ ìˆœì„œëŒ€ë¡œ ì¶”ì¶œí•˜ì—¬ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ `my_string`ê³¼ ì •ìˆ˜ ë°°ì—´ `index_list`ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
 - `index_list`ì˜ ì›ì†Œë“¤ì€ `my_string`ì˜ ì¸ë±ìŠ¤ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 - í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ë¬¸ìë“¤ì„ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì—¬ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë§Œë“­ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - `1 â‰¤ my_string.count â‰¤ 1,000`
 - `1 â‰¤ index_list.count â‰¤ 1,000`
 - `0 â‰¤ index_list[i] < my_string.count`
 */

func solution1(_ my_string: String, _ index_list: [Int]) -> String {
    let char = Array(my_string)  // ë¬¸ìì—´ì„ ë¬¸ì ë°°ì—´ë¡œ ë³€í™˜
    return index_list.map { String(char[$0]) }.joined()
}

/*:
 ## ì˜ˆì œ ì‹¤í–‰
 */

let my_string1 = "cvsgiorszzzmrpaqpe"
let index_list1 = [16, 6, 5, 3, 12, 14, 11, 11, 17, 12, 7]
solution1(my_string1, index_list1)  // "programmers"

let my_string2 = "zpiaz"
let index_list2 = [1, 2, 0, 0, 3]
solution1(my_string2, index_list2)  // "pizza"

/*:
 ## ì„¤ëª…
 - `Array(my_string)`: ë¬¸ìì—´ì„ ë°°ì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¬¸ì ì¸ë±ì‹±ì„ ì‰½ê²Œ ë§Œë“¦
 - `index_list.map { String(char[$0]) }`: ì£¼ì–´ì§„ ì¸ë±ìŠ¤ì˜ ë¬¸ìë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
 - `.joined()`: ëª¨ë“  ë¬¸ìë¥¼ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ í•©ì¹¨
 */

/*:
 ## ğŸ“Œ ì˜ë¼ì„œ ë°°ì—´ë¡œ ì €ì¥í•˜ê¸°
 MARK: ì˜ë¼ì„œ ë°°ì—´ë¡œ ì €ì¥í•˜ê¸°
 
 - ë¬¸ìì—´ my_strê³¼ nì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_strì„ ê¸¸ì´ nì”© ì˜ë¼ì„œ ì €ì¥í•œ ë°°ì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ `my_str`ê³¼ ë§¤ê°œë³€ìˆ˜ `n`ì´ ì£¼ì–´ì§
 - my_strì„ në§Œí¼ ì˜ë¼ì„œ ì €ì¥í•´ì•¼ ë¨
 - ì €ì¥í•œ ë°°ì—´ì„ ë‹¤ì‹œ returní•˜ë„ë¡ ì½”ë“œë¥¼ ì‘ì„±
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ my_strì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ n â‰¤ my_strì˜ ê¸¸ì´
 - my_strì€ ì•ŒíŒŒë²³ ì†Œë¬¸ì, ëŒ€ë¬¸ì, ìˆ«ìë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 
 */

func solution2(_ my_str: String, _ n: Int) -> [String] {
    var result: [String] = []
    let length = my_str.count
    
    for i in stride(from: 0, to: length, by: n) {
        let start = my_str.index(my_str.startIndex, offsetBy: i)
        let end = my_str.index(start, offsetBy: n, limitedBy: my_str.endIndex) ?? my_str.endIndex
        result.append(String(my_str[start..<end]))
    }
    
    return result
}

/*:
 ## ì˜ˆì œ ì‹¤í–‰
 */

//print(solution("abc1Addfggg4556b", 6)) // ["abc1Ad", "dfggg4", "556b"]
//print(solution("abcdef123", 3)) // ["abc", "def", "123"]
//print(solution("helloWorld", 4)) // ["hell", "oWor", "ld"]

/*:
 ## ì„¤ëª…
 - ê²°ê³¼ë¥¼ ì €ì¥í•  result ë°°ì—´ì„ ìƒì„±
 - stride(from:to:by:)ë¥¼ ì‚¬ìš©í•´ì„œ 0ë¶€í„° my_str.countê¹Œì§€ nê°„ê²©ìœ¼ë¡œ ìˆœíšŒí•˜ë©´ì„œ ë¬¸ìì—´ì„ ìë¦„
 - ë¬¸ìì—´ ìŠ¬ë¼ì´ì‹± (startIndex: í˜„ì¬ iìœ„ì¹˜ì—ì„œ ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤, endIndex: startIndexì—ì„œ në§Œí¼ ì´ë™, í•˜ì§€ë§Œ ë¬¸ìì—´ ëì„ ë„˜ìœ¼ë©´ endIndex = my_str.endIndex
 - ì˜ë¼ë‚¸ ë¬¸ìì—´ì„ ë°°ì—´ì— ì¶”ê°€
 - \* limitedBy: my_str.endIndexë¥¼ ì‚¬ìš©í•´ì„œ ë§ˆì§€ë§‰ ë‚¨ì€ ë¬¸ìì—´ë„ ê·¸ëŒ€ë¡œ ì¶”ê°€ë˜ë„ë¡ ì„¤ì •
 */


/*:
 ## ğŸ“Œ OX í€´ì¦ˆ
 MARK: OX í€´ì¦ˆ
 
 - ë§ì…ˆ, ëº„ì…ˆ ìˆ˜ì‹ë“¤ì´ 'X [ì—°ì‚°ì] Y = Z' í˜•íƒœë¡œ ë“¤ì–´ìˆëŠ” ë¬¸ìì—´ ë°°ì—´ quizê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. ìˆ˜ì‹ì´ ì˜³ë‹¤ë©´ "O"ë¥¼ í‹€ë¦¬ë‹¤ë©´ "X"ë¥¼ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë°°ì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ìˆ˜ì‹ì´ ë“¤ì–´ìˆëŠ” quizê°€ ë°°ì—´ë¡œ ì œê³µ
 - í•´ë‹¹ ë°°ì—´ì˜ ê³„ì‚° ê²°ê³¼ê°€ ë§ë‹¤ë©´ O, í‹€ë¦¬ë‹¤ë©´ Xë¥¼ ë¦¬í„´í•´ì•¼ í•¨
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - ì—°ì‚° ê¸°í˜¸ì™€ ìˆ«ì ì‚¬ì´ëŠ” í•­ìƒ í•˜ë‚˜ì˜ ê³µë°±ì´ ì¡´ì¬í•©ë‹ˆë‹¤. ë‹¨ ìŒìˆ˜ë¥¼ í‘œì‹œí•˜ëŠ” ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ì™€ ìˆ«ì ì‚¬ì´ì—ëŠ” ê³µë°±ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - 1 â‰¤ quizì˜ ê¸¸ì´ â‰¤ 10
 - X, Y, ZëŠ” ê°ê° 0ë¶€í„° 9ê¹Œì§€ ìˆ«ìë¡œ ì´ë£¨ì–´ì§„ ì •ìˆ˜ë¥¼ ì˜ë¯¸í•˜ë©°, ê° ìˆ«ìì˜ ë§¨ ì•ì— ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ê°€ í•˜ë‚˜ ìˆì„ ìˆ˜ ìˆê³  ì´ëŠ” ìŒìˆ˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
 - X, Y, ZëŠ” 0ì„ ì œì™¸í•˜ê³ ëŠ” 0ìœ¼ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - -10,000 â‰¤ X, Y â‰¤ 10,000
 - -20,000 â‰¤ Z â‰¤ 20,000
 - [ì—°ì‚°ì]ëŠ” + ì™€ - ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.
 */

func solution3(_ quiz:[String]) -> [String] {
    var answer: [String] = []
    
    for q in quiz {
        let parts = q.components(separatedBy: " ")
        let x = Int(parts[0])!
        let y = Int(parts[2])!
        let z = Int(parts[4])!
        
        var result = 0
        
        switch parts[1] {
        case "+":
            result = x + y
        case "-":
            result = x - y
        default:
            break
        }
        
        answer.append(result == z ? "O" : "X")
    }
    
    return answer
}

/*:
 ## ì„¤ëª…
 - ê²°ê³¼ë¥¼ ì €ì¥í•  answer ë³€ìˆ˜ ì„ ì–¸ (ë‹¨, ë°°ì—´ì„ ë¦¬í„´í•´ì•¼ í•˜ë¯€ë¡œ ë¹ˆ ë°°ì—´ë¡œ ë³€ìˆ˜ë¥¼ ì„ ì–¸)
 - components(separatedBy: " ")ë¥¼ ì‚¬ìš©í•´ì„œ ê³µë°±ì„ ê¸°ì¤€ìœ¼ë¡œ ê° íŒŒì¸ ë³„ë¡œ ë‚˜ëˆ„ê³  ê°ê°ì˜ íŒŒì¸ ë³„ë¡œ ìˆ«ìëŠ” ì •ìˆ˜í˜•ìœ¼ë¡œ ì—°ì‚°ìëŠ” switch caseë¡œ ê³„ì‚°ì‹ì„ ë‚˜ëˆ”
 - xì—ëŠ” 0ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì…, yì—ëŠ” 2ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì…, zì—ëŠ” 4ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì… (!ì„ ì‚¬ìš©í•œ ì´ìœ ëŠ” ë¬´ì¡°ê±´ ê°’ì´ ìˆê¸° ë•Œë¬¸)
 - ê° ì¼€ì´ìŠ¤ ë³„ë¡œ ì¸ë±ìŠ¤ 1ë²ˆì„ ê°€ì§„ íŒŒì¸ ê°€ + ë¼ë©´ ë§ì…ˆ ì—°ì‚°ìë¥¼ ì‹¤í–‰, ë§Œì•½ - ë¼ë©´ ëº„ì…ˆ ì—°ì‚°ìë¥¼ ì‹¤í–‰í•˜ë„ë¡ ê²½ìš°ë¥¼ ë‚˜ëˆ”
 - ì‚¼í•­ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ì„œ ì •ë‹µì€ O, ì˜¤ë‹µì€ Xë¥¼ answer ë°°ì—´ì— ì¶”ê°€í•˜ê¸° ìœ„í•´ appendë¥¼ ì‚¬ìš©
 - answerë¥¼ ë¦¬í„´
 */



/*:
 ## ğŸ“Œ ë‹¤ìŒì— ì˜¬ ìˆ«ì
 MARK: ë‹¤ìŒì— ì˜¬ ìˆ«ì
 
 - ë“±ì°¨ìˆ˜ì—´ í˜¹ì€ ë“±ë¹„ìˆ˜ì—´ commonì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë§ˆì§€ë§‰ ì›ì†Œ ë‹¤ìŒìœ¼ë¡œ ì˜¬ ìˆ«ìë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ë³´ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë°°ì—´ì´ [1, 2, 3, 4] ë¼ë©´ ê³µì°¨ê°€ 1ì¸ ë“±ì°¨ìˆ˜ì—´ì´ë¯€ë¡œ ë‹¤ìŒì— ì˜¬ ìˆ˜ëŠ” 5ì´ë¯€ë¡œ 5ì„ return
 - ë°°ì—´ì´ [2, 4, 8] ë¼ë©´ ê³µë¹„ê°€ 2ì¸ ë“±ë¹„ìˆ˜ì—´ì´ë¯€ë¡œ ë‹¤ìŒì— ì˜¬ ìˆ˜ëŠ” 16ì´ë¯€ë¡œ 16ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 < commonì˜ ê¸¸ì´ < 1,000
 - -1,000 < commonì˜ ì›ì†Œ < 2,000
 - commonì˜ ì›ì†ŒëŠ” ëª¨ë‘ ì •ìˆ˜ì…ë‹ˆë‹¤.
 - ë“±ì°¨ìˆ˜ì—´ í˜¹ì€ ë“±ë¹„ìˆ˜ì—´ì´ ì•„ë‹Œ ê²½ìš°ëŠ” ì—†ìŠµë‹ˆë‹¤.
 - ë“±ë¹„ìˆ˜ì—´ì¸ ê²½ìš° ê³µë¹„ëŠ” 0ì´ ì•„ë‹Œ ì •ìˆ˜ì…ë‹ˆë‹¤.
 
 */

func solution4(_ common:[Int]) -> Int {
    
    if common[1] - common[0] == common[2] - common[1] {
        let difference = common[1] - common[0]
        return common.last! + difference
    } else {
        let ratio = common[2] / common[1]
        return common.last! * ratio
    }
}

/*:
 ## ì„¤ëª…
 - ìš°ì„  ë“±ì°¨ìˆ˜ì—´ì¸ì§€ ë“±ë¹„ìˆ˜ì—´ì¸ì§€ íŒë‹¨í•˜ê¸° ìœ„í•´ common[1] - common[0] == common[2] - common[1] ë¹„êµ (í•´ë‹¹ ì‹ì´ ì„±ë¦½í•˜ë©´ ë“±ì°¨ìˆ˜ì—´, ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ ë“±ë¹„ìˆ˜ì—´)
 - ë§Œì•½ ë“±ì°¨ìˆ˜ì—´ì´ë¼ë©´ ì¸ë±ìŠ¤ 1ë²ˆê³¼ ì¸ë±ìŠ¤ 0ì„ ëº€ ê°’ì´ ê³µì°¨ì´ë¯€ë¡œ í•´ë‹¹ ê³µì°¨ë¥¼ difference ë³€ìˆ˜ì— ëŒ€ì…í•´ì£¼ê³  return ê°’ìœ¼ë¡œ commonì˜ ë§ˆì§€ë§‰ í•­ì— ë”í•´ì¤Œ
 - ë§Œì•½ ë“±ë¹„ìˆ˜ì—´ì´ë¼ë©´ ì¸ë±ìŠ¤ 2ë²ˆê³¼ 1ë²ˆì„ ë‚˜ëˆˆ ê°’ì„ ratio ë³€ìˆ˜ì— ëŒ€ì…í•´ì£¼ê³  return ê°’ìœ¼ë¡œ commonì˜ ë§ˆì§€ë§‰ í•­ì— ratio ë³€ìˆ˜ë¥¼ ê³±í•œ ê°’ì„ ë°˜í™˜
 - ë¬¸ì œ ì¡°ê±´ì— ë”°ë¥´ë©´ ë“±ë¹„ìˆ˜ì—´ì˜ ê³µë¹„ëŠ” 0ì´ ì•„ë‹Œ ì •ìˆ˜ì´ë¯€ë¡œ, ë‚˜ëˆ—ì…ˆ ì—°ì‚°ì—ì„œ ë¬¸ì œê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ
 - \*common.last!ëŠ” ë°°ì—´ì˜ ë§ˆì§€ë§‰ ìš”ì†Œë¥¼ ê°€ì ¸ì˜´
 */


/*:
 ## ğŸ“Œ ë‹¤ìŒì— ì˜¬ ìˆ«ì
 MARK: ë‹¤ìŒì— ì˜¬ ìˆ«ì
 
 - êµ° ì „ëµê°€ ë¨¸ì“±ì´ëŠ” ì „ìŸ ì¤‘ ì êµ°ì´ ë‹¤ìŒê³¼ ê°™ì€ ì•”í˜¸ ì²´ê³„ë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒì„ ì•Œì•„ëƒˆìŠµë‹ˆë‹¤.
 - ì•”í˜¸í™”ëœ ë¬¸ìì—´ cipherë¥¼ ì£¼ê³ ë°›ìŠµë‹ˆë‹¤.
 - ê·¸ ë¬¸ìì—´ì—ì„œ codeì˜ ë°°ìˆ˜ ë²ˆì§¸ ê¸€ìë§Œ ì§„ì§œ ì•”í˜¸ì…ë‹ˆë‹¤.
 - ë¬¸ìì—´ cipherì™€ ì •ìˆ˜ codeê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ í•´ë…ëœ ì•”í˜¸ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ cipherê°€ "dfjardstddetckdaccccdegk" ì´ê³  codeê°€ 4ë¡œ ì£¼ì–´ì§„ë‹¤ë©´ 4, 8, 16, 20, 14ë²ˆì§¸ ê¸€ìë¥¼ í•©ì¹œ "attackì„ return í•´ì•¼ í•¨
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 < commonì˜ ê¸¸ì´ < 1,000
 - -1,000 < commonì˜ ì›ì†Œ < 2,000
 - commonì˜ ì›ì†ŒëŠ” ëª¨ë‘ ì •ìˆ˜ì…ë‹ˆë‹¤.
 - ë“±ì°¨ìˆ˜ì—´ í˜¹ì€ ë“±ë¹„ìˆ˜ì—´ì´ ì•„ë‹Œ ê²½ìš°ëŠ” ì—†ìŠµë‹ˆë‹¤.
 - ë“±ë¹„ìˆ˜ì—´ì¸ ê²½ìš° ê³µë¹„ëŠ” 0ì´ ì•„ë‹Œ ì •ìˆ˜ì…ë‹ˆë‹¤.
 
 */


func solution5(_ cipher:String, _ code:Int) -> String {
    return cipher.enumerated()
        .filter { ($0.offset + 1) % code == 0 }
        .map { String($0.element) }
        .joined()
}

/*:
 ## ì„¤ëª…
 - enumerated()ë¥¼ ì‚¬ìš©í•´ì„œ ê° ë¬¸ìì— ëŒ€í•´ ì¸ë±ìŠ¤ë¥¼ ê°€ì ¸ì˜´
 - \* enumerated()ëŠ” Swiftì—ì„œ ê° ìš”ì†Œì˜ ì¸ë±ìŠ¤ì™€ ê°’ì„ í•¨ê»˜ ê°€ì ¸ì˜¤ëŠ” ë©”ì„œë“œ (ê° ìš”ì†Œê°€ ëª‡ ë²ˆì§¸ ìœ„ì¹˜ì— ìˆëŠ”ì§€ ì•Œì•„ì•¼ í•  ë•Œ ì‚¬ìš©)
 - filter í•¨ìˆ˜ë¥¼ í†µí•´ codeì˜ ë°°ìˆ˜ì¸ ì¸ë±ìŠ¤ë§Œ ë‚¨ê¸°ê¸° ìœ„í•´ ($0.offset + 1) % code == 0} ì„ ì‘ì„±, offsetì€ ê¸°ë³¸ì ìœ¼ë¡œ 0ë¶€í„° ì‹œì‘í•˜ê¸° ë•Œë¬¸ì— +1ì„ í•´ì¤˜ì„œ 1ë¶€í„° ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤ë¡œ ì‚¬ìš©
 - filterë¡œ ë¶„ë¥˜í•œ ê²ƒì„ Stringìœ¼ë¡œ ë³€í™˜í•´ì£¼ê³  mapì„ ì‚¬ìš©í•´ì„œ í•˜ë‚˜ì˜ ë°°ì—´ë¡œ ë§Œë“¦
 - joined()ë¥¼ ì‚¬ìš©í•´ì„œ í•„í„°ë§ëœ ë¬¸ìë“¤ì„ í•©ì³ ìµœì¢… ë¬¸ìì—´ì„ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ í° ì‚¬ëŒ
 MARK: ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ í° ì‚¬ëŒ
 
 
 - ë¨¸ì“±ì´ëŠ” í•™êµì—ì„œ í‚¤ ìˆœìœ¼ë¡œ ì¤„ì„ ì„¤ ë•Œ ëª‡ ë²ˆì§¸ë¡œ ì„œì•¼ í•˜ëŠ”ì§€ ê¶ê¸ˆí•´ì¡ŒìŠµë‹ˆë‹¤. ë¨¸ì“±ì´ë„¤ ë°˜ ì¹œêµ¬ë“¤ì˜ í‚¤ê°€ ë‹´ê¸´ ì •ìˆ˜ ë°°ì—´ arrayì™€ ë¨¸ì“±ì´ì˜ í‚¤ heightê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ í° ì‚¬ëŒ ìˆ˜ë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ë³´ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ ë¨¸ì“±ì´ì˜ í‚¤(height)ê°€ 140ì´ê³  ì¹œêµ¬ë“¤ì˜ í‚¤(array)ê°€ [145, 130, 160, 180] ì´ë¼ë©´ 3ì„ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ arrayì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ height â‰¤ 200
 - 1 â‰¤ arrayì˜ ì›ì†Œ â‰¤ 200
 
 */


func solution6(_ array:[Int], _ height:Int) -> Int {
    let tallerPeople = array.filter{ $0 > height }
    return tallerPeople.count
}


/*:
 ## ì„¤ëª…
 - ìš°ì„  ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ê°€ í° ì‚¬ëŒì„ ë¶„ë¥˜í•˜ê¸° ìœ„í•´ filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê³  í•´ë‹¹ ê°’ì„ ë‹´ì„ ë³€ìˆ˜(tallerPeople)ë¥¼ ì„ ì–¸
 - return ê°’ì„ tallerPeopleë¡œ í•˜ê³  ë°˜í™˜í•´ì•¼ í•˜ëŠ” ê°’ì´ í‚¤ê°€ ì•„ë‹Œ í‚¤ í° ì‚¬ëŒì˜ ìˆ˜ì´ë¯€ë¡œ tallerPeople.countë¡œ ê°œìˆ˜ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆë„ë¡ ì‘ì„±
 */


/*:
 ## ğŸ“Œ ëª¨ìŒ ì œê±°
 MARK: ëª¨ìŒ ì œê±°
 
 - ì˜ì–´ì—ì„  a, e, i, o, u ë‹¤ì„¯ ê°€ì§€ ì•ŒíŒŒë²³ì„ ëª¨ìŒìœ¼ë¡œ ë¶„ë¥˜í•©ë‹ˆë‹¤. ë¬¸ìì—´ my_stringì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ ëª¨ìŒì„ ì œê±°í•œ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ my_stringìœ¼ë¡œ busê°€ ì£¼ì–´ì§„ë‹¤ë©´, uë¥¼ ì œê±°í•œ bsë¥¼ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - my_stringì€ ì†Œë¬¸ìì™€ ê³µë°±ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 */


func solution7(_ my_string:String) -> String {
    return my_string.filter { !["a", "e", "i", "o", "u"].contains($0) }
    
}

/*:
 ## ì„¤ëª…
 - filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ a, e, i, o, uê°€ ì•„ë‹Œ(!) ìš”ì†Œë“¤ì„ ë½‘ì•„ì„œ return
 */

/*:
 ## ğŸ“Œ ì¹˜í‚¨ ì¿ í°
 MARK: ì¹˜í‚¨ ì¿ í°
 
 - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì¹˜í‚¨ì€ ì¹˜í‚¨ì„ ì‹œì¼œë¨¹ìœ¼ë©´ í•œ ë§ˆë¦¬ë‹¹ ì¿ í°ì„ í•œ ì¥ ë°œê¸‰í•©ë‹ˆë‹¤. ì¿ í°ì„ ì—´ ì¥ ëª¨ìœ¼ë©´ ì¹˜í‚¨ì„ í•œ ë§ˆë¦¬ ì„œë¹„ìŠ¤ë¡œ ë°›ì„ ìˆ˜ ìˆê³ , ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ë„ ì¿ í°ì´ ë°œê¸‰ë©ë‹ˆë‹¤. ì‹œì¼œë¨¹ì€ ì¹˜í‚¨ì˜ ìˆ˜ chickenì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ ë°›ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì„œë¹„ìŠ¤ ì¹˜í‚¨ì˜ ìˆ˜ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ ì¹˜í‚¨ì„ 100ë§ˆë¦¬ ì‹œì¼°ë‹¤ë©´ ì¿ í° 100ì¥ì´ ë°œê¸‰ë˜ë¯€ë¡œ ì„œë¹„ìŠ¤ ì¹˜í‚¨ 10ë§ˆë¦¬ë¥¼ ì£¼ë¬¸í•  ìˆ˜ ìˆê³  ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ë„ ì¿ í°ì´ ë°œê¸‰ë˜ë¯€ë¡œ ì„œë¹„ìŠ¤ ì¹˜í‚¨ 10ë§ˆë¦¬ì— + ì„œë¹„ìŠ¤ ì¹˜í‚¨ìœ¼ë¡œ ë°›ì€ ì¿ í°(10ì¥)ìœ¼ë¡œ ì¹˜í‚¨ 1ë§ˆë¦¬ë¥¼ ë” ì£¼ë¬¸í•´ì„œ ì´ 11ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - chickenì€ ì •ìˆ˜ì…ë‹ˆë‹¤.
 - 0 â‰¤ chicken â‰¤ 1,000,000
 */


func solution8(_ chicken:Int) -> Int {
    if chicken < 10 {
        return 0
    }
    let service = chicken / 10
    return service + solution8(service + (chicken % 10))
}

/*:
 ## ì„¤ëª…
 - ì¹˜í‚¨ì´ 10ì´ ë„˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì²˜ë¦¬í•  ê²Œ ì—†ìœ¼ë¯€ë¡œ 0ì„ return
 - í˜„ì¬ ì¹˜í‚¨ ìˆ˜ì—ì„œ 10ë§ˆë¦¬ë‹¹ 1ë§ˆë¦¬ì”© ì„œë¹„ìŠ¤ ì¹˜í‚¨ì„ ë°›ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ chicken / 10ì„ ê³„ì‚°
 - í˜„ì¬ ì„œë¹„ìŠ¤ ì¹˜í‚¨ ê°œìˆ˜(service)ë¥¼ ë”í•œ í›„, ì¬ê·€ í˜¸ì¶œì„ í•¨
 - ì¬ê·€í˜¸ì¶œ ì¸ìëŠ” (service + (chicken % 10))
 - ì¦‰, í˜„ì¬ ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ì„œ ë°›ì€ ì¿ í°ê³¼ ê¸°ì¡´ì˜ ë‚¨ì€ ì¿ í°ì„ í•©ì³ì„œ ì¬ê·€ í˜¸ì¶œì„ í•¨
 - \* ì¬ê·€ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ì¹˜í‚¨ì„ ë¨¹ìœ¼ë©´ ì¿ í°ì´ ë‚˜ì˜¤ê³ , ì¿ í°ì´ 10ì¥ì´ ë„˜ìœ¼ë©´ ë‹¤ì‹œ ì¹˜í‚¨ì„ ë°›ì„ ìˆ˜ ìˆëŠ” êµ¬ì¡°ì´ë¯€ë¡œ ê³„ì† ë°˜ë³µë¨ ì¦‰, í•œ ë²ˆ ì¹˜í‚¨ì„ ì„œë¹„ìŠ¤ë¡œ ë°›ì€ í›„ ê·¸ ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ì„œ ë˜ ì¿ í°ì´ ë‚˜ì˜¤ëŠ” ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— ì¬ê·€ë¥¼ ì‚¬ìš©
 */




/*:
 ## ğŸ“Œ ê°€ìœ„ ë°”ìœ„ ë³´
 MARK: ê°€ìœ„ ë°”ìœ„ ë³´
 
 - ê°€ìœ„ëŠ” 2 ë°”ìœ„ëŠ” 0 ë³´ëŠ” 5ë¡œ í‘œí˜„í•©ë‹ˆë‹¤. ê°€ìœ„ ë°”ìœ„ ë³´ë¥¼ ë‚´ëŠ” ìˆœì„œëŒ€ë¡œ ë‚˜íƒ€ë‚¸ ë¬¸ìì—´ rspê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, rspì— ì €ì¥ëœ ê°€ìœ„ ë°”ìœ„ ë³´ë¥¼ ëª¨ë‘ ì´ê¸°ëŠ” ê²½ìš°ë¥¼ ìˆœì„œëŒ€ë¡œ ë‚˜íƒ€ë‚¸ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ë³´ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - rspì˜ ê°’ì´ 2(ê°€ìœ„)ë¼ë©´ 0(ë°”ìœ„)ì„ ë¦¬í„´
 - rspì˜ ê°’ì´ 205(ê°€ìœ„ ë°”ìœ„ ë³´)ë¼ë©´ 052(ë°”ìœ„ ë³´ ê°€ìœ„)ë¥¼ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 < rspì˜ ê¸¸ì´ â‰¤ 100
 - rspì™€ ê¸¸ì´ê°€ ê°™ì€ ë¬¸ìì—´ì„ return í•©ë‹ˆë‹¤.
 - rspëŠ” ìˆ«ì 0, 2, 5ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 
 */


func Solution9(_ rsp:String) -> String {
    let mapping: [String: String] = ["2": "0", "0": "5", "5": "2"]
    
    return rsp.map { mapping[String($0)] ?? "?" }.joined()
}

/*:
 ## ì„¤ëª…
 - ê° ì¼€ì´ìŠ¤ ë³„ë¡œ ë¦¬í„´í•´ì•¼ í•˜ëŠ” ê²ƒì´ ì •í•´ì ¸ ìˆê¸° ë•Œë¬¸ì— key value ë§¤í•‘ì„ ì‚¬ìš©í•´ì„œ 2ëŠ” 0, 0ì€ 5, 5ëŠ” 2ë¡œ ì¹˜í™˜ì„ í•´ì¤Œ
 - rspì˜ ê° ë¬¸ìì— ëŒ€í•´ mapping ë”•ì…”ë„ˆë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë³€í™˜í•˜ê³ , ë³€í™˜ëœ ë¬¸ìë“¤ì„ joined()ë¥¼ ì‚¬ìš©í•´ì„œ ë‹¤ì‹œ í•©ì³ì„œ return
 */

/*:
 ## ğŸ“Œ ì§ìˆ˜ì˜ í•©
 MARK: ì§ìˆ˜ì˜ í•©
 
 - ì •ìˆ˜ nì´ ì£¼ì–´ì§ˆ ë•Œ, nì´í•˜ì˜ ì§ìˆ˜ë¥¼ ëª¨ë‘ ë”í•œ ê°’ì„ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ nì´ 10ì´ë¼ë©´ 2 + 4 + 6 + 8 + 10 = 30ì´ë¯€ë¡œ 30ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 < n â‰¤ 1000
 */

func solution9(_ n:Int) -> Int {
    var sum = 0
    for i in 1...n {
        if i % 2 == 0 {
            sum += i
        }
    }
    return sum
}

/*:
 ## ì„¤ëª…
 - ë”í•œ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(sum)ë¥¼ ì„ ì–¸í•˜ê³  0ìœ¼ë¡œ ì´ˆê¸°í™”
 - forë¬¸ê³¼ ifë¬¸ì„ ì´ìš©í•´ì„œ 1ë¶€í„° ì •ìˆ˜ nê¹Œì§€ i ë¥¼ 2ë¡œ ë‚˜ëˆ„ì–´ì„œ 0ì´ ë˜ëŠ” ê°’ë“¤ë§Œ sum ë³€ìˆ˜ì— ë”í•´ì¤Œ
 - í•´ë‹¹ ê°’ë“¤ì´ ë‹¤ ë”í•´ì§„ sum ë³€ìˆ˜ë¥¼ return
 */


/*:
 ## ğŸ“Œ ë§ˆì§€ë§‰ ë‘ ì›ì†Œ
 MARK: ë§ˆì§€ë§‰ ë‘ ì›ì†Œ
 
 - ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§ˆ ë•Œ, ë§ˆì§€ë§‰ ì›ì†Œê°€ ê·¸ì „ ì›ì†Œë³´ë‹¤ í¬ë©´ ë§ˆì§€ë§‰ ì›ì†Œì—ì„œ ê·¸ì „ ì›ì†Œë¥¼ ëº€ ê°’ì„ ë§ˆì§€ë§‰ ì›ì†Œê°€ ê·¸ì „ ì›ì†Œë³´ë‹¤ í¬ì§€ ì•Šë‹¤ë©´ ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ë‘ ë°°í•œ ê°’ì„ ì¶”ê°€í•˜ì—¬ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [2, 1, 6]ë¼ê³  ì£¼ì–´ì¡Œë‹¤ë©´ ë§ˆì§€ë§‰ ì›ì†Œì¸ 6ì´ ê·¸ ì „ ì›ì†Œì¸ 1ë³´ë‹¤ í¬ê¸° ë•Œë¬¸ì— 6 - 1ì¸ 5ë¥¼ ì¶”ê°€í•œ [2, 1, 6, 5]ë¥¼ ë¦¬í„´
 - num_listê°€ [5, 2, 1, 7, 5]ë¼ê³  ì£¼ì–´ì¡Œë‹¤ë©´ ë§ˆì§€ë§‰ ì›ì†Œì¸ 5ê°€ ê·¸ ì „ ì›ì†Œì¸ 7ë³´ë‹¤ í¬ì§€ ì•Šê¸° ë•Œë¬¸ì— 5ì˜ 2ë°°ì¸ 10ì„ ì¶”ê°€í•œ [5, 2, 1, 7, 5, 10]ì„ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 */


func solution10(_ num_list:[Int]) -> [Int] {
    let lastValue = num_list[num_list.count - 1]
    let secondLastValue = num_list[num_list.count - 2]
    var subValue = lastValue - secondLastValue
    
    if lastValue > secondLastValue {
        return num_list + [subValue]
    } else {
        return num_list + [lastValue * 2]
    }
}

/*:
 ## ì„¤ëª…
 - ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ë‹´ì„ ë³€ìˆ˜(lastValue)ì™€ ë§ˆì§€ë§‰ ì›ì†Œì—ì„œ ê·¸ ì „ ì›ì†Œì˜ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(secondLastValue)ë¥¼ ì„ ì–¸í•´ì£¼ê³  ë‘ ê°’ì„ ëº€ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(subValue)ë¥¼ ì„ ì–¸í•¨
 - ifë¬¸ìœ¼ë¡œ ë§ˆì§€ë§‰ ì›ì†Œê°€ ë” í¬ë‹¤ë©´ ê¸°ì¡´ ë°°ì—´(num_list)ì— ë‘ ê°’ì€ ëº€ ë³€ìˆ˜ë¥¼ ì¶”ê°€í•´ì£¼ê³  return
 - ê·¸ ì™¸ë¼ë©´ ê¸°ì¡´ ë°°ì—´ì— ë§ˆì§€ë§‰ ì›ì†Œì— 2ë°°ë¥¼ í•œ ê°’ì„ ë¦¬í„´
 */



/*:
 ## ğŸ“Œ í™€ìˆ˜ vs ì§ìˆ˜
 MARK: í™€ìˆ˜ vs ì§ìˆ˜
 
 - ì •ìˆ˜ê°€ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. num_listì˜ í™€ìˆ˜ë§Œ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì¸ ìˆ˜ì™€ ì§ìˆ˜ë§Œ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì¸ ìˆ˜ì˜ í•©ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [3, 4, 5, 2, 1]ë¡œ ì£¼ì–´ì¡Œë‹¤ë©´ í™€ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 351ì´ê³  ì§ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 42ì…ë‹ˆë‹¤. ë‘ ìˆ˜ì˜ í•©ì€ 393ì…ë‹ˆë‹¤.
 - num_listê°€ [5, 7, 8, 3]ìœ¼ë¡œ ì£¼ì–´ì¡Œë‹¤ë©´ í™€ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 573ì´ê³  ì§ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 8ì…ë‹ˆë‹¤. ë‘ ìˆ˜ì˜ í•©ì€ 581ì…ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - num_listì—ëŠ” ì ì–´ë„ í•œ ê°œì”©ì˜ ì§ìˆ˜ì™€ í™€ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.
 */


func solution11(_ num_list:[Int]) -> Int {
    var oddNum = num_list.filter { (number: Int) -> Bool in
        return number % 2 == 1
    }
    var evenNum = num_list.filter { (number: Int) -> Bool in
        return number % 2 == 0
    }
    
    let oddResult = oddNum.reduce(0) { accumulated, current in
        return accumulated * 10 + current
    }
    
    let evenResult = evenNum.reduce(0) { accumulated, current in
        return accumulated * 10 + current
    }
    
    return oddResult + evenResult
}

/*:
 ## ì„¤ëª…
 - í™€ìˆ˜ì™€ ì§ìˆ˜ë¥¼ ë³„ë„ë¡œ í•„í„°ë§í•˜ì—¬ ë‘ ë°°ì—´ë¡œ ë¶„ë¦¬í•¨
 - í™€ìˆ˜ë“¤ì„ í•˜ë‚˜ì˜ ìˆ«ìë¡œ ì´ì–´ë¶™ì„ (ì˜ˆ: [1,3,5] â†’ 135)
 - reduce í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ê° ìˆ«ìë¥¼ 10ì˜ ìë¦¬ì”© ì˜¬ë ¤ê°€ë©° ê³„ì‚°
 - ì§ìˆ˜ë“¤ë„ ê°™ì€ ë°©ì‹ìœ¼ë¡œ í•˜ë‚˜ì˜ ìˆ«ìë¡œ ì´ì–´ë¶™ì„ (ì˜ˆ: [2,4] â†’ 24)
 - ë‘ ê²°ê³¼ê°’ì„ ë”í•´ì„œ ìµœì¢… ë‹µì„ ë°˜í™˜í•¨
 */


/*:
 ## ğŸ“Œ ë¬¸ìì—´ ì•ì˜ nê¸€ì
 MARK: ë¬¸ìì—´ ì•ì˜ nê¸€ì
 
 - ë¬¸ìì—´ my_stringê³¼ ì •ìˆ˜ nì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_stringì˜ ì•ì˜ nê¸€ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - my_stringì€ ìˆ«ìì™€ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 - 1 â‰¤ n â‰¤ my_stringì˜ ê¸¸ì´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - num_listì—ëŠ” ì ì–´ë„ í•œ ê°œì”©ì˜ ì§ìˆ˜ì™€ í™€ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.
 */



func solution12(_ my_string:String, _ n:Int) -> String {
    let result = String(my_string.prefix(n))
    return result
}

/*:
 ## ì„¤ëª…
 - prefix ë©”ì„œë“œëŠ” ì•ì—ì„œë¶€í„° nê°œì˜ ë¬¸ìë¥¼ ê°€ì ¸ì˜¤ê¸° ë•Œë¬¸ì— prefixë¥¼ ì‚¬ìš©í•´ì„œ nê°œ ë§Œí¼ ê°€ì ¸ì˜¤ê³  ê°€ì ¸ì˜¨ ê°’ì„ ë³€ìˆ˜(result)ì— ë‹´ê³  í•´ë‹¹ ë³€ìˆ˜ë¥¼ return
 */

/*:
 ## ğŸ“Œ í•  ì¼ ëª©ë¡
 MARK: í•  ì¼ ëª©ë¡
 
 - ì˜¤ëŠ˜ í•´ì•¼ í•  ì¼ì´ ë‹´ê¸´ ë¬¸ìì—´ ë°°ì—´ todo_listì™€ ê°ê°ì˜ ì¼ì„ ì§€ê¸ˆ ë§ˆì³¤ëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” boolean ë°°ì—´ finishedê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, todo_listì—ì„œ ì•„ì§ ë§ˆì¹˜ì§€ ëª»í•œ ì¼ë“¤ì„ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - todo_list, finished, resultê°€ ê°ê° ["problemsolving", "practiceguitar", "swim", "studygraph"]    [true, false, true, false]    ["practiceguitar", "studygraph"]
 - todo_list ì¤‘ì—ì„œ "problemsolving"ê³¼ "swim"ì€ ë§ˆì³¤ê³ , "practiceguitar"ì™€ "studygraph"ëŠ” ì•„ì§ ë§ˆì¹˜ì§€ ëª»í–ˆìœ¼ë¯€ë¡œ todo_listì—ì„œ ë‚˜ì˜¨ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ ["practiceguitar", "studygraph"]ë¥¼ return í•©ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ todo_listì˜ ê¸¸ì´ 1 â‰¤ 100
 - 2 â‰¤ todo_listì˜ ì›ì†Œì˜ ê¸¸ì´ â‰¤ 20
 - todo_listì˜ ì›ì†ŒëŠ” ì˜ì†Œë¬¸ìë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - todo_listì˜ ì›ì†ŒëŠ” ëª¨ë‘ ì„œë¡œ ë‹¤ë¦…ë‹ˆë‹¤.
 - finished[i]ëŠ” true ë˜ëŠ” falseì´ê³  trueëŠ” todo_list[i]ë¥¼ ë§ˆì³¤ìŒì„, falseëŠ” ì•„ì§ ë§ˆì¹˜ì§€ ëª»í–ˆìŒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 - ì•„ì§ ë§ˆì¹˜ì§€ ëª»í•œ ì¼ì´ ì ì–´ë„ í•˜ë‚˜ ìˆìŠµë‹ˆë‹¤.
 */


func solution13(_ todo_list:[String], _ finished:[Bool]) -> [String] {
    var result: [String] = []
    
    for (index, isFinished) in finished.enumerated() {
        if !isFinished {
            result.append(todo_list[index])
        }
    }
    return result
}

/*:
 ## ì„¤ëª…
 - todo_listì™€ finishedì˜ ì¸ë±ìŠ¤ë¥¼ ì´ìš©
 - enumerated()ë¥¼ ì‚¬ìš©í•´ì„œ ë°°ì—´ì˜ ê° ìš”ì†Œì— ëŒ€í•´ ì¸ë±ìŠ¤ì™€ ìš”ì†Œ ê°’ì„ í•¨ê»˜ ì œê³µí•˜ëŠ” ì‹œí€€ìŠ¤ë¥¼ ë°˜í™˜
 - ë§Œì•½ finished ë°°ì—´ì´ [true, false, true] ë¼ë©´
 - ì²« ë²ˆì§¸ ë°˜ë³µì—ì„œëŠ” index = 0, isFinished = true
 - ë‘ ë²ˆì§¸ ë°˜ë³µì—ì„œëŠ” index = 1, isFinished = false
 - ì„¸ ë²ˆì§¸ ë°˜ë³µì—ì„œëŠ” index = 2, isFinished = true
 - if ì¡°ê±´ë¬¸ì„ ì‚¬ìš©í•´ì„œ isFinishedì˜ ê°’ì´ falseì¼ ë•Œë§Œ ë‚´ë¶€ ì½”ë“œë¥¼ ì‹¤í–‰
 - todo_list[index]ë¡œ í˜„ì¬ ì¸ë±ìŠ¤ì— í•´ë‹¹í•˜ëŠ” í•  ì¼ í•­ë³µì— ì ‘ê·¼
 - ê·¸ í•­ëª©ì„ result ë°°ì—´ì— ì¶”ê°€í•œ í›„ resultë¥¼ return
 */


/*:
 ## ğŸ“Œ në³´ë‹¤ ì»¤ì§ˆ ë•Œê¹Œì§€ ë”í•˜ê¸°
 MARK: në³´ë‹¤ ì»¤ì§ˆ ë•Œê¹Œì§€ ë”í•˜ê¸°
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - numbers, n, resultê°€ ê°ê° [34, 5, 71, 29, 100, 34], 123, 139ë¡œ ì£¼ì–´ì¡Œë‹¤ë©´
 - 29ë¥¼ ë”í•œ ë’¤ì— sum ê°’ì€ 139ì´ê³  'n' ê°’ì¸ 123ë³´ë‹¤ í¬ë¯€ë¡œ 139ë¥¼ return í•©ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ numbersì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ numbersì˜ ì›ì†Œ â‰¤ 100
 - 0 â‰¤ n < numbersì˜ ëª¨ë“  ì›ì†Œì˜ í•©
 */

func solution14(_ numbers:[Int], _ n:Int) -> Int {
    var sum = 0
    for numbers in numbers {
        sum += numbers
        if sum > n {
            break
        }
    }
    return sum
}

/*:
 ## ì„¤ëª…
 - numbersì˜ í•©ì„ ì €ì¥í•  sum ë³€ìˆ˜ ì„ ì–¸
 - forë¬¸ì„ ì´ìš©í•´ì„œ numbersë¥¼ ìˆœì„œëŒ€ë¡œ ë”í•´ì£¼ê³  sumì— í•©ì„ ì €ì¥
 - ifë¬¸ì„ ì‚¬ìš©í•´ì„œ sumì˜ ê°’ì´ në³´ë‹¤ ì»¤ì§€ë©´ ì¤‘ë‹¨
 - sumì„ return
 */


/*:
 ## ğŸ“Œ ì¹´ìš´íŠ¸ ì—…
 MARK: ì¹´ìš´íŠ¸ ì—…
 
 - ì •ìˆ˜ start_numì™€ end_numê°€ ì£¼ì–´ì§ˆ ë•Œ, start_numë¶€í„° end_numê¹Œì§€ì˜ ìˆ«ìë¥¼ ì°¨ë¡€ë¡œ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - start_numì´ 3ì´ê³  end_numì´ 10ì´ë¼ë©´ [3, 4, 5, 6, 7, 8, 9, 10]ì„ ë‹´ì€ ë°°ì—´ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ start_num â‰¤ end_num â‰¤ 50
 */

func solution15(_ start_num:Int, _ end_num:Int) -> [Int] {
    return Array(start_num...end_num)
}

/*:
 ## ì„¤ëª…
 - start_num...end_numìœ¼ë¡œ ì‹œì‘ ìˆ«ìë¶€í„° ë ìˆ«ìê¹Œì§€ì˜ ë‹«íŒ ë²”ìœ„ë¥¼ ìƒì„±
 - Array()ëŠ” ì´ ë²”ìœ„ë¥¼ ë°°ì—´ë¡œ ë°˜í™˜í•˜ë¯€ë¡œ Array(start_num...end_num) ì„ return
 */


/*:
 ## ğŸ“Œ ì¹´ìš´íŠ¸ ë‹¤ìš´
 MARK: ì¹´ìš´íŠ¸ ë‹¤ìš´
 
 - ì •ìˆ˜ start_numì™€ end_numê°€ ì£¼ì–´ì§ˆ ë•Œ, start_numì—ì„œ end_numê¹Œì§€ 1ì”© ê°ì†Œí•˜ëŠ” ìˆ˜ë“¤ì„ ì°¨ë¡€ë¡œ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - start_numì´ 10ì´ê³  end_numì´ 3ì´ë¼ë©´ [10, 9, 8, 7, 6, 5, 4, 3]ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ end_num â‰¤ start_num â‰¤ 50
 */


func solution16(_ start_num:Int, _ end_num:Int) -> [Int] {
    var a: [Int] = []
    
    for i in end_num...start_num {
        a.append(i)
    }
    return a.reversed()
}


/*:
 ## ì„¤ëª…
 - forë¬¸ì„ ì‚¬ìš©í•´ì„œ end_numë¶€í„° start_numê¹Œì§€ ì‹¤í–‰
 - ì‹¤í–‰ëœ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(a)ë¥¼ ì„ ì–¸ (ë‹¨, ë°°ì—´ë¡œ ê°’ì„ ì €ì¥í•´ì•¼ í•˜ë¯€ë¡œ ë¹ˆ ë°°ì—´ë¡œ ì„ ì–¸)
 - append í•¨ìˆ˜ë¡œ ië¥¼ aë°°ì—´ì— ì €ì¥
 - aë¥¼ ê·¸ëŒ€ë¡œ ë¦¬í„´í•˜ë©´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ê°’ì´ ë¦¬í„´ë˜ë¯€ë¡œ reversed() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ê°’ì„ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ë³€ê²½í•œ ë’¤ í•´ë‹¹ ê°’ì„ ë¦¬í„´
 */

/*:
 ## ğŸ“Œ në²ˆì§¸ ì›ì†Œë¶€í„°
 MARK: në²ˆì§¸ ì›ì†Œë¶€í„°
 
 - ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ num_listì™€ ì •ìˆ˜ nì´ ì£¼ì–´ì§ˆ ë•Œ, n ë²ˆì§¸ ì›ì†Œë¶€í„° ë§ˆì§€ë§‰ ì›ì†Œê¹Œì§€ì˜ ëª¨ë“  ì›ì†Œë¥¼ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [5, 2, 1, 7, 5] ì´ê³  nì´ 2 ë¼ë©´ 2ë²ˆì§¸ë¶€í„° ë‚˜ë¨¸ì§€ ë°°ì—´ì˜ ê°’ì„ ë¦¬í„´í•´ì•¼ í•˜ë¯€ë¡œ [2, 1, 7, 5]ë¥¼ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 30
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - 1 â‰¤ n â‰¤ num_listì˜ ê¸¸ì´
 */

func solution17(_ num_list:[Int], _ n:Int) -> [Int] {
    var sliceArray = Array(num_list[(n - 1)...])
    
    return sliceArray
}

/*:
 ## ì„¤ëª…
 - num_list[(n - 1)...]ë¥¼ ì‚¬ìš©í•´ në²ˆì§¸ ì¸ë±ìŠ¤(ë°°ì—´ì€ 0ë¶€í„° ì‹œì‘í•˜ë¯€ë¡œ n-1)ë¶€í„° ëê¹Œì§€ì˜ ë¶€ë¶„ ë°°ì—´ì„ ìƒì„±
 - ìƒì„±ëœ ë¶€ë¶„ ë°°ì—´ì„ Array()ë¡œ ë³€í™˜í•˜ì—¬ ìƒˆë¡œìš´ ë°°ì—´ sliceArrayì— ì €ì¥
 - ìµœì¢…ì ìœ¼ë¡œ sliceArrayë¥¼ ë°˜í™˜í•˜ì—¬ ì›ë³¸ ë°°ì—´ì˜ në²ˆì§¸ ìš”ì†Œë¶€í„° ëê¹Œì§€ì˜ ìš”ì†Œë“¤ì„ í¬í•¨í•˜ëŠ” ìƒˆ ë°°ì—´ì„ return
 */


/*:
 ## ğŸ“Œ ë¬¸ìì—´ ë°”ê¿”ì„œ ì°¾ê¸°
 MARK: ë¬¸ìì—´ ë°”ê¿”ì„œ ì°¾ê¸°
 
 - ë¬¸ì "A"ì™€ "B"ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ myStringê³¼ patê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. myStringì˜ "A"ë¥¼ "B"ë¡œ, "B"ë¥¼ "A"ë¡œ ë°”ê¾¼ ë¬¸ìì—´ì˜ ì—°ì†í•˜ëŠ” ë¶€ë¶„ ë¬¸ìì—´ ì¤‘ patì´ ìˆìœ¼ë©´ 1ì„ ì•„ë‹ˆë©´ 0ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myStringì´ "ABBAA", patì´ "AABB" ë¼ë©´ "ABBAA"ì—ì„œ "A"ì™€ "B"ë¥¼ ì„œë¡œ ë°”ê¾¸ë©´ "BAABB"ê°€ ë˜ëŠ”ë° ì—¬ê¸°ì—ëŠ” ë¶€ë¶„ë¬¸ìì—´ "AABB"ê°€ ìˆê¸° ë•Œë¬¸ì— 1ì„ returní•¨
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ patì˜ ê¸¸ì´ â‰¤ 10
 - myStringê³¼ patëŠ” ë¬¸ì "A"ì™€ "B"ë¡œë§Œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.
 */


func solution18(_ myString:String, _ pat:String) -> Int {
    let converted = myString.map { char -> Character in
        if char == "A" {
            return "B"
        } else if char == "B" {
            return "A"
        } else {
            return char
        }
    }
    
    let convertedString = String(converted)
    
    if convertedString.contains(pat) {
        return 1
    } else {
        return 0
    }
}


/*:
 ## ì„¤ëª…
 - myStringì˜ ê° ë¬¸ìë¥¼ ìˆœíšŒí•˜ë©´ì„œ AëŠ” Bë¡œ BëŠ” Aë¡œ ë³€í™˜
 - map í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ê° ë¬¸ìë¥¼ ë³€í™˜í•˜ê³  ë³€í™˜ëœ ë¬¸ì ë°°ì—´ì„ Stringìœ¼ë¡œ ë³€í™˜
 - contains ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì„œ ë³€í™˜ëœ ë¬¸ìì—´ì— patì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
 - if elseë¬¸ìœ¼ë¡œ ì¡´ì¬í•œë‹¤ë©´ 1ì„, ì—†ë‹¤ë©´ 0ì„ return
 */


/*:
 ## ğŸ“Œ ê°€ê¹Œìš´ 1 ì°¾ê¸°
 MARK: ê°€ê¹Œìš´ 1 ì°¾ê¸°
 
 - ì •ìˆ˜ ë°°ì—´ arrê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ì´ë•Œ arrì˜ ì›ì†ŒëŠ” 1 ë˜ëŠ” 0ì…ë‹ˆë‹¤. ì •ìˆ˜ idxê°€ ì£¼ì–´ì¡Œì„ ë•Œ, idxë³´ë‹¤ í¬ë©´ì„œ ë°°ì—´ì˜ ê°’ì´ 1ì¸ ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ë¥¼ ì°¾ì•„ì„œ ë°˜í™˜í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”. ë‹¨, ë§Œì•½ ê·¸ëŸ¬í•œ ì¸ë±ìŠ¤ê°€ ì—†ë‹¤ë©´ -1ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - arrì´ [0, 0, 0, 1]ì´ê³  idxê°€ 1ì´ë¼ë©´ 1ë³´ë‹¤ í¬ë©´ì„œ ì›ì†Œê°€ 1ì¸ ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ëŠ” 3ì´ë¯€ë¡œ 3ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 3 â‰¤ arrì˜ ê¸¸ì´ â‰¤ 100'000
 - arrì˜ ì›ì†ŒëŠ” ì „ë¶€ 1 ë˜ëŠ” 0ì…ë‹ˆë‹¤.
 
 */

func solution19(_ arr:[Int], _ idx:Int) -> Int {
    for i in (idx)..<arr.count {
        if arr[i] == 1 {
            return i
        }
    }
    return -1
}
/*
 ## ì„¤ëª…
 
 - ì •ìˆ˜ ë°°ì—´ arrê°€ ì£¼ì–´ì§€ê³ , ì›ì†ŒëŠ” 1 ë˜ëŠ” 0ìœ¼ë¡œ êµ¬ì„±ë¨
 - ì •ìˆ˜ idxê°€ ì£¼ì–´ì¡Œì„ ë•Œ, idxë¶€í„° ë°°ì—´ì„ ìˆœíšŒí•˜ë©´ì„œ ê°’ì´ 1ì¸ ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ë¥¼ ì°¾ìŒ
 - for ë°˜ë³µë¬¸ì„ ì‚¬ìš©í•´ idxë¶€í„° ë°°ì—´ì˜ ëê¹Œì§€ ìˆœì°¨ì ìœ¼ë¡œ í™•ì¸
 - ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì²« ë²ˆì§¸ ì¸ë±ìŠ¤ë¥¼ ë°œê²¬í•˜ë©´ ì¦‰ì‹œ í•´ë‹¹ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜
 - ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì¸ë±ìŠ¤ê°€ ì—†ëŠ” ê²½ìš° -1ì„ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ê°„ë‹¨í•œ ì‹ ê³„ì‚°í•˜ê¸°
 MARK: ê°„ë‹¨í•œ ì‹ ê³„ì‚°í•˜ê¸°
 
 - ë¬¸ìì—´ binomialì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. binomialì€ "a op b" í˜•íƒœì˜ ì´í•­ì‹ì´ê³  aì™€ bëŠ” ìŒì´ ì•„ë‹Œ ì •ìˆ˜, opëŠ” '+', '-', '*' ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ì‹ì„ ê³„ì‚°í•œ ì •ìˆ˜ë¥¼ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - binomialì´ "43 + 12" ë¼ë©´ 55ë¥¼ return
 - binomialì´ "0 - 7777" ë¼ë©´ -7777ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ a, b â‰¤ 40,000
 - 0ì„ ì œì™¸í•˜ê³  a, bëŠ” 0ìœ¼ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 */


import Foundation

func solution(_ binomial:String) -> Int {
    let components = binomial.split(separator: " ")
    
    if components.count == 3,
       let a = Int(components[0]),
       let b = Int(components[2]) {
        let op = String(components[1])
        
        switch op {
        case "+":
            return a + b
        case "-":
            return a - b
        case "*":
            return a * b
        default:
            return 0
        }
    }
    return 0
}

/*
 ## ì„¤ëª…
 - binomial ë¬¸ìì—´ì„ ê³µë°± ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ìœ„í•´ components ìƒìˆ˜ë¥¼ ì„ ì–¸
 - if letë¬¸ë²•ìœ¼ë¡œ componentsì˜ ê°œìˆ˜ê°€ 3ê°œë¼ë©´ ê°ê°ì˜ ìš”ì†Œë¥¼ a, b, op ë³€ìˆ˜ì— ëŒ€ì…(ì¡°ê±´ì‹ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ binomialì€ í˜•íƒœê°€ ê³ ì •ë˜ì–´ ìˆìœ¼ë¯€ë¡œ í•­ìƒ ê°œìˆ˜ê°€ 3ì„)
    - ë‹¨, ì´ë•Œ aì™€ bëŠ” Intë¡œ íƒ€ì… ë³€í™˜ì„ ì§„í–‰
 - switch caseë¬¸ìœ¼ë¡œ ê°ê°ì˜ ì—°ì‚°ì— ë§ê²Œ ê³„ì‚°ì„ ì§„í–‰í•˜ê³  í•´ë‹¹ ê°’ì„ return
 */
