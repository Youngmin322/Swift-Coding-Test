import Foundation

/*:
 # ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´
 ## ğŸ“Œ ê¸€ì ì´ì–´ ë¶™ì—¬ ë¬¸ìì—´ ë§Œë“¤ê¸°
 ì£¼ì–´ì§„ ë¬¸ìì—´ `my_string`ì—ì„œ `index_list`ì— í•´ë‹¹í•˜ëŠ” ë¬¸ìë“¤ì„ ìˆœì„œëŒ€ë¡œ ì¶”ì¶œí•˜ì—¬ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ `my_string`ê³¼ ì •ìˆ˜ ë°°ì—´ `index_list`ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
 - `index_list`ì˜ ì›ì†Œë“¤ì€ `my_string`ì˜ ì¸ë±ìŠ¤ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 - í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ë¬¸ìë“¤ì„ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì—¬ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë§Œë“­ë‹ˆë‹¤.
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - `1 â‰¤ my_string.count â‰¤ 1,000`
 - `1 â‰¤ index_list.count â‰¤ 1,000`
 - `0 â‰¤ index_list[i] < my_string.count`
 */

func solution(_ my_string: String, _ index_list: [Int]) -> String {
    let char = Array(my_string)  // ë¬¸ìì—´ì„ ë¬¸ì ë°°ì—´ë¡œ ë³€í™˜
    return index_list.map { String(char[$0]) }.joined()
}

/*:
 ## ì˜ˆì œ ì‹¤í–‰
 */

let my_string1 = "cvsgiorszzzmrpaqpe"
let index_list1 = [16, 6, 5, 3, 12, 14, 11, 11, 17, 12, 7]
solution(my_string1, index_list1)  // "programmers"

let my_string2 = "zpiaz"
let index_list2 = [1, 2, 0, 0, 3]
solution(my_string2, index_list2)  // "pizza"

/*:
 ## ì„¤ëª…
 - `Array(my_string)`: ë¬¸ìì—´ì„ ë°°ì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¬¸ì ì¸ë±ì‹±ì„ ì‰½ê²Œ ë§Œë“¦
 - `index_list.map { String(char[$0]) }`: ì£¼ì–´ì§„ ì¸ë±ìŠ¤ì˜ ë¬¸ìë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
 - `.joined()`: ëª¨ë“  ë¬¸ìë¥¼ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ í•©ì¹¨
 */

/*:
 ## ğŸ“Œ ì˜ë¼ì„œ ë°°ì—´ë¡œ ì €ì¥í•˜ê¸°
 ë¬¸ìì—´ my_strê³¼ nì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_strì„ ê¸¸ì´ nì”© ì˜ë¼ì„œ ì €ì¥í•œ ë°°ì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ `my_str`ê³¼ ë§¤ê°œë³€ìˆ˜ `n`ì´ ì£¼ì–´ì§
 - my_strì„ në§Œí¼ ì˜ë¼ì„œ ì €ì¥í•´ì•¼ ë¨
 - ì €ì¥í•œ ë°°ì—´ì„ ë‹¤ì‹œ returní•˜ë„ë¡ ì½”ë“œë¥¼ ì‘ì„±
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ my_strì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ n â‰¤ my_strì˜ ê¸¸ì´
 - my_strì€ ì•ŒíŒŒë²³ ì†Œë¬¸ì, ëŒ€ë¬¸ì, ìˆ«ìë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 
 */

func solution(_ my_str: String, _ n: Int) -> [String] {
    var result: [String] = []
    let length = my_str.count
    
    for i in stride(from: 0, to: length, by: n) {
        let start = my_str.index(my_str.startIndex, offsetBy: i)
        let end = my_str.index(start, offsetBy: n, limitedBy: my_str.endIndex) ?? my_str.endIndex
        result.append(String(my_str[start..<end]))
    }
    
    return result
}

/*:
 ## ì˜ˆì œ ì‹¤í–‰
 */

print(solution("abc1Addfggg4556b", 6)) // ["abc1Ad", "dfggg4", "556b"]
print(solution("abcdef123", 3)) // ["abc", "def", "123"]
print(solution("helloWorld", 4)) // ["hell", "oWor", "ld"]

/*:
 ## ì„¤ëª…
 - ê²°ê³¼ë¥¼ ì €ì¥í•  result ë°°ì—´ì„ ìƒì„±
 - stride(from:to:by:)ë¥¼ ì‚¬ìš©í•´ì„œ 0ë¶€í„° my_str.countê¹Œì§€ nê°„ê²©ìœ¼ë¡œ ìˆœíšŒí•˜ë©´ì„œ ë¬¸ìì—´ì„ ìë¦„
 - ë¬¸ìì—´ ìŠ¬ë¼ì´ì‹± (startIndex: í˜„ì¬ iìœ„ì¹˜ì—ì„œ ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤, endIndex: startIndexì—ì„œ në§Œí¼ ì´ë™, í•˜ì§€ë§Œ ë¬¸ìì—´ ëì„ ë„˜ìœ¼ë©´ endIndex = my_str.endIndex
 - ì˜ë¼ë‚¸ ë¬¸ìì—´ì„ ë°°ì—´ì— ì¶”ê°€
 - \* limitedBy: my_str.endIndexë¥¼ ì‚¬ìš©í•´ì„œ ë§ˆì§€ë§‰ ë‚¨ì€ ë¬¸ìì—´ë„ ê·¸ëŒ€ë¡œ ì¶”ê°€ë˜ë„ë¡ ì„¤ì •
 */


/*:
 ## ğŸ“Œ OX í€´ì¦ˆ
 ë§ì…ˆ, ëº„ì…ˆ ìˆ˜ì‹ë“¤ì´ 'X [ì—°ì‚°ì] Y = Z' í˜•íƒœë¡œ ë“¤ì–´ìˆëŠ” ë¬¸ìì—´ ë°°ì—´ quizê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. ìˆ˜ì‹ì´ ì˜³ë‹¤ë©´ "O"ë¥¼ í‹€ë¦¬ë‹¤ë©´ "X"ë¥¼ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë°°ì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ìˆ˜ì‹ì´ ë“¤ì–´ìˆëŠ” quizê°€ ë°°ì—´ë¡œ ì œê³µ
 - í•´ë‹¹ ë°°ì—´ì˜ ê³„ì‚° ê²°ê³¼ê°€ ë§ë‹¤ë©´ O, í‹€ë¦¬ë‹¤ë©´ Xë¥¼ ë¦¬í„´í•´ì•¼ í•¨
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - ì—°ì‚° ê¸°í˜¸ì™€ ìˆ«ì ì‚¬ì´ëŠ” í•­ìƒ í•˜ë‚˜ì˜ ê³µë°±ì´ ì¡´ì¬í•©ë‹ˆë‹¤. ë‹¨ ìŒìˆ˜ë¥¼ í‘œì‹œí•˜ëŠ” ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ì™€ ìˆ«ì ì‚¬ì´ì—ëŠ” ê³µë°±ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - 1 â‰¤ quizì˜ ê¸¸ì´ â‰¤ 10
 - X, Y, ZëŠ” ê°ê° 0ë¶€í„° 9ê¹Œì§€ ìˆ«ìë¡œ ì´ë£¨ì–´ì§„ ì •ìˆ˜ë¥¼ ì˜ë¯¸í•˜ë©°, ê° ìˆ«ìì˜ ë§¨ ì•ì— ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ê°€ í•˜ë‚˜ ìˆì„ ìˆ˜ ìˆê³  ì´ëŠ” ìŒìˆ˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
 - X, Y, ZëŠ” 0ì„ ì œì™¸í•˜ê³ ëŠ” 0ìœ¼ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - -10,000 â‰¤ X, Y â‰¤ 10,000
 - -20,000 â‰¤ Z â‰¤ 20,000
 - [ì—°ì‚°ì]ëŠ” + ì™€ - ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.
 
 
 */

func solution(_ quiz:[String]) -> [String] {
    var answer: [String] = []
    
    for q in quiz {
        let parts = q.components(separatedBy: " ")
        let x = Int(parts[0])!
        let y = Int(parts[2])!
        let z = Int(parts[4])!
        
        var result = 0
        
        switch parts[1] {
        case "+":
            result = x + y
        case "-":
            result = x - y
        default:
            break
        }
        
        answer.append(result == z ? "O" : "X")
    }
    
    return answer
}

/*:
 ## ì„¤ëª…
 - ê²°ê³¼ë¥¼ ì €ì¥í•  answer ë³€ìˆ˜ ì„ ì–¸ (ë‹¨, ë°°ì—´ì„ ë¦¬í„´í•´ì•¼ í•˜ë¯€ë¡œ ë¹ˆ ë°°ì—´ë¡œ ë³€ìˆ˜ë¥¼ ì„ ì–¸)
 - components(separatedBy: " ")ë¥¼ ì‚¬ìš©í•´ì„œ ê³µë°±ì„ ê¸°ì¤€ìœ¼ë¡œ ê° íŒŒì¸ ë³„ë¡œ ë‚˜ëˆ„ê³  ê°ê°ì˜ íŒŒì¸ ë³„ë¡œ ìˆ«ìëŠ” ì •ìˆ˜í˜•ìœ¼ë¡œ ì—°ì‚°ìëŠ” switch caseë¡œ ê³„ì‚°ì‹ì„ ë‚˜ëˆ”
 - xì—ëŠ” 0ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì…, yì—ëŠ” 2ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì…, zì—ëŠ” 4ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì… (!ì„ ì‚¬ìš©í•œ ì´ìœ ëŠ” ë¬´ì¡°ê±´ ê°’ì´ ìˆê¸° ë•Œë¬¸)
 - ê° ì¼€ì´ìŠ¤ ë³„ë¡œ ì¸ë±ìŠ¤ 1ë²ˆì„ ê°€ì§„ íŒŒì¸ ê°€ + ë¼ë©´ ë§ì…ˆ ì—°ì‚°ìë¥¼ ì‹¤í–‰, ë§Œì•½ - ë¼ë©´ ëº„ì…ˆ ì—°ì‚°ìë¥¼ ì‹¤í–‰í•˜ë„ë¡ ê²½ìš°ë¥¼ ë‚˜ëˆ”
 - ì‚¼í•­ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ì„œ ì •ë‹µì€ O, ì˜¤ë‹µì€ Xë¥¼ answer ë°°ì—´ì— ì¶”ê°€í•˜ê¸° ìœ„í•´ appendë¥¼ ì‚¬ìš©
 - answerë¥¼ ë¦¬í„´
 */
