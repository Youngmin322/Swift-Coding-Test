import Foundation

/*:
 # ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´
 ## ğŸ“Œ ê¸€ì ì´ì–´ ë¶™ì—¬ ë¬¸ìì—´ ë§Œë“¤ê¸°
 MARK: ê¸€ì ì´ì–´ ë¶™ì—¬ ë¬¸ìì—´ ë§Œë“¤ê¸°
 
 - ì£¼ì–´ì§„ ë¬¸ìì—´ `my_string`ì—ì„œ `index_list`ì— í•´ë‹¹í•˜ëŠ” ë¬¸ìë“¤ì„ ìˆœì„œëŒ€ë¡œ ì¶”ì¶œí•˜ì—¬ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ `my_string`ê³¼ ì •ìˆ˜ ë°°ì—´ `index_list`ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
 - `index_list`ì˜ ì›ì†Œë“¤ì€ `my_string`ì˜ ì¸ë±ìŠ¤ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 - í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ë¬¸ìë“¤ì„ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì—¬ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë§Œë“­ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - `1 â‰¤ my_string.count â‰¤ 1,000`
 - `1 â‰¤ index_list.count â‰¤ 1,000`
 - `0 â‰¤ index_list[i] < my_string.count`
 */

func solution1(_ my_string: String, _ index_list: [Int]) -> String {
    let char = Array(my_string)  // ë¬¸ìì—´ì„ ë¬¸ì ë°°ì—´ë¡œ ë³€í™˜
    return index_list.map { String(char[$0]) }.joined()
}

/*:
 ## ì˜ˆì œ ì‹¤í–‰
 */

let my_string1 = "cvsgiorszzzmrpaqpe"
let index_list1 = [16, 6, 5, 3, 12, 14, 11, 11, 17, 12, 7]
solution1(my_string1, index_list1)  // "programmers"

let my_string2 = "zpiaz"
let index_list2 = [1, 2, 0, 0, 3]
solution1(my_string2, index_list2)  // "pizza"

/*:
 ## ì„¤ëª…
 - `Array(my_string)`: ë¬¸ìì—´ì„ ë°°ì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¬¸ì ì¸ë±ì‹±ì„ ì‰½ê²Œ ë§Œë“¦
 - `index_list.map { String(char[$0]) }`: ì£¼ì–´ì§„ ì¸ë±ìŠ¤ì˜ ë¬¸ìë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
 - `.joined()`: ëª¨ë“  ë¬¸ìë¥¼ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ í•©ì¹¨
 */

/*:
 ## ğŸ“Œ ì˜ë¼ì„œ ë°°ì—´ë¡œ ì €ì¥í•˜ê¸°
 MARK: ì˜ë¼ì„œ ë°°ì—´ë¡œ ì €ì¥í•˜ê¸°
 
 - ë¬¸ìì—´ my_strê³¼ nì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_strì„ ê¸¸ì´ nì”© ì˜ë¼ì„œ ì €ì¥í•œ ë°°ì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ `my_str`ê³¼ ë§¤ê°œë³€ìˆ˜ `n`ì´ ì£¼ì–´ì§
 - my_strì„ në§Œí¼ ì˜ë¼ì„œ ì €ì¥í•´ì•¼ ë¨
 - ì €ì¥í•œ ë°°ì—´ì„ ë‹¤ì‹œ returní•˜ë„ë¡ ì½”ë“œë¥¼ ì‘ì„±
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ my_strì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ n â‰¤ my_strì˜ ê¸¸ì´
 - my_strì€ ì•ŒíŒŒë²³ ì†Œë¬¸ì, ëŒ€ë¬¸ì, ìˆ«ìë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 
 */

func solution2(_ my_str: String, _ n: Int) -> [String] {
    var result: [String] = []
    let length = my_str.count
    
    for i in stride(from: 0, to: length, by: n) {
        let start = my_str.index(my_str.startIndex, offsetBy: i)
        let end = my_str.index(start, offsetBy: n, limitedBy: my_str.endIndex) ?? my_str.endIndex
        result.append(String(my_str[start..<end]))
    }
    
    return result
}

/*:
 ## ì˜ˆì œ ì‹¤í–‰
 */

//print(solution("abc1Addfggg4556b", 6)) // ["abc1Ad", "dfggg4", "556b"]
//print(solution("abcdef123", 3)) // ["abc", "def", "123"]
//print(solution("helloWorld", 4)) // ["hell", "oWor", "ld"]

/*:
 ## ì„¤ëª…
 - ê²°ê³¼ë¥¼ ì €ì¥í•  result ë°°ì—´ì„ ìƒì„±
 - stride(from:to:by:)ë¥¼ ì‚¬ìš©í•´ì„œ 0ë¶€í„° my_str.countê¹Œì§€ nê°„ê²©ìœ¼ë¡œ ìˆœíšŒí•˜ë©´ì„œ ë¬¸ìì—´ì„ ìë¦„
 - ë¬¸ìì—´ ìŠ¬ë¼ì´ì‹± (startIndex: í˜„ì¬ iìœ„ì¹˜ì—ì„œ ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤, endIndex: startIndexì—ì„œ në§Œí¼ ì´ë™, í•˜ì§€ë§Œ ë¬¸ìì—´ ëì„ ë„˜ìœ¼ë©´ endIndex = my_str.endIndex
 - ì˜ë¼ë‚¸ ë¬¸ìì—´ì„ ë°°ì—´ì— ì¶”ê°€
 - \* limitedBy: my_str.endIndexë¥¼ ì‚¬ìš©í•´ì„œ ë§ˆì§€ë§‰ ë‚¨ì€ ë¬¸ìì—´ë„ ê·¸ëŒ€ë¡œ ì¶”ê°€ë˜ë„ë¡ ì„¤ì •
 */


/*:
 ## ğŸ“Œ OX í€´ì¦ˆ
 MARK: OX í€´ì¦ˆ
 
 - ë§ì…ˆ, ëº„ì…ˆ ìˆ˜ì‹ë“¤ì´ 'X [ì—°ì‚°ì] Y = Z' í˜•íƒœë¡œ ë“¤ì–´ìˆëŠ” ë¬¸ìì—´ ë°°ì—´ quizê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. ìˆ˜ì‹ì´ ì˜³ë‹¤ë©´ "O"ë¥¼ í‹€ë¦¬ë‹¤ë©´ "X"ë¥¼ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë°°ì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ìˆ˜ì‹ì´ ë“¤ì–´ìˆëŠ” quizê°€ ë°°ì—´ë¡œ ì œê³µ
 - í•´ë‹¹ ë°°ì—´ì˜ ê³„ì‚° ê²°ê³¼ê°€ ë§ë‹¤ë©´ O, í‹€ë¦¬ë‹¤ë©´ Xë¥¼ ë¦¬í„´í•´ì•¼ í•¨
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - ì—°ì‚° ê¸°í˜¸ì™€ ìˆ«ì ì‚¬ì´ëŠ” í•­ìƒ í•˜ë‚˜ì˜ ê³µë°±ì´ ì¡´ì¬í•©ë‹ˆë‹¤. ë‹¨ ìŒìˆ˜ë¥¼ í‘œì‹œí•˜ëŠ” ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ì™€ ìˆ«ì ì‚¬ì´ì—ëŠ” ê³µë°±ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - 1 â‰¤ quizì˜ ê¸¸ì´ â‰¤ 10
 - X, Y, ZëŠ” ê°ê° 0ë¶€í„° 9ê¹Œì§€ ìˆ«ìë¡œ ì´ë£¨ì–´ì§„ ì •ìˆ˜ë¥¼ ì˜ë¯¸í•˜ë©°, ê° ìˆ«ìì˜ ë§¨ ì•ì— ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ê°€ í•˜ë‚˜ ìˆì„ ìˆ˜ ìˆê³  ì´ëŠ” ìŒìˆ˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
 - X, Y, ZëŠ” 0ì„ ì œì™¸í•˜ê³ ëŠ” 0ìœ¼ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - -10,000 â‰¤ X, Y â‰¤ 10,000
 - -20,000 â‰¤ Z â‰¤ 20,000
 - [ì—°ì‚°ì]ëŠ” + ì™€ - ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.
 */

func solution3(_ quiz:[String]) -> [String] {
    var answer: [String] = []
    
    for q in quiz {
        let parts = q.components(separatedBy: " ")
        let x = Int(parts[0])!
        let y = Int(parts[2])!
        let z = Int(parts[4])!
        
        var result = 0
        
        switch parts[1] {
        case "+":
            result = x + y
        case "-":
            result = x - y
        default:
            break
        }
        
        answer.append(result == z ? "O" : "X")
    }
    
    return answer
}

/*:
 ## ì„¤ëª…
 - ê²°ê³¼ë¥¼ ì €ì¥í•  answer ë³€ìˆ˜ ì„ ì–¸ (ë‹¨, ë°°ì—´ì„ ë¦¬í„´í•´ì•¼ í•˜ë¯€ë¡œ ë¹ˆ ë°°ì—´ë¡œ ë³€ìˆ˜ë¥¼ ì„ ì–¸)
 - components(separatedBy: " ")ë¥¼ ì‚¬ìš©í•´ì„œ ê³µë°±ì„ ê¸°ì¤€ìœ¼ë¡œ ê° íŒŒì¸ ë³„ë¡œ ë‚˜ëˆ„ê³  ê°ê°ì˜ íŒŒì¸ ë³„ë¡œ ìˆ«ìëŠ” ì •ìˆ˜í˜•ìœ¼ë¡œ ì—°ì‚°ìëŠ” switch caseë¡œ ê³„ì‚°ì‹ì„ ë‚˜ëˆ”
 - xì—ëŠ” 0ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì…, yì—ëŠ” 2ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì…, zì—ëŠ” 4ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì… (!ì„ ì‚¬ìš©í•œ ì´ìœ ëŠ” ë¬´ì¡°ê±´ ê°’ì´ ìˆê¸° ë•Œë¬¸)
 - ê° ì¼€ì´ìŠ¤ ë³„ë¡œ ì¸ë±ìŠ¤ 1ë²ˆì„ ê°€ì§„ íŒŒì¸ ê°€ + ë¼ë©´ ë§ì…ˆ ì—°ì‚°ìë¥¼ ì‹¤í–‰, ë§Œì•½ - ë¼ë©´ ëº„ì…ˆ ì—°ì‚°ìë¥¼ ì‹¤í–‰í•˜ë„ë¡ ê²½ìš°ë¥¼ ë‚˜ëˆ”
 - ì‚¼í•­ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ì„œ ì •ë‹µì€ O, ì˜¤ë‹µì€ Xë¥¼ answer ë°°ì—´ì— ì¶”ê°€í•˜ê¸° ìœ„í•´ appendë¥¼ ì‚¬ìš©
 - answerë¥¼ ë¦¬í„´
 */



/*:
 ## ğŸ“Œ ë‹¤ìŒì— ì˜¬ ìˆ«ì
 MARK: ë‹¤ìŒì— ì˜¬ ìˆ«ì
 
 - ë“±ì°¨ìˆ˜ì—´ í˜¹ì€ ë“±ë¹„ìˆ˜ì—´ commonì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë§ˆì§€ë§‰ ì›ì†Œ ë‹¤ìŒìœ¼ë¡œ ì˜¬ ìˆ«ìë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ë³´ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë°°ì—´ì´ [1, 2, 3, 4] ë¼ë©´ ê³µì°¨ê°€ 1ì¸ ë“±ì°¨ìˆ˜ì—´ì´ë¯€ë¡œ ë‹¤ìŒì— ì˜¬ ìˆ˜ëŠ” 5ì´ë¯€ë¡œ 5ì„ return
 - ë°°ì—´ì´ [2, 4, 8] ë¼ë©´ ê³µë¹„ê°€ 2ì¸ ë“±ë¹„ìˆ˜ì—´ì´ë¯€ë¡œ ë‹¤ìŒì— ì˜¬ ìˆ˜ëŠ” 16ì´ë¯€ë¡œ 16ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 < commonì˜ ê¸¸ì´ < 1,000
 - -1,000 < commonì˜ ì›ì†Œ < 2,000
 - commonì˜ ì›ì†ŒëŠ” ëª¨ë‘ ì •ìˆ˜ì…ë‹ˆë‹¤.
 - ë“±ì°¨ìˆ˜ì—´ í˜¹ì€ ë“±ë¹„ìˆ˜ì—´ì´ ì•„ë‹Œ ê²½ìš°ëŠ” ì—†ìŠµë‹ˆë‹¤.
 - ë“±ë¹„ìˆ˜ì—´ì¸ ê²½ìš° ê³µë¹„ëŠ” 0ì´ ì•„ë‹Œ ì •ìˆ˜ì…ë‹ˆë‹¤.
 
 */

func solution4(_ common:[Int]) -> Int {
    
    if common[1] - common[0] == common[2] - common[1] {
        let difference = common[1] - common[0]
        return common.last! + difference
    } else {
        let ratio = common[2] / common[1]
        return common.last! * ratio
    }
}

/*:
 ## ì„¤ëª…
 - ìš°ì„  ë“±ì°¨ìˆ˜ì—´ì¸ì§€ ë“±ë¹„ìˆ˜ì—´ì¸ì§€ íŒë‹¨í•˜ê¸° ìœ„í•´ common[1] - common[0] == common[2] - common[1] ë¹„êµ (í•´ë‹¹ ì‹ì´ ì„±ë¦½í•˜ë©´ ë“±ì°¨ìˆ˜ì—´, ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ ë“±ë¹„ìˆ˜ì—´)
 - ë§Œì•½ ë“±ì°¨ìˆ˜ì—´ì´ë¼ë©´ ì¸ë±ìŠ¤ 1ë²ˆê³¼ ì¸ë±ìŠ¤ 0ì„ ëº€ ê°’ì´ ê³µì°¨ì´ë¯€ë¡œ í•´ë‹¹ ê³µì°¨ë¥¼ difference ë³€ìˆ˜ì— ëŒ€ì…í•´ì£¼ê³  return ê°’ìœ¼ë¡œ commonì˜ ë§ˆì§€ë§‰ í•­ì— ë”í•´ì¤Œ
 - ë§Œì•½ ë“±ë¹„ìˆ˜ì—´ì´ë¼ë©´ ì¸ë±ìŠ¤ 2ë²ˆê³¼ 1ë²ˆì„ ë‚˜ëˆˆ ê°’ì„ ratio ë³€ìˆ˜ì— ëŒ€ì…í•´ì£¼ê³  return ê°’ìœ¼ë¡œ commonì˜ ë§ˆì§€ë§‰ í•­ì— ratio ë³€ìˆ˜ë¥¼ ê³±í•œ ê°’ì„ ë°˜í™˜
 - ë¬¸ì œ ì¡°ê±´ì— ë”°ë¥´ë©´ ë“±ë¹„ìˆ˜ì—´ì˜ ê³µë¹„ëŠ” 0ì´ ì•„ë‹Œ ì •ìˆ˜ì´ë¯€ë¡œ, ë‚˜ëˆ—ì…ˆ ì—°ì‚°ì—ì„œ ë¬¸ì œê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ
 - \*common.last!ëŠ” ë°°ì—´ì˜ ë§ˆì§€ë§‰ ìš”ì†Œë¥¼ ê°€ì ¸ì˜´
 */


/*:
 ## ğŸ“Œ ë‹¤ìŒì— ì˜¬ ìˆ«ì
 MARK: ë‹¤ìŒì— ì˜¬ ìˆ«ì
 
 - êµ° ì „ëµê°€ ë¨¸ì“±ì´ëŠ” ì „ìŸ ì¤‘ ì êµ°ì´ ë‹¤ìŒê³¼ ê°™ì€ ì•”í˜¸ ì²´ê³„ë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒì„ ì•Œì•„ëƒˆìŠµë‹ˆë‹¤.
 - ì•”í˜¸í™”ëœ ë¬¸ìì—´ cipherë¥¼ ì£¼ê³ ë°›ìŠµë‹ˆë‹¤.
 - ê·¸ ë¬¸ìì—´ì—ì„œ codeì˜ ë°°ìˆ˜ ë²ˆì§¸ ê¸€ìë§Œ ì§„ì§œ ì•”í˜¸ì…ë‹ˆë‹¤.
 - ë¬¸ìì—´ cipherì™€ ì •ìˆ˜ codeê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ í•´ë…ëœ ì•”í˜¸ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ cipherê°€ "dfjardstddetckdaccccdegk" ì´ê³  codeê°€ 4ë¡œ ì£¼ì–´ì§„ë‹¤ë©´ 4, 8, 16, 20, 14ë²ˆì§¸ ê¸€ìë¥¼ í•©ì¹œ "attackì„ return í•´ì•¼ í•¨
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 < commonì˜ ê¸¸ì´ < 1,000
 - -1,000 < commonì˜ ì›ì†Œ < 2,000
 - commonì˜ ì›ì†ŒëŠ” ëª¨ë‘ ì •ìˆ˜ì…ë‹ˆë‹¤.
 - ë“±ì°¨ìˆ˜ì—´ í˜¹ì€ ë“±ë¹„ìˆ˜ì—´ì´ ì•„ë‹Œ ê²½ìš°ëŠ” ì—†ìŠµë‹ˆë‹¤.
 - ë“±ë¹„ìˆ˜ì—´ì¸ ê²½ìš° ê³µë¹„ëŠ” 0ì´ ì•„ë‹Œ ì •ìˆ˜ì…ë‹ˆë‹¤.
 
 */


func solution5(_ cipher:String, _ code:Int) -> String {
    return cipher.enumerated()
        .filter { ($0.offset + 1) % code == 0 }
        .map { String($0.element) }
        .joined()
}

/*:
 ## ì„¤ëª…
 - enumerated()ë¥¼ ì‚¬ìš©í•´ì„œ ê° ë¬¸ìì— ëŒ€í•´ ì¸ë±ìŠ¤ë¥¼ ê°€ì ¸ì˜´
 - \* enumerated()ëŠ” Swiftì—ì„œ ê° ìš”ì†Œì˜ ì¸ë±ìŠ¤ì™€ ê°’ì„ í•¨ê»˜ ê°€ì ¸ì˜¤ëŠ” ë©”ì„œë“œ (ê° ìš”ì†Œê°€ ëª‡ ë²ˆì§¸ ìœ„ì¹˜ì— ìˆëŠ”ì§€ ì•Œì•„ì•¼ í•  ë•Œ ì‚¬ìš©)
 - filter í•¨ìˆ˜ë¥¼ í†µí•´ codeì˜ ë°°ìˆ˜ì¸ ì¸ë±ìŠ¤ë§Œ ë‚¨ê¸°ê¸° ìœ„í•´ ($0.offset + 1) % code == 0} ì„ ì‘ì„±, offsetì€ ê¸°ë³¸ì ìœ¼ë¡œ 0ë¶€í„° ì‹œì‘í•˜ê¸° ë•Œë¬¸ì— +1ì„ í•´ì¤˜ì„œ 1ë¶€í„° ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤ë¡œ ì‚¬ìš©
 - filterë¡œ ë¶„ë¥˜í•œ ê²ƒì„ Stringìœ¼ë¡œ ë³€í™˜í•´ì£¼ê³  mapì„ ì‚¬ìš©í•´ì„œ í•˜ë‚˜ì˜ ë°°ì—´ë¡œ ë§Œë“¦
 - joined()ë¥¼ ì‚¬ìš©í•´ì„œ í•„í„°ë§ëœ ë¬¸ìë“¤ì„ í•©ì³ ìµœì¢… ë¬¸ìì—´ì„ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ í° ì‚¬ëŒ
 MARK: ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ í° ì‚¬ëŒ
 
 
 - ë¨¸ì“±ì´ëŠ” í•™êµì—ì„œ í‚¤ ìˆœìœ¼ë¡œ ì¤„ì„ ì„¤ ë•Œ ëª‡ ë²ˆì§¸ë¡œ ì„œì•¼ í•˜ëŠ”ì§€ ê¶ê¸ˆí•´ì¡ŒìŠµë‹ˆë‹¤. ë¨¸ì“±ì´ë„¤ ë°˜ ì¹œêµ¬ë“¤ì˜ í‚¤ê°€ ë‹´ê¸´ ì •ìˆ˜ ë°°ì—´ arrayì™€ ë¨¸ì“±ì´ì˜ í‚¤ heightê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ í° ì‚¬ëŒ ìˆ˜ë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ë³´ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ ë¨¸ì“±ì´ì˜ í‚¤(height)ê°€ 140ì´ê³  ì¹œêµ¬ë“¤ì˜ í‚¤(array)ê°€ [145, 130, 160, 180] ì´ë¼ë©´ 3ì„ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ arrayì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ height â‰¤ 200
 - 1 â‰¤ arrayì˜ ì›ì†Œ â‰¤ 200
 
 */


func solution6(_ array:[Int], _ height:Int) -> Int {
    let tallerPeople = array.filter{ $0 > height }
    return tallerPeople.count
}


/*:
 ## ì„¤ëª…
 - ìš°ì„  ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ê°€ í° ì‚¬ëŒì„ ë¶„ë¥˜í•˜ê¸° ìœ„í•´ filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê³  í•´ë‹¹ ê°’ì„ ë‹´ì„ ë³€ìˆ˜(tallerPeople)ë¥¼ ì„ ì–¸
 - return ê°’ì„ tallerPeopleë¡œ í•˜ê³  ë°˜í™˜í•´ì•¼ í•˜ëŠ” ê°’ì´ í‚¤ê°€ ì•„ë‹Œ í‚¤ í° ì‚¬ëŒì˜ ìˆ˜ì´ë¯€ë¡œ tallerPeople.countë¡œ ê°œìˆ˜ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆë„ë¡ ì‘ì„±
 */


/*:
 ## ğŸ“Œ ëª¨ìŒ ì œê±°
 MARK: ëª¨ìŒ ì œê±°
 
 - ì˜ì–´ì—ì„  a, e, i, o, u ë‹¤ì„¯ ê°€ì§€ ì•ŒíŒŒë²³ì„ ëª¨ìŒìœ¼ë¡œ ë¶„ë¥˜í•©ë‹ˆë‹¤. ë¬¸ìì—´ my_stringì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ ëª¨ìŒì„ ì œê±°í•œ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ my_stringìœ¼ë¡œ busê°€ ì£¼ì–´ì§„ë‹¤ë©´, uë¥¼ ì œê±°í•œ bsë¥¼ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - my_stringì€ ì†Œë¬¸ìì™€ ê³µë°±ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 */


func solution7(_ my_string:String) -> String {
    return my_string.filter { !["a", "e", "i", "o", "u"].contains($0) }
    
}

/*:
 ## ì„¤ëª…
 - filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ a, e, i, o, uê°€ ì•„ë‹Œ(!) ìš”ì†Œë“¤ì„ ë½‘ì•„ì„œ return
 */

/*:
 ## ğŸ“Œ ì¹˜í‚¨ ì¿ í°
 MARK: ì¹˜í‚¨ ì¿ í°
 
 - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì¹˜í‚¨ì€ ì¹˜í‚¨ì„ ì‹œì¼œë¨¹ìœ¼ë©´ í•œ ë§ˆë¦¬ë‹¹ ì¿ í°ì„ í•œ ì¥ ë°œê¸‰í•©ë‹ˆë‹¤. ì¿ í°ì„ ì—´ ì¥ ëª¨ìœ¼ë©´ ì¹˜í‚¨ì„ í•œ ë§ˆë¦¬ ì„œë¹„ìŠ¤ë¡œ ë°›ì„ ìˆ˜ ìˆê³ , ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ë„ ì¿ í°ì´ ë°œê¸‰ë©ë‹ˆë‹¤. ì‹œì¼œë¨¹ì€ ì¹˜í‚¨ì˜ ìˆ˜ chickenì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ ë°›ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì„œë¹„ìŠ¤ ì¹˜í‚¨ì˜ ìˆ˜ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ ì¹˜í‚¨ì„ 100ë§ˆë¦¬ ì‹œì¼°ë‹¤ë©´ ì¿ í° 100ì¥ì´ ë°œê¸‰ë˜ë¯€ë¡œ ì„œë¹„ìŠ¤ ì¹˜í‚¨ 10ë§ˆë¦¬ë¥¼ ì£¼ë¬¸í•  ìˆ˜ ìˆê³  ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ë„ ì¿ í°ì´ ë°œê¸‰ë˜ë¯€ë¡œ ì„œë¹„ìŠ¤ ì¹˜í‚¨ 10ë§ˆë¦¬ì— + ì„œë¹„ìŠ¤ ì¹˜í‚¨ìœ¼ë¡œ ë°›ì€ ì¿ í°(10ì¥)ìœ¼ë¡œ ì¹˜í‚¨ 1ë§ˆë¦¬ë¥¼ ë” ì£¼ë¬¸í•´ì„œ ì´ 11ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - chickenì€ ì •ìˆ˜ì…ë‹ˆë‹¤.
 - 0 â‰¤ chicken â‰¤ 1,000,000
 */


func solution8(_ chicken:Int) -> Int {
    if chicken < 10 {
        return 0
    }
    let service = chicken / 10
    return service + solution8(service + (chicken % 10))
}

/*:
 ## ì„¤ëª…
 - ì¹˜í‚¨ì´ 10ì´ ë„˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì²˜ë¦¬í•  ê²Œ ì—†ìœ¼ë¯€ë¡œ 0ì„ return
 - í˜„ì¬ ì¹˜í‚¨ ìˆ˜ì—ì„œ 10ë§ˆë¦¬ë‹¹ 1ë§ˆë¦¬ì”© ì„œë¹„ìŠ¤ ì¹˜í‚¨ì„ ë°›ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ chicken / 10ì„ ê³„ì‚°
 - í˜„ì¬ ì„œë¹„ìŠ¤ ì¹˜í‚¨ ê°œìˆ˜(service)ë¥¼ ë”í•œ í›„, ì¬ê·€ í˜¸ì¶œì„ í•¨
 - ì¬ê·€í˜¸ì¶œ ì¸ìëŠ” (service + (chicken % 10))
 - ì¦‰, í˜„ì¬ ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ì„œ ë°›ì€ ì¿ í°ê³¼ ê¸°ì¡´ì˜ ë‚¨ì€ ì¿ í°ì„ í•©ì³ì„œ ì¬ê·€ í˜¸ì¶œì„ í•¨
 - \* ì¬ê·€ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ì¹˜í‚¨ì„ ë¨¹ìœ¼ë©´ ì¿ í°ì´ ë‚˜ì˜¤ê³ , ì¿ í°ì´ 10ì¥ì´ ë„˜ìœ¼ë©´ ë‹¤ì‹œ ì¹˜í‚¨ì„ ë°›ì„ ìˆ˜ ìˆëŠ” êµ¬ì¡°ì´ë¯€ë¡œ ê³„ì† ë°˜ë³µë¨ ì¦‰, í•œ ë²ˆ ì¹˜í‚¨ì„ ì„œë¹„ìŠ¤ë¡œ ë°›ì€ í›„ ê·¸ ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ì„œ ë˜ ì¿ í°ì´ ë‚˜ì˜¤ëŠ” ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— ì¬ê·€ë¥¼ ì‚¬ìš©
 */




/*:
 ## ğŸ“Œ ê°€ìœ„ ë°”ìœ„ ë³´
 MARK: ê°€ìœ„ ë°”ìœ„ ë³´
 
 - ê°€ìœ„ëŠ” 2 ë°”ìœ„ëŠ” 0 ë³´ëŠ” 5ë¡œ í‘œí˜„í•©ë‹ˆë‹¤. ê°€ìœ„ ë°”ìœ„ ë³´ë¥¼ ë‚´ëŠ” ìˆœì„œëŒ€ë¡œ ë‚˜íƒ€ë‚¸ ë¬¸ìì—´ rspê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, rspì— ì €ì¥ëœ ê°€ìœ„ ë°”ìœ„ ë³´ë¥¼ ëª¨ë‘ ì´ê¸°ëŠ” ê²½ìš°ë¥¼ ìˆœì„œëŒ€ë¡œ ë‚˜íƒ€ë‚¸ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ë³´ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - rspì˜ ê°’ì´ 2(ê°€ìœ„)ë¼ë©´ 0(ë°”ìœ„)ì„ ë¦¬í„´
 - rspì˜ ê°’ì´ 205(ê°€ìœ„ ë°”ìœ„ ë³´)ë¼ë©´ 052(ë°”ìœ„ ë³´ ê°€ìœ„)ë¥¼ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 < rspì˜ ê¸¸ì´ â‰¤ 100
 - rspì™€ ê¸¸ì´ê°€ ê°™ì€ ë¬¸ìì—´ì„ return í•©ë‹ˆë‹¤.
 - rspëŠ” ìˆ«ì 0, 2, 5ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 
 */


func Solution9(_ rsp:String) -> String {
    let mapping: [String: String] = ["2": "0", "0": "5", "5": "2"]
    
    return rsp.map { mapping[String($0)] ?? "?" }.joined()
}

/*:
 ## ì„¤ëª…
 - ê° ì¼€ì´ìŠ¤ ë³„ë¡œ ë¦¬í„´í•´ì•¼ í•˜ëŠ” ê²ƒì´ ì •í•´ì ¸ ìˆê¸° ë•Œë¬¸ì— key value ë§¤í•‘ì„ ì‚¬ìš©í•´ì„œ 2ëŠ” 0, 0ì€ 5, 5ëŠ” 2ë¡œ ì¹˜í™˜ì„ í•´ì¤Œ
 - rspì˜ ê° ë¬¸ìì— ëŒ€í•´ mapping ë”•ì…”ë„ˆë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë³€í™˜í•˜ê³ , ë³€í™˜ëœ ë¬¸ìë“¤ì„ joined()ë¥¼ ì‚¬ìš©í•´ì„œ ë‹¤ì‹œ í•©ì³ì„œ return
 */

/*:
 ## ğŸ“Œ ì§ìˆ˜ì˜ í•©
 MARK: ì§ìˆ˜ì˜ í•©
 
 - ì •ìˆ˜ nì´ ì£¼ì–´ì§ˆ ë•Œ, nì´í•˜ì˜ ì§ìˆ˜ë¥¼ ëª¨ë‘ ë”í•œ ê°’ì„ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ nì´ 10ì´ë¼ë©´ 2 + 4 + 6 + 8 + 10 = 30ì´ë¯€ë¡œ 30ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 < n â‰¤ 1000
 */

func solution9(_ n:Int) -> Int {
    var sum = 0
    for i in 1...n {
        if i % 2 == 0 {
            sum += i
        }
    }
    return sum
}

/*:
 ## ì„¤ëª…
 - ë”í•œ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(sum)ë¥¼ ì„ ì–¸í•˜ê³  0ìœ¼ë¡œ ì´ˆê¸°í™”
 - forë¬¸ê³¼ ifë¬¸ì„ ì´ìš©í•´ì„œ 1ë¶€í„° ì •ìˆ˜ nê¹Œì§€ i ë¥¼ 2ë¡œ ë‚˜ëˆ„ì–´ì„œ 0ì´ ë˜ëŠ” ê°’ë“¤ë§Œ sum ë³€ìˆ˜ì— ë”í•´ì¤Œ
 - í•´ë‹¹ ê°’ë“¤ì´ ë‹¤ ë”í•´ì§„ sum ë³€ìˆ˜ë¥¼ return
 */


/*:
 ## ğŸ“Œ ë§ˆì§€ë§‰ ë‘ ì›ì†Œ
 MARK: ë§ˆì§€ë§‰ ë‘ ì›ì†Œ
 
 - ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§ˆ ë•Œ, ë§ˆì§€ë§‰ ì›ì†Œê°€ ê·¸ì „ ì›ì†Œë³´ë‹¤ í¬ë©´ ë§ˆì§€ë§‰ ì›ì†Œì—ì„œ ê·¸ì „ ì›ì†Œë¥¼ ëº€ ê°’ì„ ë§ˆì§€ë§‰ ì›ì†Œê°€ ê·¸ì „ ì›ì†Œë³´ë‹¤ í¬ì§€ ì•Šë‹¤ë©´ ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ë‘ ë°°í•œ ê°’ì„ ì¶”ê°€í•˜ì—¬ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [2, 1, 6]ë¼ê³  ì£¼ì–´ì¡Œë‹¤ë©´ ë§ˆì§€ë§‰ ì›ì†Œì¸ 6ì´ ê·¸ ì „ ì›ì†Œì¸ 1ë³´ë‹¤ í¬ê¸° ë•Œë¬¸ì— 6 - 1ì¸ 5ë¥¼ ì¶”ê°€í•œ [2, 1, 6, 5]ë¥¼ ë¦¬í„´
 - num_listê°€ [5, 2, 1, 7, 5]ë¼ê³  ì£¼ì–´ì¡Œë‹¤ë©´ ë§ˆì§€ë§‰ ì›ì†Œì¸ 5ê°€ ê·¸ ì „ ì›ì†Œì¸ 7ë³´ë‹¤ í¬ì§€ ì•Šê¸° ë•Œë¬¸ì— 5ì˜ 2ë°°ì¸ 10ì„ ì¶”ê°€í•œ [5, 2, 1, 7, 5, 10]ì„ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 */


func solution10(_ num_list:[Int]) -> [Int] {
    let lastValue = num_list[num_list.count - 1]
    let secondLastValue = num_list[num_list.count - 2]
    var subValue = lastValue - secondLastValue
    
    if lastValue > secondLastValue {
        return num_list + [subValue]
    } else {
        return num_list + [lastValue * 2]
    }
}

/*:
 ## ì„¤ëª…
 - ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ë‹´ì„ ë³€ìˆ˜(lastValue)ì™€ ë§ˆì§€ë§‰ ì›ì†Œì—ì„œ ê·¸ ì „ ì›ì†Œì˜ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(secondLastValue)ë¥¼ ì„ ì–¸í•´ì£¼ê³  ë‘ ê°’ì„ ëº€ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(subValue)ë¥¼ ì„ ì–¸í•¨
 - ifë¬¸ìœ¼ë¡œ ë§ˆì§€ë§‰ ì›ì†Œê°€ ë” í¬ë‹¤ë©´ ê¸°ì¡´ ë°°ì—´(num_list)ì— ë‘ ê°’ì€ ëº€ ë³€ìˆ˜ë¥¼ ì¶”ê°€í•´ì£¼ê³  return
 - ê·¸ ì™¸ë¼ë©´ ê¸°ì¡´ ë°°ì—´ì— ë§ˆì§€ë§‰ ì›ì†Œì— 2ë°°ë¥¼ í•œ ê°’ì„ ë¦¬í„´
 */



/*:
 ## ğŸ“Œ í™€ìˆ˜ vs ì§ìˆ˜
 MARK: í™€ìˆ˜ vs ì§ìˆ˜
 
 - ì •ìˆ˜ê°€ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. num_listì˜ í™€ìˆ˜ë§Œ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì¸ ìˆ˜ì™€ ì§ìˆ˜ë§Œ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì¸ ìˆ˜ì˜ í•©ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [3, 4, 5, 2, 1]ë¡œ ì£¼ì–´ì¡Œë‹¤ë©´ í™€ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 351ì´ê³  ì§ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 42ì…ë‹ˆë‹¤. ë‘ ìˆ˜ì˜ í•©ì€ 393ì…ë‹ˆë‹¤.
 - num_listê°€ [5, 7, 8, 3]ìœ¼ë¡œ ì£¼ì–´ì¡Œë‹¤ë©´ í™€ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 573ì´ê³  ì§ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 8ì…ë‹ˆë‹¤. ë‘ ìˆ˜ì˜ í•©ì€ 581ì…ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - num_listì—ëŠ” ì ì–´ë„ í•œ ê°œì”©ì˜ ì§ìˆ˜ì™€ í™€ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.
 */


func solution11(_ num_list:[Int]) -> Int {
    var oddNum = num_list.filter { (number: Int) -> Bool in
        return number % 2 == 1
    }
    var evenNum = num_list.filter { (number: Int) -> Bool in
        return number % 2 == 0
    }
    
    let oddResult = oddNum.reduce(0) { accumulated, current in
        return accumulated * 10 + current
    }
    
    let evenResult = evenNum.reduce(0) { accumulated, current in
        return accumulated * 10 + current
    }
    
    return oddResult + evenResult
}

/*:
 ## ì„¤ëª…
 - í™€ìˆ˜ì™€ ì§ìˆ˜ë¥¼ ë³„ë„ë¡œ í•„í„°ë§í•˜ì—¬ ë‘ ë°°ì—´ë¡œ ë¶„ë¦¬í•¨
 - í™€ìˆ˜ë“¤ì„ í•˜ë‚˜ì˜ ìˆ«ìë¡œ ì´ì–´ë¶™ì„ (ì˜ˆ: [1,3,5] â†’ 135)
 - reduce í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ê° ìˆ«ìë¥¼ 10ì˜ ìë¦¬ì”© ì˜¬ë ¤ê°€ë©° ê³„ì‚°
 - ì§ìˆ˜ë“¤ë„ ê°™ì€ ë°©ì‹ìœ¼ë¡œ í•˜ë‚˜ì˜ ìˆ«ìë¡œ ì´ì–´ë¶™ì„ (ì˜ˆ: [2,4] â†’ 24)
 - ë‘ ê²°ê³¼ê°’ì„ ë”í•´ì„œ ìµœì¢… ë‹µì„ ë°˜í™˜í•¨
 */


/*:
 ## ğŸ“Œ ë¬¸ìì—´ ì•ì˜ nê¸€ì
 MARK: ë¬¸ìì—´ ì•ì˜ nê¸€ì
 
 - ë¬¸ìì—´ my_stringê³¼ ì •ìˆ˜ nì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_stringì˜ ì•ì˜ nê¸€ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - my_stringì€ ìˆ«ìì™€ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 - 1 â‰¤ n â‰¤ my_stringì˜ ê¸¸ì´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - num_listì—ëŠ” ì ì–´ë„ í•œ ê°œì”©ì˜ ì§ìˆ˜ì™€ í™€ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.
 */



func solution12(_ my_string:String, _ n:Int) -> String {
    let result = String(my_string.prefix(n))
    return result
}

/*:
 ## ì„¤ëª…
 - prefix ë©”ì„œë“œëŠ” ì•ì—ì„œë¶€í„° nê°œì˜ ë¬¸ìë¥¼ ê°€ì ¸ì˜¤ê¸° ë•Œë¬¸ì— prefixë¥¼ ì‚¬ìš©í•´ì„œ nê°œ ë§Œí¼ ê°€ì ¸ì˜¤ê³  ê°€ì ¸ì˜¨ ê°’ì„ ë³€ìˆ˜(result)ì— ë‹´ê³  í•´ë‹¹ ë³€ìˆ˜ë¥¼ return
 */

/*:
 ## ğŸ“Œ í•  ì¼ ëª©ë¡
 MARK: í•  ì¼ ëª©ë¡
 
 - ì˜¤ëŠ˜ í•´ì•¼ í•  ì¼ì´ ë‹´ê¸´ ë¬¸ìì—´ ë°°ì—´ todo_listì™€ ê°ê°ì˜ ì¼ì„ ì§€ê¸ˆ ë§ˆì³¤ëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” boolean ë°°ì—´ finishedê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, todo_listì—ì„œ ì•„ì§ ë§ˆì¹˜ì§€ ëª»í•œ ì¼ë“¤ì„ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - todo_list, finished, resultê°€ ê°ê° ["problemsolving", "practiceguitar", "swim", "studygraph"]    [true, false, true, false]    ["practiceguitar", "studygraph"]
 - todo_list ì¤‘ì—ì„œ "problemsolving"ê³¼ "swim"ì€ ë§ˆì³¤ê³ , "practiceguitar"ì™€ "studygraph"ëŠ” ì•„ì§ ë§ˆì¹˜ì§€ ëª»í–ˆìœ¼ë¯€ë¡œ todo_listì—ì„œ ë‚˜ì˜¨ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ ["practiceguitar", "studygraph"]ë¥¼ return í•©ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ todo_listì˜ ê¸¸ì´ 1 â‰¤ 100
 - 2 â‰¤ todo_listì˜ ì›ì†Œì˜ ê¸¸ì´ â‰¤ 20
 - todo_listì˜ ì›ì†ŒëŠ” ì˜ì†Œë¬¸ìë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - todo_listì˜ ì›ì†ŒëŠ” ëª¨ë‘ ì„œë¡œ ë‹¤ë¦…ë‹ˆë‹¤.
 - finished[i]ëŠ” true ë˜ëŠ” falseì´ê³  trueëŠ” todo_list[i]ë¥¼ ë§ˆì³¤ìŒì„, falseëŠ” ì•„ì§ ë§ˆì¹˜ì§€ ëª»í–ˆìŒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 - ì•„ì§ ë§ˆì¹˜ì§€ ëª»í•œ ì¼ì´ ì ì–´ë„ í•˜ë‚˜ ìˆìŠµë‹ˆë‹¤.
 */


func solution13(_ todo_list:[String], _ finished:[Bool]) -> [String] {
    var result: [String] = []
    
    for (index, isFinished) in finished.enumerated() {
        if !isFinished {
            result.append(todo_list[index])
        }
    }
    return result
}

/*:
 ## ì„¤ëª…
 - todo_listì™€ finishedì˜ ì¸ë±ìŠ¤ë¥¼ ì´ìš©
 - enumerated()ë¥¼ ì‚¬ìš©í•´ì„œ ë°°ì—´ì˜ ê° ìš”ì†Œì— ëŒ€í•´ ì¸ë±ìŠ¤ì™€ ìš”ì†Œ ê°’ì„ í•¨ê»˜ ì œê³µí•˜ëŠ” ì‹œí€€ìŠ¤ë¥¼ ë°˜í™˜
 - ë§Œì•½ finished ë°°ì—´ì´ [true, false, true] ë¼ë©´
 - ì²« ë²ˆì§¸ ë°˜ë³µì—ì„œëŠ” index = 0, isFinished = true
 - ë‘ ë²ˆì§¸ ë°˜ë³µì—ì„œëŠ” index = 1, isFinished = false
 - ì„¸ ë²ˆì§¸ ë°˜ë³µì—ì„œëŠ” index = 2, isFinished = true
 - if ì¡°ê±´ë¬¸ì„ ì‚¬ìš©í•´ì„œ isFinishedì˜ ê°’ì´ falseì¼ ë•Œë§Œ ë‚´ë¶€ ì½”ë“œë¥¼ ì‹¤í–‰
 - todo_list[index]ë¡œ í˜„ì¬ ì¸ë±ìŠ¤ì— í•´ë‹¹í•˜ëŠ” í•  ì¼ í•­ë³µì— ì ‘ê·¼
 - ê·¸ í•­ëª©ì„ result ë°°ì—´ì— ì¶”ê°€í•œ í›„ resultë¥¼ return
 */


/*:
 ## ğŸ“Œ në³´ë‹¤ ì»¤ì§ˆ ë•Œê¹Œì§€ ë”í•˜ê¸°
 MARK: në³´ë‹¤ ì»¤ì§ˆ ë•Œê¹Œì§€ ë”í•˜ê¸°
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - numbers, n, resultê°€ ê°ê° [34, 5, 71, 29, 100, 34], 123, 139ë¡œ ì£¼ì–´ì¡Œë‹¤ë©´
 - 29ë¥¼ ë”í•œ ë’¤ì— sum ê°’ì€ 139ì´ê³  'n' ê°’ì¸ 123ë³´ë‹¤ í¬ë¯€ë¡œ 139ë¥¼ return í•©ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ numbersì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ numbersì˜ ì›ì†Œ â‰¤ 100
 - 0 â‰¤ n < numbersì˜ ëª¨ë“  ì›ì†Œì˜ í•©
 */

func solution14(_ numbers:[Int], _ n:Int) -> Int {
    var sum = 0
    for numbers in numbers {
        sum += numbers
        if sum > n {
            break
        }
    }
    return sum
}

/*:
 ## ì„¤ëª…
 - numbersì˜ í•©ì„ ì €ì¥í•  sum ë³€ìˆ˜ ì„ ì–¸
 - forë¬¸ì„ ì´ìš©í•´ì„œ numbersë¥¼ ìˆœì„œëŒ€ë¡œ ë”í•´ì£¼ê³  sumì— í•©ì„ ì €ì¥
 - ifë¬¸ì„ ì‚¬ìš©í•´ì„œ sumì˜ ê°’ì´ në³´ë‹¤ ì»¤ì§€ë©´ ì¤‘ë‹¨
 - sumì„ return
 */


/*:
 ## ğŸ“Œ ì¹´ìš´íŠ¸ ì—…
 MARK: ì¹´ìš´íŠ¸ ì—…
 
 - ì •ìˆ˜ start_numì™€ end_numê°€ ì£¼ì–´ì§ˆ ë•Œ, start_numë¶€í„° end_numê¹Œì§€ì˜ ìˆ«ìë¥¼ ì°¨ë¡€ë¡œ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - start_numì´ 3ì´ê³  end_numì´ 10ì´ë¼ë©´ [3, 4, 5, 6, 7, 8, 9, 10]ì„ ë‹´ì€ ë°°ì—´ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ start_num â‰¤ end_num â‰¤ 50
 */

func solution15(_ start_num:Int, _ end_num:Int) -> [Int] {
    return Array(start_num...end_num)
}

/*:
 ## ì„¤ëª…
 - start_num...end_numìœ¼ë¡œ ì‹œì‘ ìˆ«ìë¶€í„° ë ìˆ«ìê¹Œì§€ì˜ ë‹«íŒ ë²”ìœ„ë¥¼ ìƒì„±
 - Array()ëŠ” ì´ ë²”ìœ„ë¥¼ ë°°ì—´ë¡œ ë°˜í™˜í•˜ë¯€ë¡œ Array(start_num...end_num) ì„ return
 */


/*:
 ## ğŸ“Œ ì¹´ìš´íŠ¸ ë‹¤ìš´
 MARK: ì¹´ìš´íŠ¸ ë‹¤ìš´
 
 - ì •ìˆ˜ start_numì™€ end_numê°€ ì£¼ì–´ì§ˆ ë•Œ, start_numì—ì„œ end_numê¹Œì§€ 1ì”© ê°ì†Œí•˜ëŠ” ìˆ˜ë“¤ì„ ì°¨ë¡€ë¡œ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - start_numì´ 10ì´ê³  end_numì´ 3ì´ë¼ë©´ [10, 9, 8, 7, 6, 5, 4, 3]ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ end_num â‰¤ start_num â‰¤ 50
 */


func solution16(_ start_num:Int, _ end_num:Int) -> [Int] {
    var a: [Int] = []
    
    for i in end_num...start_num {
        a.append(i)
    }
    return a.reversed()
}


/*:
 ## ì„¤ëª…
 - forë¬¸ì„ ì‚¬ìš©í•´ì„œ end_numë¶€í„° start_numê¹Œì§€ ì‹¤í–‰
 - ì‹¤í–‰ëœ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(a)ë¥¼ ì„ ì–¸ (ë‹¨, ë°°ì—´ë¡œ ê°’ì„ ì €ì¥í•´ì•¼ í•˜ë¯€ë¡œ ë¹ˆ ë°°ì—´ë¡œ ì„ ì–¸)
 - append í•¨ìˆ˜ë¡œ ië¥¼ aë°°ì—´ì— ì €ì¥
 - aë¥¼ ê·¸ëŒ€ë¡œ ë¦¬í„´í•˜ë©´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ê°’ì´ ë¦¬í„´ë˜ë¯€ë¡œ reversed() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ê°’ì„ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ë³€ê²½í•œ ë’¤ í•´ë‹¹ ê°’ì„ ë¦¬í„´
 */

/*:
 ## ğŸ“Œ në²ˆì§¸ ì›ì†Œë¶€í„°
 MARK: në²ˆì§¸ ì›ì†Œë¶€í„°
 
 - ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ num_listì™€ ì •ìˆ˜ nì´ ì£¼ì–´ì§ˆ ë•Œ, n ë²ˆì§¸ ì›ì†Œë¶€í„° ë§ˆì§€ë§‰ ì›ì†Œê¹Œì§€ì˜ ëª¨ë“  ì›ì†Œë¥¼ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [5, 2, 1, 7, 5] ì´ê³  nì´ 2 ë¼ë©´ 2ë²ˆì§¸ë¶€í„° ë‚˜ë¨¸ì§€ ë°°ì—´ì˜ ê°’ì„ ë¦¬í„´í•´ì•¼ í•˜ë¯€ë¡œ [2, 1, 7, 5]ë¥¼ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 30
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - 1 â‰¤ n â‰¤ num_listì˜ ê¸¸ì´
 */

func solution17(_ num_list:[Int], _ n:Int) -> [Int] {
    var sliceArray = Array(num_list[(n - 1)...])
    
    return sliceArray
}

/*:
 ## ì„¤ëª…
 - num_list[(n - 1)...]ë¥¼ ì‚¬ìš©í•´ në²ˆì§¸ ì¸ë±ìŠ¤(ë°°ì—´ì€ 0ë¶€í„° ì‹œì‘í•˜ë¯€ë¡œ n-1)ë¶€í„° ëê¹Œì§€ì˜ ë¶€ë¶„ ë°°ì—´ì„ ìƒì„±
 - ìƒì„±ëœ ë¶€ë¶„ ë°°ì—´ì„ Array()ë¡œ ë³€í™˜í•˜ì—¬ ìƒˆë¡œìš´ ë°°ì—´ sliceArrayì— ì €ì¥
 - ìµœì¢…ì ìœ¼ë¡œ sliceArrayë¥¼ ë°˜í™˜í•˜ì—¬ ì›ë³¸ ë°°ì—´ì˜ në²ˆì§¸ ìš”ì†Œë¶€í„° ëê¹Œì§€ì˜ ìš”ì†Œë“¤ì„ í¬í•¨í•˜ëŠ” ìƒˆ ë°°ì—´ì„ return
 */


/*:
 ## ğŸ“Œ ë¬¸ìì—´ ë°”ê¿”ì„œ ì°¾ê¸°
 MARK: ë¬¸ìì—´ ë°”ê¿”ì„œ ì°¾ê¸°
 
 - ë¬¸ì "A"ì™€ "B"ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ myStringê³¼ patê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. myStringì˜ "A"ë¥¼ "B"ë¡œ, "B"ë¥¼ "A"ë¡œ ë°”ê¾¼ ë¬¸ìì—´ì˜ ì—°ì†í•˜ëŠ” ë¶€ë¶„ ë¬¸ìì—´ ì¤‘ patì´ ìˆìœ¼ë©´ 1ì„ ì•„ë‹ˆë©´ 0ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myStringì´ "ABBAA", patì´ "AABB" ë¼ë©´ "ABBAA"ì—ì„œ "A"ì™€ "B"ë¥¼ ì„œë¡œ ë°”ê¾¸ë©´ "BAABB"ê°€ ë˜ëŠ”ë° ì—¬ê¸°ì—ëŠ” ë¶€ë¶„ë¬¸ìì—´ "AABB"ê°€ ìˆê¸° ë•Œë¬¸ì— 1ì„ returní•¨
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ patì˜ ê¸¸ì´ â‰¤ 10
 - myStringê³¼ patëŠ” ë¬¸ì "A"ì™€ "B"ë¡œë§Œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.
 */


func solution18(_ myString:String, _ pat:String) -> Int {
    let converted = myString.map { char -> Character in
        if char == "A" {
            return "B"
        } else if char == "B" {
            return "A"
        } else {
            return char
        }
    }
    
    let convertedString = String(converted)
    
    if convertedString.contains(pat) {
        return 1
    } else {
        return 0
    }
}


/*:
 ## ì„¤ëª…
 - myStringì˜ ê° ë¬¸ìë¥¼ ìˆœíšŒí•˜ë©´ì„œ AëŠ” Bë¡œ BëŠ” Aë¡œ ë³€í™˜
 - map í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ê° ë¬¸ìë¥¼ ë³€í™˜í•˜ê³  ë³€í™˜ëœ ë¬¸ì ë°°ì—´ì„ Stringìœ¼ë¡œ ë³€í™˜
 - contains ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì„œ ë³€í™˜ëœ ë¬¸ìì—´ì— patì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
 - if elseë¬¸ìœ¼ë¡œ ì¡´ì¬í•œë‹¤ë©´ 1ì„, ì—†ë‹¤ë©´ 0ì„ return
 */


/*:
 ## ğŸ“Œ ê°€ê¹Œìš´ 1 ì°¾ê¸°
 MARK: ê°€ê¹Œìš´ 1 ì°¾ê¸°
 
 - ì •ìˆ˜ ë°°ì—´ arrê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ì´ë•Œ arrì˜ ì›ì†ŒëŠ” 1 ë˜ëŠ” 0ì…ë‹ˆë‹¤. ì •ìˆ˜ idxê°€ ì£¼ì–´ì¡Œì„ ë•Œ, idxë³´ë‹¤ í¬ë©´ì„œ ë°°ì—´ì˜ ê°’ì´ 1ì¸ ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ë¥¼ ì°¾ì•„ì„œ ë°˜í™˜í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”. ë‹¨, ë§Œì•½ ê·¸ëŸ¬í•œ ì¸ë±ìŠ¤ê°€ ì—†ë‹¤ë©´ -1ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - arrì´ [0, 0, 0, 1]ì´ê³  idxê°€ 1ì´ë¼ë©´ 1ë³´ë‹¤ í¬ë©´ì„œ ì›ì†Œê°€ 1ì¸ ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ëŠ” 3ì´ë¯€ë¡œ 3ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 3 â‰¤ arrì˜ ê¸¸ì´ â‰¤ 100'000
 - arrì˜ ì›ì†ŒëŠ” ì „ë¶€ 1 ë˜ëŠ” 0ì…ë‹ˆë‹¤.
 
 */

func solution19(_ arr:[Int], _ idx:Int) -> Int {
    for i in (idx)..<arr.count {
        if arr[i] == 1 {
            return i
        }
    }
    return -1
}
/*:
 ## ì„¤ëª…
 
 - ì •ìˆ˜ ë°°ì—´ arrê°€ ì£¼ì–´ì§€ê³ , ì›ì†ŒëŠ” 1 ë˜ëŠ” 0ìœ¼ë¡œ êµ¬ì„±ë¨
 - ì •ìˆ˜ idxê°€ ì£¼ì–´ì¡Œì„ ë•Œ, idxë¶€í„° ë°°ì—´ì„ ìˆœíšŒí•˜ë©´ì„œ ê°’ì´ 1ì¸ ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ë¥¼ ì°¾ìŒ
 - for ë°˜ë³µë¬¸ì„ ì‚¬ìš©í•´ idxë¶€í„° ë°°ì—´ì˜ ëê¹Œì§€ ìˆœì°¨ì ìœ¼ë¡œ í™•ì¸
 - ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì²« ë²ˆì§¸ ì¸ë±ìŠ¤ë¥¼ ë°œê²¬í•˜ë©´ ì¦‰ì‹œ í•´ë‹¹ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜
 - ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì¸ë±ìŠ¤ê°€ ì—†ëŠ” ê²½ìš° -1ì„ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ê°„ë‹¨í•œ ì‹ ê³„ì‚°í•˜ê¸°
 MARK: ê°„ë‹¨í•œ ì‹ ê³„ì‚°í•˜ê¸°
 
 - ë¬¸ìì—´ binomialì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. binomialì€ "a op b" í˜•íƒœì˜ ì´í•­ì‹ì´ê³  aì™€ bëŠ” ìŒì´ ì•„ë‹Œ ì •ìˆ˜, opëŠ” '+', '-', '*' ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ì‹ì„ ê³„ì‚°í•œ ì •ìˆ˜ë¥¼ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - binomialì´ "43 + 12" ë¼ë©´ 55ë¥¼ return
 - binomialì´ "0 - 7777" ë¼ë©´ -7777ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ a, b â‰¤ 40,000
 - 0ì„ ì œì™¸í•˜ê³  a, bëŠ” 0ìœ¼ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 */


import Foundation

func solution20(_ binomial:String) -> Int {
    let components = binomial.split(separator: " ")
    
    if components.count == 3,
       let a = Int(components[0]),
       let b = Int(components[2]) {
        let op = String(components[1])
        
        switch op {
        case "+":
            return a + b
        case "-":
            return a - b
        case "*":
            return a * b
        default:
            return 0
        }
    }
    return 0
}

/*:
 ## ì„¤ëª…
 - binomial ë¬¸ìì—´ì„ ê³µë°± ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ìœ„í•´ components ìƒìˆ˜ë¥¼ ì„ ì–¸
 - if letë¬¸ë²•ìœ¼ë¡œ componentsì˜ ê°œìˆ˜ê°€ 3ê°œë¼ë©´ ê°ê°ì˜ ìš”ì†Œë¥¼ a, b, op ë³€ìˆ˜ì— ëŒ€ì…(ì¡°ê±´ì‹ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ binomialì€ í˜•íƒœê°€ ê³ ì •ë˜ì–´ ìˆìœ¼ë¯€ë¡œ í•­ìƒ ê°œìˆ˜ê°€ 3ì„)
    - ë‹¨, ì´ë•Œ aì™€ bëŠ” Intë¡œ íƒ€ì… ë³€í™˜ì„ ì§„í–‰
 - switch caseë¬¸ìœ¼ë¡œ ê°ê°ì˜ ì—°ì‚°ì— ë§ê²Œ ê³„ì‚°ì„ ì§„í–‰í•˜ê³  í•´ë‹¹ ê°’ì„ return
 */


/*:
 ## ğŸ“Œ ë¬¸ìì—´ ì˜ë¼ì„œ ì •ë ¬í•˜ê¸°
 MARK: ë¬¸ìì—´ ì˜ë¼ì„œ ì •ë ¬í•˜ê¸°
 
 - ë¬¸ìì—´ myStringì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. "x"ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•´ë‹¹ ë¬¸ìì—´ì„ ì˜ë¼ë‚´ ë°°ì—´ì„ ë§Œë“  í›„ ì‚¬ì „ìˆœìœ¼ë¡œ ì •ë ¬í•œ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”. ë‹¨, ë¹ˆ ë¬¸ìì—´ì€ ë°˜í™˜í•  ë°°ì—´ì— ë„£ì§€ ì•ŠìŠµë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myStringì´ "axbxcxdx" ì´ë¼ë©´ return ê°’ì€ ["a","b","c","d"]ì´ ë˜ì–´ì•¼ í•¨
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myString â‰¤ 100,000
    - myStringì€ ì•ŒíŒŒë²³ ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.
 */

func solution21(_ myString:String) -> [String] {
    let cutString = myString.components(separatedBy: "x").filter { !$0.isEmpty}
    return cutString.sorted()
}

/*:
 ## ì„¤ëª…
 - myStringì„ xë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¬¸ìì—´ì„ ì˜ë¼ë‚´ì•¼ í•˜ê¸° ë•Œë¬¸ì— componentsë¥¼ ì‚¬ìš©í•´ì„œ ë¬¸ìì—´ì„ ì˜ë¼ëƒ„
 - ë¬¸ì œì—ì„œ ë¹ˆ ë¬¸ìì—´ì€ ë°˜í™˜í•  ë°°ì—´ì— ë„£ì§€ ì•ŠëŠ”ë‹¤ê³  í–ˆìœ¼ë¯€ë¡œ filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ë¹ˆ ë¬¸ìì—´ì„ ì œì™¸í•˜ê³  ëª¨ë‘ ë½‘ì•„ëƒ„
 - ì¡°ê±´ì— ë§ê²Œ ì˜ë¼ë‚¸ ë°°ì—´ì„ cutString ë³€ìˆ˜ì— ëŒ€ì…í•˜ê³  í•´ë‹¹ ë³€ìˆ˜ë¥¼ sorted()ë¥¼ ì‚¬ìš©í•´ì„œ ì‚¬ì „ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê³  í•´ë‹¹ ê°’ì„ return
 */


/*:
 ## ğŸ“Œ íŠ¹ì •í•œ ë¬¸ìë¥¼ ëŒ€ë¬¸ìë¡œ ë°”ê¾¸ê¸°
 MARK: íŠ¹ì •í•œ ë¬¸ìë¥¼ ëŒ€ë¬¸ìë¡œ ë°”ê¾¸ê¸°
 
 - ì˜ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ my_stringê³¼ ì˜ì†Œë¬¸ì 1ê¸€ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ alpê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_stringì—ì„œ alpì— í•´ë‹¹í•˜ëŠ” ëª¨ë“  ê¸€ìë¥¼ ëŒ€ë¬¸ìë¡œ ë°”ê¾¼ ë¬¸ìì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 -
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 */

func solution22(_ my_string:String, _ alp:String) -> String {
    var upperString = ""
    for ch in my_string {
        if ch == Character(alp) {
            upperString += ch.uppercased()
        } else {
            upperString += String(ch)
        }
    }
    
    return upperString
}

/*:
 ## ì„¤ëª…
 - my_stringì—ì„œ í•œ ê¸€ìì”© ìˆœíšŒí•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— forë¬¸ì„ ì‚¬ìš©í•´ì„œ ë¬¸ìì—´ì˜ ê° ë¬¸ìë¥¼ í™•ì¸
 - ê° ë¬¸ìë¥¼ alpì™€ ë¹„êµí•˜ê¸° ìœ„í•´ Character(alp)ë¡œ íƒ€ì…ì„ ë§ì¶”ê³  ë¹„êµ
 - if elseë¬¸ì„ ì‚¬ìš©í•´ì„œ ë§Œì•½ ë¬¸ìê°€ alpì™€ ê°™ë‹¤ê³  uppercased()ë¥¼ ì‚¬ìš©í•´ì„œ í•´ë‹¹ ë¬¸ìë¥¼ ëŒ€ë¬¸ìë¡œ ë³€í™˜í•œ ë’¤ upperStringì— ë¶™ì„
 - ë‹¤ë¥´ë©´ ì›ë˜ ë¬¸ìë¥¼ ê·¸ëŒ€ë¡œ upperStringì— ë¶™ì„
 - ë§ˆì§€ë§‰ìœ¼ë¡œ upperStringì„ return
 */


/*:
 ## ğŸ“Œ 1ë¡œ ë§Œë“¤ê¸°
 MARK: 1ë¡œ ë§Œë“¤ê¸°
 
 - ì •ìˆ˜ê°€ ìˆì„ ë•Œ, ì§ìˆ˜ë¼ë©´ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê³ , í™€ìˆ˜ë¼ë©´ 1ì„ ëº€ ë’¤ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ë©´, ë§ˆì§€ë§‰ì—” 1ì´ ë©ë‹ˆë‹¤. ì •ìˆ˜ë“¤ì´ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§ˆ ë•Œ, num_listì˜ ëª¨ë“  ì›ì†Œë¥¼ 1ë¡œ ë§Œë“¤ê¸° ìœ„í•´ì„œ í•„ìš”í•œ ë‚˜ëˆ„ê¸° ì—°ì‚°ì˜ íšŸìˆ˜ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - my_stringì´ "programmers", alpê°€ "p"ë¼ë©´ resultëŠ” "Programmers"
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 3 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 15
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 30
 */

func solution23(_ num_list:[Int]) -> Int {
    var totalCount = 0
    
    for num in num_list {
        var n = num
        while n > 1 {
            n /= 2
            totalCount += 1
        }
    }
    return totalCount
}

/*:
 ## ì„¤ëª…
 - ì—°ì‚° íšŸìˆ˜ë¥¼ ì €ì¥í•  ë³€ìˆ˜ totalCountë¥¼ ì„ ì–¸
 - forë¬¸ìœ¼ë¡œ ë¦¬ìŠ¤íŠ¸ ì•ˆì˜ ìˆ«ì í•˜ë‚˜ì”© ë°˜ë³µ
 - í˜„ì¬ ìˆ«ìë¥¼ ì„ì‹œ ë³€ìˆ˜ë¡œ ì €ì¥ (Swiftì—ì„œ forë£¨í”„ ë³€ìˆ˜(ì—¬ê¸°ì—ì„œëŠ” num)ëŠ” letì´ê¸° ë•Œë¬¸
 - 1ì„ ë§Œë“œëŠ” ê²Œ ëª©ì ì´ë¯€ë¡œ whileë¬¸ìœ¼ë¡œ nì´ 1ë³´ë‹¤ í´ ë™ì•ˆ ê³„ì† ë°˜ë³µ
 - nì„ 2ë¡œ ë‚˜ëˆ”(í™€ìˆ˜ì¸ ê²½ìš°ëŠ” ìì—°ìŠ¤ëŸ½ê²Œ n - 1ì´ ëœ í›„ ë‚˜ëˆ„ëŠ” ê²ƒê³¼ ê°™ê¸° ë•Œë¬¸ì— ë³„ë„ ì²˜ë¦¬ x)
 - ì—°ì‚°ì´ ì§„í–‰ ëìœ¼ë¯€ë¡œ totalCountì— 1ì„ ì¦ê°€
 - totalCountë¥¼ return
 */


/*:
 ## ğŸ“Œ ê¸¸ì´ì— ë”°ë¥¸ ì—°ì‚°
 MARK: ê¸¸ì´ì— ë”°ë¥¸ ì—°ì‚°
 
 - ì •ìˆ˜ê°€ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§ˆ ë•Œ, ë¦¬ìŠ¤íŠ¸ì˜ ê¸¸ì´ê°€ 11 ì´ìƒì´ë©´ ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ëª¨ë“  ì›ì†Œì˜ í•©ì„ 10 ì´í•˜ì´ë©´ ëª¨ë“  ì›ì†Œì˜ ê³±ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [2,3,4,5]ë¼ë©´ 120ì„ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 20
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - num_listì˜ ì›ì†Œë¥¼ ëª¨ë‘ ê³±í–ˆì„ ë•Œ 2,147,483,647ë¥¼ ë„˜ëŠ” ì…ë ¥ì€ ì£¼ì–´ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.

 */

func solution24(_ num_list:[Int]) -> Int {
    let count = num_list.count
    var sum = 0
    var product = 0
    
    if count >= 11 {
        sum = num_list.reduce(0, +)
        return sum
    } else {
        product = num_list.reduce(1, *)
        return product
    }
}

/*:
 ## ì„¤ëª…
 - num_listì˜ ê¸¸ì´ë¥¼ ë‹´ì„ ë³€ìˆ˜ì™€ num_listì˜ í•©, ê³±ì„ ë‹´ì„ ë³€ìˆ˜ë¥¼ ê°ê° ì„ ì–¸
 - ifë¬¸ìœ¼ë¡œ num_listì˜ ê¸¸ì´ê°€ 11 ì´ìƒì´ë¼ë©´ reduce í•¨ìˆ˜ë¡œ 0ë¶€í„° ì­‰ ëª¨ì•„ì„œ ë”í•´ì£¼ê³  sumì„ return
 - ê·¸ ì™¸ì˜ ì¡°ê±´ì€ reduce í•¨ìˆ˜ë¡œ 1ë¶€í„° ëª¨ì•„ì„œ ê³±í•´ì£¼ê³  í•´ë‹¹ ê°’ì„ returní•¨
    - 0ë¶€í„° ëª¨ìœ¼ì§€ ì•Šì€ ì´ìœ ëŠ” 0ì„ í¬í•¨í•˜ëŠ” ìˆœê°„ 0ë„ ê°™ì´ ê³±í•´ì§€ê¸° ë•Œë¬¸ì— ê²°ê³¼ ê°’ì´ í•­ìƒ 0ì´ ë‚˜ì˜´
 */



/*:
 ## ğŸ“Œ ëŒ€ë¬¸ìë¡œ ë°”ê¾¸ê¸°
 MARK: ëŒ€ë¬¸ìë¡œ ë°”ê¾¸ê¸°
 
 - ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ myStringì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. ëª¨ë“  ì•ŒíŒŒë²³ì„ ëŒ€ë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myString ì´ "aBcDeFg"ë¼ë©´ "ABCDEFG"ë¥¼ ë¦¬í„´
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 100,000
    - myStringì€ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.


 */

func solution25(_ myString:String) -> String {
    let Change = myString.uppercased()
    
    return Change
}

/*:
 ## ì„¤ëª…
 - uppercased() í•¨ìˆ˜ëŠ” ì†Œë¬¸ìë¥¼ ëŒ€ë¬¸ìë¡œ ë³€ê²½í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë¯€ë¡œ í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì´ìš©
 - myStringì— uppercased()ë¥¼ ì ìš©í•´ì£¼ê³  ì ìš©ëœ ê°’ì„ Change ë³€ìˆ˜ì— ë‹´ì€ í›„ í•´ë‹¹ ë³€ìˆ˜ë¥¼ return
 */


/*:
 ## ğŸ“Œ ì†Œë¬¸ìë¡œ ë°”ê¾¸ê¸°
 MARK: ì†Œë¬¸ìë¡œ ë°”ê¾¸ê¸°
 
 - ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ myStringì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. ëª¨ë“  ì•ŒíŒŒë²³ì„ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myString ì´ "aBcDeFg"ë¼ë©´ "abcdefg"ë¥¼ ë¦¬í„´
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 100,000
    - myStringì€ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.
 */

func solution26(_ myString:String) -> String {
    let change = myString.lowercased()
    
    return change
}

/*:
 ## ì„¤ëª…
 - lowercased() í•¨ìˆ˜ëŠ” ëŒ€ë¬¸ìë¥¼ ì†Œë¬¸ìë¡œ ë³€ê²½í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë¯€ë¡œ í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì´ìš©
 - myStringì— lowercased()ë¥¼ ì ìš©í•´ì£¼ê³  ì ìš©ëœ ê°’ì„ change ë³€ìˆ˜ì— ë‹´ì€ í›„ í•´ë‹¹ ë³€ìˆ˜ë¥¼ return
 */



/*:
 ## ğŸ“Œ ì›í•˜ëŠ” ë¬¸ìì—´ ì°¾ê¸°
 MARK: ì›í•˜ëŠ” ë¬¸ìì—´ ì°¾ê¸°
 
 - ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ myStringê³¼ patì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. myStringì˜ ì—°ì†ëœ ë¶€ë¶„ ë¬¸ìì—´ ì¤‘ patì´ ì¡´ì¬í•˜ë©´ 1ì„ ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ 0ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”. ë‹¨, ì•ŒíŒŒë²³ ëŒ€ë¬¸ìì™€ ì†Œë¬¸ìëŠ” êµ¬ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myString ì´ "AbCdEfG" ì´ê³  patì´ "aBc"ë¼ë©´ 1ì„ return
 - myString ì´ "aaAA" ì´ê³  patì´ "aaaaa"ë¼ë©´ 0ì„ ë¦¬í„´
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 100,000
 - 1 â‰¤ patì˜ ê¸¸ì´ â‰¤ 300
 - myStringê³¼ patì€ ëª¨ë‘ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.

 */

func solution27(_ myString:String, _ pat:String) -> Int {
    let lowercaseString = myString.lowercased()
    let lowercasePat = pat.lowercased()
    
    return lowercaseString.contains(lowercasePat) ? 1 : 0
}

/*:
 ## ì„¤ëª…
 - lowercased() í•¨ìˆ˜ëŠ” ëŒ€ë¬¸ìë¥¼ ì†Œë¬¸ìë¡œ ë³€ê²½í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë¯€ë¡œ í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì´ìš©
 - ë‘ ë¬¸ìì—´ì„ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´ ë¹„êµ
 - contains ë©”ì„œë“œë¡œ ë¬¸ìì—´ í¬í•¨ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ì—¬ ê²°ê³¼ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ A ê°•ì¡°í•˜ê¸°
 MARK: A ê°•ì¡°í•˜ê¸°
 
 - ë¬¸ìì—´ myStringì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. myStringì—ì„œ ì•ŒíŒŒë²³ "a"ê°€ ë“±ì¥í•˜ë©´ ì „ë¶€ "A"ë¡œ ë³€í™˜í•˜ê³ , "A"ê°€ ì•„ë‹Œ ëª¨ë“  ëŒ€ë¬¸ì ì•ŒíŒŒë²³ì€ ì†Œë¬¸ì ì•ŒíŒŒë²³ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myStringì´ "abstract algebra" ë¼ë©´ "AbstrAct AlgebrA"ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 20
     - myStringì€ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.

 */

func solution28(_ myString:String) -> String {
    let lowercase = myString.lowercased()
    let result = lowercase.map { $0 == "a" ? "A" : String($0)} .joined()
    
    return result
    
    
    // ë” íš¨ìœ¨ì ì¸ ë‹¤ë¥¸ í’€ì´
    func anotherSolution28(_ myString:String) -> String {
        return myString.lowercased().replacingOccurrences(of: "a", with: "A")
    }
}

/*:
 ## ì„¤ëª…
 - lowercased() í•¨ìˆ˜ë¡œ ì „ì²´ ë¬¸ìì—´ì„ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ê³  lowercase ë³€ìˆ˜ì— ì €ì¥
 - lowercaseì— ìˆëŠ” ë¬¸ìì—´ ì¤‘ì—ì„œ mapí•¨ìˆ˜ë¡œ ì†Œë¬¸ì aê°€ ìˆë‹¤ë©´ ëŒ€ë¬¸ì Aë¡œ ë³€í™˜í•˜ê³  joined() í•¨ìˆ˜ë¡œ ë‹¤ì‹œ lowercaseì— ë„£ìŒ
 - í•´ë‹¹ ê²°ê³¼ë¥¼ return
 */



/*:
 ## ğŸ“Œ ad ì œê±°í•˜ê¸°
 MARK: ad ì œê±°í•˜ê¸°
 
 - ë¬¸ìì—´ ë°°ì—´ strArrê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ë°°ì—´ ë‚´ì˜ ë¬¸ìì—´ ì¤‘ "ad"ë¼ëŠ” ë¶€ë¶„ ë¬¸ìì—´ì„ í¬í•¨í•˜ê³  ìˆëŠ” ëª¨ë“  ë¬¸ìì—´ì„ ì œê±°í•˜ê³  ë‚¨ì€ ë¬¸ìì—´ì„ ìˆœì„œë¥¼ ìœ ì§€í•˜ì—¬ ë°°ì—´ë¡œ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - strArrê°€ ["and","notad","abcd"]ì´ë¼ë©´ ["and", "abcd"]ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ strArrì˜ ê¸¸ì´ â‰¤ 1,000
    - 1 â‰¤ strArrì˜ ì›ì†Œì˜ ê¸¸ì´ â‰¤ 20
    - strArrì˜ ì›ì†ŒëŠ” ì•ŒíŒŒë²³ ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.

 */

func solution29(_ strArr:[String]) -> [String] {
    let result = strArr.filter{ !$0.contains("ad") }
    
    return result
}
/*:
 ## ì„¤ëª…
 - filterë¡œ ë°°ì—´ì—ì„œ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìš”ì†Œë§Œ ë‚¨ê¹€
 - contains("ad")ëŠ” ë¬¸ìì—´ ì•ˆì— "ad"ë¼ëŠ” ë¶€ë¶„ ë¬¸ìì—´ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ë¥¼ ê²€ì‚¬
 - !$0.contains("ad")ëŠ” "ad"ê°€ ì—†ëŠ” ë¬¸ìì—´ë§Œ ë‚¨ê²Œ ë¨
 */


/*:
 ## ğŸ“Œ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê¸° 1
 MARK: ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê¸° 1
 
 - ë‹¨ì–´ê°€ ê³µë°± í•œ ê°œë¡œ êµ¬ë¶„ë˜ì–´ ìˆëŠ” ë¬¸ìì—´ my_stringì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_stringì— ë‚˜ì˜¨ ë‹¨ì–´ë¥¼ ì•ì—ì„œë¶€í„° ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - my_stringì´ "i love you" ë¼ë©´ ["i", "love", "you"]ì„ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - my_stringì€ ì˜ì†Œë¬¸ìì™€ ê³µë°±ìœ¼ë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 - my_stringì˜ ë§¨ ì•ê³¼ ë§¨ ë’¤ì— ê¸€ìëŠ” ê³µë°±ì´ ì•„ë‹™ë‹ˆë‹¤.

 */

func solution30(_ my_string:String) -> [String] {
    let words = my_string.split(separator: " ").map { String($0)}
    return words
}

/*:
 ## ì„¤ëª…
 - split()ì„ ì‚¬ìš©í•´ì„œ ê³µë°±ì„ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ”
 - String ë°°ì—´ë¡œ ë°˜í™˜ì„ í•´ì•¼ í•˜ë¯€ë¡œ map í•¨ìˆ˜ë¥¼ ì‚¬ìš©
 - í•´ë‹¹ ê°’ì„ ì €ì¥í•œ words ë³€ìˆ˜ë¥¼ return
 */


/*:
 ## ğŸ“Œ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê¸° 2
 MARK: ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê¸° 2
 
 - ë‹¨ì–´ê°€ ê³µë°± í•œ ê°œ ì´ìƒìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ìˆëŠ” ë¬¸ìì—´ my_stringì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_stringì— ë‚˜ì˜¨ ë‹¨ì–´ë¥¼ ì•ì—ì„œë¶€í„° ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - my_stringì´ " i    love  you" ë¼ë©´ ["i", "love", "you"]ì„ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
  - my_stringì€ ì˜ì†Œë¬¸ìì™€ ê³µë°±ìœ¼ë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
  - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
  - my_stringì˜ ë§¨ ì•ê³¼ ë§¨ ë’¤ì—ë„ ê³µë°±ì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  - my_stringì—ëŠ” ë‹¨ì–´ê°€ í•˜ë‚˜ ì´ìƒ ì¡´ì¬í•©ë‹ˆë‹¤.

 */

func solution31(_ my_string:String) -> [String] {
    let words = my_string.split(separator: " ").map { String($0)}
    return words
}

/*:
 ## ì„¤ëª…
 - Swiftì˜ splitì€ ê³µë°± ì—¬ëŸ¬ ê°œê°€ ë¶™ì–´ ìˆì–´ë„ ê°ê° ë¶„ë¦¬ë˜ê¸° ë•Œë¬¸ì— ìœ„ ë¬¸ì œì™€ ë™ì¼í•˜ê²Œ splitì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
 */



/*:
 ## ğŸ“Œ ì£¼ì‚¬ìœ„ ê²Œì„ 1
 MARK: ì£¼ì‚¬ìœ„ ê²Œì„ 1
 
 - 1ë¶€í„° 6ê¹Œì§€ ìˆ«ìê°€ ì íŒ ì£¼ì‚¬ìœ„ê°€ ë‘ ê°œ ìˆìŠµë‹ˆë‹¤. ë‘ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¸ì„ ë•Œ ë‚˜ì˜¨ ìˆ«ìë¥¼ ê°ê° a, bë¼ê³  í–ˆì„ ë•Œ ì–»ëŠ” ì ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
    - aì™€ bê°€ ëª¨ë‘ í™€ìˆ˜ë¼ë©´ a2 + b2 ì ì„ ì–»ìŠµë‹ˆë‹¤.
    - aì™€ b ì¤‘ í•˜ë‚˜ë§Œ í™€ìˆ˜ë¼ë©´ 2 Ã— (a + b) ì ì„ ì–»ìŠµë‹ˆë‹¤.
    - aì™€ b ëª¨ë‘ í™€ìˆ˜ê°€ ì•„ë‹ˆë¼ë©´ |a - b| ì ì„ ì–»ìŠµë‹ˆë‹¤.
 - ë‘ ì •ìˆ˜ aì™€ bê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ì–»ëŠ” ì ìˆ˜ë¥¼ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - aê°€ 3 bê°€ 5ë¼ë©´ 34ë¥¼ return
 - aê°€ 6 bê°€ 1ë¼ë©´ 14ë¥¼ return
 - aê°€ 2 bê°€ 4ë¼ë©´ 2ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
  - aì™€ bëŠ” 1 ì´ìƒ 6 ì´í•˜ì˜ ì •ìˆ˜ì…ë‹ˆë‹¤.

 */

func solution32(_ a:Int, _ b:Int) -> Int {
    if (a % 2 == 1 && b % 2 == 1) {
        return (a * a) + (b * b)
    } else if (a % 2 == 1 && b % 2 == 0) || (a % 2 == 0 && b % 2 == 1) {
        return 2 * (a + b)
    } else {
        return abs(a - b)
    }
}

/*:
 ## ì„¤ëª…
 - if else ë¬¸ì„ ì‚¬ìš©í•´ ì„¸ ê°€ì§€ ì¼€ì´ìŠ¤ë¡œ ë¶„ê¸° ì²˜ë¦¬
 - ì²« ë²ˆì§¸ ì¡°ê±´ì€ aì™€ bê°€ ëª¨ë‘ í™€ìˆ˜ì¼ ë•Œ í•´ë‹¹ -> && (AND ì—°ì‚°ì)ë¥¼ ì‚¬ìš©í•´ ë‘ ì¡°ê±´ì´ ëª¨ë‘ ì°¸ì¼ ë•Œë§Œ ì‹¤í–‰
 - ë‘ ë²ˆì§¸ ì¡°ê±´ì€ aì™€ b ì¤‘ í•˜ë‚˜ë§Œ í™€ìˆ˜ì¼ ë•Œ í•´ë‹¹ â†’ || (OR ì—°ì‚°ì)ë¥¼ ì‚¬ìš©í•´ ë‘˜ ì¤‘ í•˜ë‚˜ë§Œ ì°¸ì´ë©´ ì‹¤í–‰ë¨
    - (a % 2 == 1 && b % 2 == 0) ë˜ëŠ” (a % 2 == 0 && b % 2 == 1) ì¤‘ í•˜ë‚˜ë¼ë„ ì°¸ì´ë©´ í•´ë‹¹
 - ì„¸ ë²ˆì§¸ ì¡°ê±´ì€ aì™€ bê°€ ëª¨ë‘ ì§ìˆ˜ì¼ ë•Œ í•´ë‹¹ë˜ë©°, ìœ„ ì¡°ê±´ì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ” ë‚˜ë¨¸ì§€ ê²½ìš°ë¥¼ ì²˜ë¦¬
 - ì´ë•Œ abs(a - b)ëŠ” aì™€ bì˜ ì°¨ì´ë¥¼ ì ˆëŒ“ê°’ìœ¼ë¡œ ë°˜í™˜í•¨ (ìŒìˆ˜ ë°©ì§€)
 */


/*:
 ## ğŸ“Œ ìˆ«ì ì§ê¿
 MARK: ìˆ«ì ì§ê¿
 
 - ë‘ ì •ìˆ˜ X, Yì˜ ì„ì˜ì˜ ìë¦¬ì—ì„œ ê³µí†µìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ì •ìˆ˜ k(0 â‰¤ k â‰¤ 9)ë“¤ì„ ì´ìš©í•˜ì—¬ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ì •ìˆ˜ë¥¼ ë‘ ìˆ˜ì˜ ì§ê¿ì´ë¼ í•©ë‹ˆë‹¤(ë‹¨, ê³µí†µìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ì •ìˆ˜ ì¤‘ ì„œë¡œ ì§ì§€ì„ ìˆ˜ ìˆëŠ” ìˆ«ìë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤). X, Yì˜ ì§ê¿ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´, ì§ê¿ì€ -1ì…ë‹ˆë‹¤. X, Yì˜ ì§ê¿ì´ 0ìœ¼ë¡œë§Œ êµ¬ì„±ë˜ì–´ ìˆë‹¤ë©´, ì§ê¿ì€ 0ì…ë‹ˆë‹¤.
 
 - ì˜ˆë¥¼ ë“¤ì–´, X = 3403ì´ê³  Y = 13203ì´ë¼ë©´, Xì™€ Yì˜ ì§ê¿ì€ Xì™€ Yì—ì„œ ê³µí†µìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” 3, 0, 3ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ì •ìˆ˜ì¸ 330ì…ë‹ˆë‹¤. ë‹¤ë¥¸ ì˜ˆì‹œë¡œ X = 5525ì´ê³  Y = 1255ì´ë©´ Xì™€ Yì˜ ì§ê¿ì€ Xì™€ Yì—ì„œ ê³µí†µìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” 2, 5, 5ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ì •ìˆ˜ì¸ 552ì…ë‹ˆë‹¤(Xì—ëŠ” 5ê°€ 3ê°œ, Yì—ëŠ” 5ê°€ 2ê°œ ë‚˜íƒ€ë‚˜ë¯€ë¡œ ë‚¨ëŠ” 5 í•œ ê°œëŠ” ì§ ì§€ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.) ë‘ ì •ìˆ˜ X, Yê°€ ì£¼ì–´ì¡Œì„ ë•Œ, X, Yì˜ ì§ê¿ì„ returní•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - XëŠ” "100", YëŠ” "2345"ë©´ -1ì„ return
 - XëŠ” "100", YëŠ” "203045"ë©´ 0ì„ return
 - XëŠ” "100", YëŠ” "123450"ë©´ 10ì„ return
 
 - aê°€ 6 bê°€ 1ë¼ë©´ 14ë¥¼ return
 - aê°€ 2 bê°€ 4ë¼ë©´ 2ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 3 â‰¤ X, Yì˜ ê¸¸ì´(ìë¦¿ìˆ˜) â‰¤ 3,000,000ì…ë‹ˆë‹¤.
 - X, YëŠ” 0ìœ¼ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - X, Yì˜ ì§ê¿ì€ ìƒë‹¹íˆ í° ì •ìˆ˜ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë¬¸ìì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

 */

func solution33(_ X:String, _ Y:String) -> String {
    var countX = Array(repeating: 0, count: 10)
    var countY = Array(repeating: 0, count: 10)
    
    for ch in X {
        if let digit = ch.wholeNumberValue {
            countX[digit] += 1
        }
    }
    for ch in Y {
        if let digit = ch.wholeNumberValue {
            countY[digit] += 1
        }
    }
    var result = ""
    
    for i in stride(from: 9, through: 0, by: -1) {
        let commonCount = min(countX[i], countY[i])
        if commonCount > 0 {
            result += String(repeating: "\(i)", count: commonCount)
        }
    }
    
    if result.isEmpty {
        return "-1"
    } else if result.first == "0" {
        return "0"
    } else {
        return result
    }
}

/*:
 ## ì„¤ëª…
 - ë‘ ë¬¸ìì—´ Xì™€ Yì—ì„œ ê° ìˆ«ì(0~9)ì˜ ë“±ì¥ íšŸìˆ˜ë¥¼ ë°°ì—´(countX, countY)ì— ì €ì¥
 - ê° ìˆ«ìë§ˆë‹¤ ë“±ì¥ íšŸìˆ˜ë¥¼ ê¸°ë¡í•˜ë©´, ìˆ«ìë³„ë¡œ ì–¼ë§ˆë‚˜ ê²¹ì¹˜ëŠ”ì§€ ë¹ ë¥´ê²Œ ì•Œ ìˆ˜ ìˆìŒ
 - ì´í›„ 9ë¶€í„° 0ê¹Œì§€ ìˆ«ìë¥¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ íƒìƒ‰
    - ê°€ì¥ í° ìˆ˜ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ë†’ì€ ìˆ«ìë¶€í„° ê²°ê³¼ ë¬¸ìì—´ì— ì¶”ê°€
 - ê° ìˆ«ì iì— ëŒ€í•´ Xì™€ Y ëª¨ë‘ì—ì„œ ë‚˜íƒ€ë‚˜ëŠ” ê°œìˆ˜ì˜ ìµœì†Ÿê°’(min)ì„ ê³„ì‚°í•˜ì—¬ ì§ ì§€ì„ ìˆ˜ ìˆëŠ” ê°œìˆ˜ë¥¼ êµ¬í•¨
    - ì˜ˆ: Xì— 5ê°€ 3ë²ˆ, Yì— 5ê°€ 2ë²ˆ â†’ ì§ ì§€ì„ ìˆ˜ ìˆëŠ” 5ëŠ” 2ê°œ
    - ì´ë•Œ String(repeating: "\(i)", count: ê°œìˆ˜)ë¥¼ ì‚¬ìš©í•´ í•´ë‹¹ ìˆ«ìë¥¼ ì—¬ëŸ¬ ë²ˆ ë¶™ì„
 - ìµœì¢…ì ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ ë¬¸ìì—´ resultê°€ ë‹¤ìŒ ì¡°ê±´ ì¤‘ í•˜ë‚˜ì— í•´ë‹¹í•  ê²½ìš° ì˜ˆì™¸ ì²˜ë¦¬
    - ì•„ë¬´ ìˆ«ìë„ ì§ì§€ì–´ì§€ì§€ ì•Šì€ ê²½ìš° â†’ resultëŠ” ë¹ˆ ë¬¸ìì—´("") â†’ "-1" ë°˜í™˜
    - ê²°ê³¼ê°€ "000..."ì²˜ëŸ¼ 0ìœ¼ë¡œë§Œ êµ¬ì„±ëœ ê²½ìš° â†’ "0" ë°˜í™˜
 - ìœ„ ë‘ ê²½ìš° ì™¸ì—ëŠ” result ë¬¸ìì—´ì„ ê·¸ëŒ€ë¡œ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ì›ì†Œë“¤ì˜ ê³±ê³¼ í•©
 MARK: ì›ì†Œë“¤ì˜ ê³±ê³¼ í•©
 
 - ì •ìˆ˜ê°€ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§ˆ ë•Œ, ëª¨ë“  ì›ì†Œë“¤ì˜ ê³±ì´ ëª¨ë“  ì›ì†Œë“¤ì˜ í•©ì˜ ì œê³±ë³´ë‹¤ ì‘ìœ¼ë©´ 1ì„ í¬ë©´ 0ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
  
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [3, 4, 5, 2, 1]ì´ë¼ë©´ 1ì„ return
 - num_listê°€ [5, 7, 8, 3]ì´ë¼ë©´ 0ì„ return
 
 - aê°€ 6 bê°€ 1ë¼ë©´ 14ë¥¼ return
 - aê°€ 2 bê°€ 4ë¼ë©´ 2ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9

 */

func solution34(_ num_list: [Int]) -> Int {
    let product = num_list.reduce(1, *)
    let sum = num_list.reduce(0, +)
    
    return product < sum * sum ? 1 : 0
}

/*:
 ## ì„¤ëª…
 - ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ëª¨ë“  ì›ì†Œë“¤ì˜ ê³±(product)ì„ reduce(1, *)ë¡œ ê³„ì‚°
   - ê³±ì…ˆì˜ í•­ë“±ì› 1ì„ ì´ˆê¸°ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ì›ì†Œë¥¼ ê³±í•¨

 - ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ëª¨ë“  ì›ì†Œë“¤ì˜ í•©(sum)ì„ reduce(0, +)ë¡œ ê³„ì‚°
   - ë§ì…ˆì˜ í•­ë“±ì› 0ì„ ì´ˆê¸°ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ì›ì†Œë¥¼ ë”í•¨

 - ì¡°ê±´ ë¹„êµ:
   - product < sum * sum ì¸ì§€ ê²€ì‚¬
   - ì¦‰, ì›ì†Œì˜ ê³±ì´ ì›ì†Œì˜ í•©ì˜ ì œê³±ë³´ë‹¤ ì‘ìœ¼ë©´ 1 ë°˜í™˜ (ì‚¼í•­ ì—°ì‚°ìë¥¼ ì‚¬ìš©)
   - ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ 0 ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ìˆ«ì ë¬¸ìì—´ê³¼ ì˜ë‹¨ì–´
 MARK: ìˆ«ì ë¬¸ìì—´ê³¼ ì˜ë‹¨ì–´
 
 - ë„¤ì˜¤ì™€ í”„ë¡œë„ê°€ ìˆ«ìë†€ì´ë¥¼ í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë„¤ì˜¤ê°€ í”„ë¡œë„ì—ê²Œ ìˆ«ìë¥¼ ê±´ë„¬ ë•Œ ì¼ë¶€ ìë¦¿ìˆ˜ë¥¼ ì˜ë‹¨ì–´ë¡œ ë°”ê¾¼ ì¹´ë“œë¥¼ ê±´ë„¤ì£¼ë©´ í”„ë¡œë„ëŠ” ì›ë˜ ìˆ«ìë¥¼ ì°¾ëŠ” ê²Œì„ì…ë‹ˆë‹¤.

 - ë‹¤ìŒì€ ìˆ«ìì˜ ì¼ë¶€ ìë¦¿ìˆ˜ë¥¼ ì˜ë‹¨ì–´ë¡œ ë°”ê¾¸ëŠ” ì˜ˆì‹œì…ë‹ˆë‹¤.

 - 1478 â†’ "one4seveneight"
 - 234567 â†’ "23four5six7"
 - 10203 â†’ "1zerotwozero3"
 - ì´ë ‡ê²Œ ìˆ«ìì˜ ì¼ë¶€ ìë¦¿ìˆ˜ê°€ ì˜ë‹¨ì–´ë¡œ ë°”ë€Œì–´ì¡Œê±°ë‚˜, í˜¹ì€ ë°”ë€Œì§€ ì•Šê³  ê·¸ëŒ€ë¡œì¸ ë¬¸ìì—´ sê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. sê°€ ì˜ë¯¸í•˜ëŠ” ì›ë˜ ìˆ«ìë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
  
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [3, 4, 5, 2, 1]ì´ë¼ë©´ 1ì„ return
 - num_listê°€ [5, 7, 8, 3]ì´ë¼ë©´ 0ì„ return
 
 - aê°€ 6 bê°€ 1ë¼ë©´ 14ë¥¼ return
 - aê°€ 2 bê°€ 4ë¼ë©´ 2ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ sì˜ ê¸¸ì´ â‰¤ 50
 - sê°€ "zero" ë˜ëŠ” "0"ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ê²½ìš°ëŠ” ì£¼ì–´ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - return ê°’ì´ 1 ì´ìƒ 2,000,000,000 ì´í•˜ì˜ ì •ìˆ˜ê°€ ë˜ëŠ” ì˜¬ë°”ë¥¸ ì…ë ¥ë§Œ së¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤.

 */

func solution35(_ s:String) -> Int {
    let numberWords: [String: String] = [
        "zero" : "0", "one" : "1", "two" : "2", "three" : "3", "four" : "4",
        "five" : "5", "six" : "6", "seven" : "7", "eight" : "8", "nine" : "9"
    ]
    
    var result = s
    
    for (word, digit) in numberWords {
        result = result.replacingOccurrences(of: word, with: digit)
    }
    return Int(result)!
}

/*:
 ## ì„¤ëª…
 - ë¨¼ì € numberWords ë”•ì…”ë„ˆë¦¬ ì„ ì–¸í•´ì„œ "ì˜ë‹¨ì–´" -> "ìˆ«ì" í˜•íƒœë¡œ ë³€í™˜ ê·œì¹™ì„ ì €ì¥
 - result ë³€ìˆ˜ì— s ë§¤ê°œë³€ìˆ˜ë¥¼ ë³µì‚¬í•´ì„œ ì‚¬ìš©(sëŠ” í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ì´ê¸° ë•Œë¬¸ì— ìƒìˆ˜ë¡œ ê°„ì£¼ë˜ë¯€ë¡œ ìˆ˜ì • ê°€ëŠ¥í•œ resultë¥¼ ì„ ì–¸)
 - for ë£¨í”„ë¥¼ í†µí•´ì„œ "zero"ë¶€í„° "nine"ê¹Œì§€ ì°¨ë¡€ë¡œ ë³€í™˜
 - replacingOccurrences(of: with:) í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ wordë¥¼ digitìœ¼ë¡œ ë°”ê¿ˆ
 - ë³€í™˜ì´ ëë‚˜ë©´ resultë¥¼ Intë¡œ í˜•ë³€í™˜ì„ í•˜ê³  ê°•ì œ ì–¸ë˜í•‘ì„ í•œ í›„ return
    - ê°•ì œ ì–¸ë˜í•‘ì„ í•˜ëŠ” ì´ìœ ëŠ” Int(...)ëŠ” í•­ìƒ ì˜µì…”ë„ íƒ€ì…ìœ¼ë¡œ ë°˜í™˜í•˜ê³  ì´ ë¬¸ì œì—ì„œëŠ” nilì´ ì—†ê¸° ë•Œë¬¸ì— ê°•ì œ ì–¸ë˜í•‘ì„ ì‚¬ìš©í•¨
    - ë§Œì•½ ë¬¸ì œì—ì„œ nilë„ í¬í•¨ì´ ëœë‹¤ë©´ if let or guard letì„ ì‚¬ìš©í•´ì„œ ì˜µì…”ë„ ë°”ì¸ë”©ì„ í•´ì•¼ í•¨
 */


/*:
 ## ğŸ“Œ 0 ë–¼ê¸°
 MARK: 0 ë–¼ê¸°
 
 - ì •ìˆ˜ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ n_strì´ ì£¼ì–´ì§ˆ ë•Œ, n_strì˜ ê°€ì¥ ì™¼ìª½ì— ì²˜ìŒìœ¼ë¡œ ë“±ì¥í•˜ëŠ” 0ë“¤ì„ ë—€ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - n_strì´ "0010"ì´ë¼ë©´ "10"ì„ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ n_str â‰¤ 10
 - n_strì´ "0"ìœ¼ë¡œë§Œ ì´ë£¨ì–´ì§„ ê²½ìš°ëŠ” ì—†ìŠµë‹ˆë‹¤.
 */

func solution36(_ n_str:String) -> String {
    let result = n_str.drop(while: { $0 == "0"})
    return String(result)
}

/*:
 ## ì„¤ëª…
 - drop(while:)ì„ ì‚¬ìš©í•´ì„œ ë¬¸ì í•˜ë‚˜í•˜ë‚˜ë¥¼ ë°›ì•„ì„œ "0"ì¼ ë•Œë§Œ 0ì„ ì œê±°í•˜ë„ë¡ ì¡°ê±´ì„ ì„¤ì •
 - (0ì´ ì—°ì†ìœ¼ë¡œ 2ë²ˆ ë‚˜ì˜¤ë©´, ì²« ë²ˆì§¸ 0ì—ì„œ í•´ë‹¹ ì¡°ê±´ì´ ì„±ê³µ í–ˆìœ¼ë¯€ë¡œ ë‘ ë²ˆì§¸ 0ì—ì„œë„ í•´ë‹¹ ë™ì‘ ìˆ˜í–‰)
 - 0ì´ ì•ˆ ë‚˜ì˜¤ëŠ” ìˆœê°„ë¶€í„°ëŠ” ë‚¨ì€ ë¬¸ìë“¤ì„ ìœ ì§€
 - í•´ë‹¹ ê²°ê³¼ëŠ” Substring íƒ€ì…ì´ë¯€ë¡œ resultë¥¼ String()ìœ¼ë¡œ ê°ì‹¸ì„œ return
 */
