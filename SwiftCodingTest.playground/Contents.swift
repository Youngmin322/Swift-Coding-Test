import Foundation

/*:
 # ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´
 ## ğŸ“Œ ê¸€ì ì´ì–´ ë¶™ì—¬ ë¬¸ìì—´ ë§Œë“¤ê¸°
 MARK: ê¸€ì ì´ì–´ ë¶™ì—¬ ë¬¸ìì—´ ë§Œë“¤ê¸°
 
 - ì£¼ì–´ì§„ ë¬¸ìì—´ `my_string`ì—ì„œ `index_list`ì— í•´ë‹¹í•˜ëŠ” ë¬¸ìë“¤ì„ ìˆœì„œëŒ€ë¡œ ì¶”ì¶œí•˜ì—¬ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ `my_string`ê³¼ ì •ìˆ˜ ë°°ì—´ `index_list`ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
 - `index_list`ì˜ ì›ì†Œë“¤ì€ `my_string`ì˜ ì¸ë±ìŠ¤ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 - í•´ë‹¹ ì¸ë±ìŠ¤ì˜ ë¬¸ìë“¤ì„ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì—¬ ìƒˆë¡œìš´ ë¬¸ìì—´ì„ ë§Œë“­ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - `1 â‰¤ my_string.count â‰¤ 1,000`
 - `1 â‰¤ index_list.count â‰¤ 1,000`
 - `0 â‰¤ index_list[i] < my_string.count`
 */

func solution1(_ my_string: String, _ index_list: [Int]) -> String {
    let char = Array(my_string)  // ë¬¸ìì—´ì„ ë¬¸ì ë°°ì—´ë¡œ ë³€í™˜
    return index_list.map { String(char[$0]) }.joined()
}

/*:
 ## ì˜ˆì œ ì‹¤í–‰
 */

let my_string1 = "cvsgiorszzzmrpaqpe"
let index_list1 = [16, 6, 5, 3, 12, 14, 11, 11, 17, 12, 7]
solution1(my_string1, index_list1)  // "programmers"

let my_string2 = "zpiaz"
let index_list2 = [1, 2, 0, 0, 3]
solution1(my_string2, index_list2)  // "pizza"

/*:
 ## ì„¤ëª…
 - `Array(my_string)`: ë¬¸ìì—´ì„ ë°°ì—´ë¡œ ë³€í™˜í•˜ì—¬ ë¬¸ì ì¸ë±ì‹±ì„ ì‰½ê²Œ ë§Œë“¦
 - `index_list.map { String(char[$0]) }`: ì£¼ì–´ì§„ ì¸ë±ìŠ¤ì˜ ë¬¸ìë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
 - `.joined()`: ëª¨ë“  ë¬¸ìë¥¼ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ í•©ì¹¨
 */

/*:
 ## ğŸ“Œ ì˜ë¼ì„œ ë°°ì—´ë¡œ ì €ì¥í•˜ê¸°
 MARK: ì˜ë¼ì„œ ë°°ì—´ë¡œ ì €ì¥í•˜ê¸°
 
 - ë¬¸ìì—´ my_strê³¼ nì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_strì„ ê¸¸ì´ nì”© ì˜ë¼ì„œ ì €ì¥í•œ ë°°ì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ `my_str`ê³¼ ë§¤ê°œë³€ìˆ˜ `n`ì´ ì£¼ì–´ì§
 - my_strì„ në§Œí¼ ì˜ë¼ì„œ ì €ì¥í•´ì•¼ ë¨
 - ì €ì¥í•œ ë°°ì—´ì„ ë‹¤ì‹œ returní•˜ë„ë¡ ì½”ë“œë¥¼ ì‘ì„±
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ my_strì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ n â‰¤ my_strì˜ ê¸¸ì´
 - my_strì€ ì•ŒíŒŒë²³ ì†Œë¬¸ì, ëŒ€ë¬¸ì, ìˆ«ìë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 
 */

func solution2(_ my_str: String, _ n: Int) -> [String] {
    var result: [String] = []
    let length = my_str.count
    
    for i in stride(from: 0, to: length, by: n) {
        let start = my_str.index(my_str.startIndex, offsetBy: i)
        let end = my_str.index(start, offsetBy: n, limitedBy: my_str.endIndex) ?? my_str.endIndex
        result.append(String(my_str[start..<end]))
    }
    
    return result
}

/*:
 ## ì˜ˆì œ ì‹¤í–‰
 */

//print(solution("abc1Addfggg4556b", 6)) // ["abc1Ad", "dfggg4", "556b"]
//print(solution("abcdef123", 3)) // ["abc", "def", "123"]
//print(solution("helloWorld", 4)) // ["hell", "oWor", "ld"]

/*:
 ## ì„¤ëª…
 - ê²°ê³¼ë¥¼ ì €ì¥í•  result ë°°ì—´ì„ ìƒì„±
 - stride(from:to:by:)ë¥¼ ì‚¬ìš©í•´ì„œ 0ë¶€í„° my_str.countê¹Œì§€ nê°„ê²©ìœ¼ë¡œ ìˆœíšŒí•˜ë©´ì„œ ë¬¸ìì—´ì„ ìë¦„
 - ë¬¸ìì—´ ìŠ¬ë¼ì´ì‹± (startIndex: í˜„ì¬ iìœ„ì¹˜ì—ì„œ ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤, endIndex: startIndexì—ì„œ në§Œí¼ ì´ë™, í•˜ì§€ë§Œ ë¬¸ìì—´ ëì„ ë„˜ìœ¼ë©´ endIndex = my_str.endIndex
 - ì˜ë¼ë‚¸ ë¬¸ìì—´ì„ ë°°ì—´ì— ì¶”ê°€
 - \* limitedBy: my_str.endIndexë¥¼ ì‚¬ìš©í•´ì„œ ë§ˆì§€ë§‰ ë‚¨ì€ ë¬¸ìì—´ë„ ê·¸ëŒ€ë¡œ ì¶”ê°€ë˜ë„ë¡ ì„¤ì •
 */


/*:
 ## ğŸ“Œ OX í€´ì¦ˆ
 MARK: OX í€´ì¦ˆ
 
 - ë§ì…ˆ, ëº„ì…ˆ ìˆ˜ì‹ë“¤ì´ 'X [ì—°ì‚°ì] Y = Z' í˜•íƒœë¡œ ë“¤ì–´ìˆëŠ” ë¬¸ìì—´ ë°°ì—´ quizê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. ìˆ˜ì‹ì´ ì˜³ë‹¤ë©´ "O"ë¥¼ í‹€ë¦¬ë‹¤ë©´ "X"ë¥¼ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë°°ì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ìˆ˜ì‹ì´ ë“¤ì–´ìˆëŠ” quizê°€ ë°°ì—´ë¡œ ì œê³µ
 - í•´ë‹¹ ë°°ì—´ì˜ ê³„ì‚° ê²°ê³¼ê°€ ë§ë‹¤ë©´ O, í‹€ë¦¬ë‹¤ë©´ Xë¥¼ ë¦¬í„´í•´ì•¼ í•¨
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - ì—°ì‚° ê¸°í˜¸ì™€ ìˆ«ì ì‚¬ì´ëŠ” í•­ìƒ í•˜ë‚˜ì˜ ê³µë°±ì´ ì¡´ì¬í•©ë‹ˆë‹¤. ë‹¨ ìŒìˆ˜ë¥¼ í‘œì‹œí•˜ëŠ” ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ì™€ ìˆ«ì ì‚¬ì´ì—ëŠ” ê³µë°±ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - 1 â‰¤ quizì˜ ê¸¸ì´ â‰¤ 10
 - X, Y, ZëŠ” ê°ê° 0ë¶€í„° 9ê¹Œì§€ ìˆ«ìë¡œ ì´ë£¨ì–´ì§„ ì •ìˆ˜ë¥¼ ì˜ë¯¸í•˜ë©°, ê° ìˆ«ìì˜ ë§¨ ì•ì— ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ê°€ í•˜ë‚˜ ìˆì„ ìˆ˜ ìˆê³  ì´ëŠ” ìŒìˆ˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
 - X, Y, ZëŠ” 0ì„ ì œì™¸í•˜ê³ ëŠ” 0ìœ¼ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - -10,000 â‰¤ X, Y â‰¤ 10,000
 - -20,000 â‰¤ Z â‰¤ 20,000
 - [ì—°ì‚°ì]ëŠ” + ì™€ - ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.
 */

func solution3(_ quiz:[String]) -> [String] {
    var answer: [String] = []
    
    for q in quiz {
        let parts = q.components(separatedBy: " ")
        let x = Int(parts[0])!
        let y = Int(parts[2])!
        let z = Int(parts[4])!
        
        var result = 0
        
        switch parts[1] {
        case "+":
            result = x + y
        case "-":
            result = x - y
        default:
            break
        }
        
        answer.append(result == z ? "O" : "X")
    }
    
    return answer
}

/*:
 ## ì„¤ëª…
 - ê²°ê³¼ë¥¼ ì €ì¥í•  answer ë³€ìˆ˜ ì„ ì–¸ (ë‹¨, ë°°ì—´ì„ ë¦¬í„´í•´ì•¼ í•˜ë¯€ë¡œ ë¹ˆ ë°°ì—´ë¡œ ë³€ìˆ˜ë¥¼ ì„ ì–¸)
 - components(separatedBy: " ")ë¥¼ ì‚¬ìš©í•´ì„œ ê³µë°±ì„ ê¸°ì¤€ìœ¼ë¡œ ê° íŒŒì¸ ë³„ë¡œ ë‚˜ëˆ„ê³  ê°ê°ì˜ íŒŒì¸ ë³„ë¡œ ìˆ«ìëŠ” ì •ìˆ˜í˜•ìœ¼ë¡œ ì—°ì‚°ìëŠ” switch caseë¡œ ê³„ì‚°ì‹ì„ ë‚˜ëˆ”
 - xì—ëŠ” 0ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì…, yì—ëŠ” 2ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì…, zì—ëŠ” 4ë²ˆ ì¸ë±ìŠ¤ë¥¼ ê°€ì§„ íŒŒì¸ ë¥¼ ëŒ€ì… (!ì„ ì‚¬ìš©í•œ ì´ìœ ëŠ” ë¬´ì¡°ê±´ ê°’ì´ ìˆê¸° ë•Œë¬¸)
 - ê° ì¼€ì´ìŠ¤ ë³„ë¡œ ì¸ë±ìŠ¤ 1ë²ˆì„ ê°€ì§„ íŒŒì¸ ê°€ + ë¼ë©´ ë§ì…ˆ ì—°ì‚°ìë¥¼ ì‹¤í–‰, ë§Œì•½ - ë¼ë©´ ëº„ì…ˆ ì—°ì‚°ìë¥¼ ì‹¤í–‰í•˜ë„ë¡ ê²½ìš°ë¥¼ ë‚˜ëˆ”
 - ì‚¼í•­ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ì„œ ì •ë‹µì€ O, ì˜¤ë‹µì€ Xë¥¼ answer ë°°ì—´ì— ì¶”ê°€í•˜ê¸° ìœ„í•´ appendë¥¼ ì‚¬ìš©
 - answerë¥¼ ë¦¬í„´
 */



/*:
 ## ğŸ“Œ ë‹¤ìŒì— ì˜¬ ìˆ«ì
 MARK: ë‹¤ìŒì— ì˜¬ ìˆ«ì
 
 - ë“±ì°¨ìˆ˜ì—´ í˜¹ì€ ë“±ë¹„ìˆ˜ì—´ commonì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë§ˆì§€ë§‰ ì›ì†Œ ë‹¤ìŒìœ¼ë¡œ ì˜¬ ìˆ«ìë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ë³´ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë°°ì—´ì´ [1, 2, 3, 4] ë¼ë©´ ê³µì°¨ê°€ 1ì¸ ë“±ì°¨ìˆ˜ì—´ì´ë¯€ë¡œ ë‹¤ìŒì— ì˜¬ ìˆ˜ëŠ” 5ì´ë¯€ë¡œ 5ì„ return
 - ë°°ì—´ì´ [2, 4, 8] ë¼ë©´ ê³µë¹„ê°€ 2ì¸ ë“±ë¹„ìˆ˜ì—´ì´ë¯€ë¡œ ë‹¤ìŒì— ì˜¬ ìˆ˜ëŠ” 16ì´ë¯€ë¡œ 16ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 < commonì˜ ê¸¸ì´ < 1,000
 - -1,000 < commonì˜ ì›ì†Œ < 2,000
 - commonì˜ ì›ì†ŒëŠ” ëª¨ë‘ ì •ìˆ˜ì…ë‹ˆë‹¤.
 - ë“±ì°¨ìˆ˜ì—´ í˜¹ì€ ë“±ë¹„ìˆ˜ì—´ì´ ì•„ë‹Œ ê²½ìš°ëŠ” ì—†ìŠµë‹ˆë‹¤.
 - ë“±ë¹„ìˆ˜ì—´ì¸ ê²½ìš° ê³µë¹„ëŠ” 0ì´ ì•„ë‹Œ ì •ìˆ˜ì…ë‹ˆë‹¤.
 
 */

func solution4(_ common:[Int]) -> Int {
    
    if common[1] - common[0] == common[2] - common[1] {
        let difference = common[1] - common[0]
        return common.last! + difference
    } else {
        let ratio = common[2] / common[1]
        return common.last! * ratio
    }
}

/*:
 ## ì„¤ëª…
 - ìš°ì„  ë“±ì°¨ìˆ˜ì—´ì¸ì§€ ë“±ë¹„ìˆ˜ì—´ì¸ì§€ íŒë‹¨í•˜ê¸° ìœ„í•´ common[1] - common[0] == common[2] - common[1] ë¹„êµ (í•´ë‹¹ ì‹ì´ ì„±ë¦½í•˜ë©´ ë“±ì°¨ìˆ˜ì—´, ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ ë“±ë¹„ìˆ˜ì—´)
 - ë§Œì•½ ë“±ì°¨ìˆ˜ì—´ì´ë¼ë©´ ì¸ë±ìŠ¤ 1ë²ˆê³¼ ì¸ë±ìŠ¤ 0ì„ ëº€ ê°’ì´ ê³µì°¨ì´ë¯€ë¡œ í•´ë‹¹ ê³µì°¨ë¥¼ difference ë³€ìˆ˜ì— ëŒ€ì…í•´ì£¼ê³  return ê°’ìœ¼ë¡œ commonì˜ ë§ˆì§€ë§‰ í•­ì— ë”í•´ì¤Œ
 - ë§Œì•½ ë“±ë¹„ìˆ˜ì—´ì´ë¼ë©´ ì¸ë±ìŠ¤ 2ë²ˆê³¼ 1ë²ˆì„ ë‚˜ëˆˆ ê°’ì„ ratio ë³€ìˆ˜ì— ëŒ€ì…í•´ì£¼ê³  return ê°’ìœ¼ë¡œ commonì˜ ë§ˆì§€ë§‰ í•­ì— ratio ë³€ìˆ˜ë¥¼ ê³±í•œ ê°’ì„ ë°˜í™˜
 - ë¬¸ì œ ì¡°ê±´ì— ë”°ë¥´ë©´ ë“±ë¹„ìˆ˜ì—´ì˜ ê³µë¹„ëŠ” 0ì´ ì•„ë‹Œ ì •ìˆ˜ì´ë¯€ë¡œ, ë‚˜ëˆ—ì…ˆ ì—°ì‚°ì—ì„œ ë¬¸ì œê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ
 - \*common.last!ëŠ” ë°°ì—´ì˜ ë§ˆì§€ë§‰ ìš”ì†Œë¥¼ ê°€ì ¸ì˜´
 */


/*:
 ## ğŸ“Œ ë‹¤ìŒì— ì˜¬ ìˆ«ì
 MARK: ë‹¤ìŒì— ì˜¬ ìˆ«ì
 
 - êµ° ì „ëµê°€ ë¨¸ì“±ì´ëŠ” ì „ìŸ ì¤‘ ì êµ°ì´ ë‹¤ìŒê³¼ ê°™ì€ ì•”í˜¸ ì²´ê³„ë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒì„ ì•Œì•„ëƒˆìŠµë‹ˆë‹¤.
 - ì•”í˜¸í™”ëœ ë¬¸ìì—´ cipherë¥¼ ì£¼ê³ ë°›ìŠµë‹ˆë‹¤.
 - ê·¸ ë¬¸ìì—´ì—ì„œ codeì˜ ë°°ìˆ˜ ë²ˆì§¸ ê¸€ìë§Œ ì§„ì§œ ì•”í˜¸ì…ë‹ˆë‹¤.
 - ë¬¸ìì—´ cipherì™€ ì •ìˆ˜ codeê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ í•´ë…ëœ ì•”í˜¸ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë¬¸ìì—´ cipherê°€ "dfjardstddetckdaccccdegk" ì´ê³  codeê°€ 4ë¡œ ì£¼ì–´ì§„ë‹¤ë©´ 4, 8, 16, 20, 14ë²ˆì§¸ ê¸€ìë¥¼ í•©ì¹œ "attackì„ return í•´ì•¼ í•¨
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 < commonì˜ ê¸¸ì´ < 1,000
 - -1,000 < commonì˜ ì›ì†Œ < 2,000
 - commonì˜ ì›ì†ŒëŠ” ëª¨ë‘ ì •ìˆ˜ì…ë‹ˆë‹¤.
 - ë“±ì°¨ìˆ˜ì—´ í˜¹ì€ ë“±ë¹„ìˆ˜ì—´ì´ ì•„ë‹Œ ê²½ìš°ëŠ” ì—†ìŠµë‹ˆë‹¤.
 - ë“±ë¹„ìˆ˜ì—´ì¸ ê²½ìš° ê³µë¹„ëŠ” 0ì´ ì•„ë‹Œ ì •ìˆ˜ì…ë‹ˆë‹¤.
 
 */


func solution5(_ cipher:String, _ code:Int) -> String {
    return cipher.enumerated()
        .filter { ($0.offset + 1) % code == 0 }
        .map { String($0.element) }
        .joined()
}

/*:
 ## ì„¤ëª…
 - enumerated()ë¥¼ ì‚¬ìš©í•´ì„œ ê° ë¬¸ìì— ëŒ€í•´ ì¸ë±ìŠ¤ë¥¼ ê°€ì ¸ì˜´
 - \* enumerated()ëŠ” Swiftì—ì„œ ê° ìš”ì†Œì˜ ì¸ë±ìŠ¤ì™€ ê°’ì„ í•¨ê»˜ ê°€ì ¸ì˜¤ëŠ” ë©”ì„œë“œ (ê° ìš”ì†Œê°€ ëª‡ ë²ˆì§¸ ìœ„ì¹˜ì— ìˆëŠ”ì§€ ì•Œì•„ì•¼ í•  ë•Œ ì‚¬ìš©)
 - filter í•¨ìˆ˜ë¥¼ í†µí•´ codeì˜ ë°°ìˆ˜ì¸ ì¸ë±ìŠ¤ë§Œ ë‚¨ê¸°ê¸° ìœ„í•´ ($0.offset + 1) % code == 0} ì„ ì‘ì„±, offsetì€ ê¸°ë³¸ì ìœ¼ë¡œ 0ë¶€í„° ì‹œì‘í•˜ê¸° ë•Œë¬¸ì— +1ì„ í•´ì¤˜ì„œ 1ë¶€í„° ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤ë¡œ ì‚¬ìš©
 - filterë¡œ ë¶„ë¥˜í•œ ê²ƒì„ Stringìœ¼ë¡œ ë³€í™˜í•´ì£¼ê³  mapì„ ì‚¬ìš©í•´ì„œ í•˜ë‚˜ì˜ ë°°ì—´ë¡œ ë§Œë“¦
 - joined()ë¥¼ ì‚¬ìš©í•´ì„œ í•„í„°ë§ëœ ë¬¸ìë“¤ì„ í•©ì³ ìµœì¢… ë¬¸ìì—´ì„ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ í° ì‚¬ëŒ
 MARK: ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ í° ì‚¬ëŒ
 
 
 - ë¨¸ì“±ì´ëŠ” í•™êµì—ì„œ í‚¤ ìˆœìœ¼ë¡œ ì¤„ì„ ì„¤ ë•Œ ëª‡ ë²ˆì§¸ë¡œ ì„œì•¼ í•˜ëŠ”ì§€ ê¶ê¸ˆí•´ì¡ŒìŠµë‹ˆë‹¤. ë¨¸ì“±ì´ë„¤ ë°˜ ì¹œêµ¬ë“¤ì˜ í‚¤ê°€ ë‹´ê¸´ ì •ìˆ˜ ë°°ì—´ arrayì™€ ë¨¸ì“±ì´ì˜ í‚¤ heightê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ í° ì‚¬ëŒ ìˆ˜ë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ë³´ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ ë¨¸ì“±ì´ì˜ í‚¤(height)ê°€ 140ì´ê³  ì¹œêµ¬ë“¤ì˜ í‚¤(array)ê°€ [145, 130, 160, 180] ì´ë¼ë©´ 3ì„ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ arrayì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ height â‰¤ 200
 - 1 â‰¤ arrayì˜ ì›ì†Œ â‰¤ 200
 
 */


func solution6(_ array:[Int], _ height:Int) -> Int {
    let tallerPeople = array.filter{ $0 > height }
    return tallerPeople.count
}


/*:
 ## ì„¤ëª…
 - ìš°ì„  ë¨¸ì“±ì´ë³´ë‹¤ í‚¤ê°€ í° ì‚¬ëŒì„ ë¶„ë¥˜í•˜ê¸° ìœ„í•´ filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê³  í•´ë‹¹ ê°’ì„ ë‹´ì„ ë³€ìˆ˜(tallerPeople)ë¥¼ ì„ ì–¸
 - return ê°’ì„ tallerPeopleë¡œ í•˜ê³  ë°˜í™˜í•´ì•¼ í•˜ëŠ” ê°’ì´ í‚¤ê°€ ì•„ë‹Œ í‚¤ í° ì‚¬ëŒì˜ ìˆ˜ì´ë¯€ë¡œ tallerPeople.countë¡œ ê°œìˆ˜ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆë„ë¡ ì‘ì„±
 */


/*:
 ## ğŸ“Œ ëª¨ìŒ ì œê±°
 MARK: ëª¨ìŒ ì œê±°
 
 - ì˜ì–´ì—ì„  a, e, i, o, u ë‹¤ì„¯ ê°€ì§€ ì•ŒíŒŒë²³ì„ ëª¨ìŒìœ¼ë¡œ ë¶„ë¥˜í•©ë‹ˆë‹¤. ë¬¸ìì—´ my_stringì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ ëª¨ìŒì„ ì œê±°í•œ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ my_stringìœ¼ë¡œ busê°€ ì£¼ì–´ì§„ë‹¤ë©´, uë¥¼ ì œê±°í•œ bsë¥¼ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - my_stringì€ ì†Œë¬¸ìì™€ ê³µë°±ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 */


func solution7(_ my_string:String) -> String {
    return my_string.filter { !["a", "e", "i", "o", "u"].contains($0) }
    
}

/*:
 ## ì„¤ëª…
 - filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ a, e, i, o, uê°€ ì•„ë‹Œ(!) ìš”ì†Œë“¤ì„ ë½‘ì•„ì„œ return
 */

/*:
 ## ğŸ“Œ ì¹˜í‚¨ ì¿ í°
 MARK: ì¹˜í‚¨ ì¿ í°
 
 - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì¹˜í‚¨ì€ ì¹˜í‚¨ì„ ì‹œì¼œë¨¹ìœ¼ë©´ í•œ ë§ˆë¦¬ë‹¹ ì¿ í°ì„ í•œ ì¥ ë°œê¸‰í•©ë‹ˆë‹¤. ì¿ í°ì„ ì—´ ì¥ ëª¨ìœ¼ë©´ ì¹˜í‚¨ì„ í•œ ë§ˆë¦¬ ì„œë¹„ìŠ¤ë¡œ ë°›ì„ ìˆ˜ ìˆê³ , ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ë„ ì¿ í°ì´ ë°œê¸‰ë©ë‹ˆë‹¤. ì‹œì¼œë¨¹ì€ ì¹˜í‚¨ì˜ ìˆ˜ chickenì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ ë°›ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì„œë¹„ìŠ¤ ì¹˜í‚¨ì˜ ìˆ˜ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ ì¹˜í‚¨ì„ 100ë§ˆë¦¬ ì‹œì¼°ë‹¤ë©´ ì¿ í° 100ì¥ì´ ë°œê¸‰ë˜ë¯€ë¡œ ì„œë¹„ìŠ¤ ì¹˜í‚¨ 10ë§ˆë¦¬ë¥¼ ì£¼ë¬¸í•  ìˆ˜ ìˆê³  ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ë„ ì¿ í°ì´ ë°œê¸‰ë˜ë¯€ë¡œ ì„œë¹„ìŠ¤ ì¹˜í‚¨ 10ë§ˆë¦¬ì— + ì„œë¹„ìŠ¤ ì¹˜í‚¨ìœ¼ë¡œ ë°›ì€ ì¿ í°(10ì¥)ìœ¼ë¡œ ì¹˜í‚¨ 1ë§ˆë¦¬ë¥¼ ë” ì£¼ë¬¸í•´ì„œ ì´ 11ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - chickenì€ ì •ìˆ˜ì…ë‹ˆë‹¤.
 - 0 â‰¤ chicken â‰¤ 1,000,000
 */


func solution8(_ chicken:Int) -> Int {
    if chicken < 10 {
        return 0
    }
    let service = chicken / 10
    return service + solution8(service + (chicken % 10))
}

/*:
 ## ì„¤ëª…
 - ì¹˜í‚¨ì´ 10ì´ ë„˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì²˜ë¦¬í•  ê²Œ ì—†ìœ¼ë¯€ë¡œ 0ì„ return
 - í˜„ì¬ ì¹˜í‚¨ ìˆ˜ì—ì„œ 10ë§ˆë¦¬ë‹¹ 1ë§ˆë¦¬ì”© ì„œë¹„ìŠ¤ ì¹˜í‚¨ì„ ë°›ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ chicken / 10ì„ ê³„ì‚°
 - í˜„ì¬ ì„œë¹„ìŠ¤ ì¹˜í‚¨ ê°œìˆ˜(service)ë¥¼ ë”í•œ í›„, ì¬ê·€ í˜¸ì¶œì„ í•¨
 - ì¬ê·€í˜¸ì¶œ ì¸ìëŠ” (service + (chicken % 10))
 - ì¦‰, í˜„ì¬ ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ì„œ ë°›ì€ ì¿ í°ê³¼ ê¸°ì¡´ì˜ ë‚¨ì€ ì¿ í°ì„ í•©ì³ì„œ ì¬ê·€ í˜¸ì¶œì„ í•¨
 - \* ì¬ê·€ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ì¹˜í‚¨ì„ ë¨¹ìœ¼ë©´ ì¿ í°ì´ ë‚˜ì˜¤ê³ , ì¿ í°ì´ 10ì¥ì´ ë„˜ìœ¼ë©´ ë‹¤ì‹œ ì¹˜í‚¨ì„ ë°›ì„ ìˆ˜ ìˆëŠ” êµ¬ì¡°ì´ë¯€ë¡œ ê³„ì† ë°˜ë³µë¨ ì¦‰, í•œ ë²ˆ ì¹˜í‚¨ì„ ì„œë¹„ìŠ¤ë¡œ ë°›ì€ í›„ ê·¸ ì„œë¹„ìŠ¤ ì¹˜í‚¨ì—ì„œ ë˜ ì¿ í°ì´ ë‚˜ì˜¤ëŠ” ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— ì¬ê·€ë¥¼ ì‚¬ìš©
 */




/*:
 ## ğŸ“Œ ê°€ìœ„ ë°”ìœ„ ë³´
 MARK: ê°€ìœ„ ë°”ìœ„ ë³´
 
 - ê°€ìœ„ëŠ” 2 ë°”ìœ„ëŠ” 0 ë³´ëŠ” 5ë¡œ í‘œí˜„í•©ë‹ˆë‹¤. ê°€ìœ„ ë°”ìœ„ ë³´ë¥¼ ë‚´ëŠ” ìˆœì„œëŒ€ë¡œ ë‚˜íƒ€ë‚¸ ë¬¸ìì—´ rspê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, rspì— ì €ì¥ëœ ê°€ìœ„ ë°”ìœ„ ë³´ë¥¼ ëª¨ë‘ ì´ê¸°ëŠ” ê²½ìš°ë¥¼ ìˆœì„œëŒ€ë¡œ ë‚˜íƒ€ë‚¸ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ë³´ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - rspì˜ ê°’ì´ 2(ê°€ìœ„)ë¼ë©´ 0(ë°”ìœ„)ì„ ë¦¬í„´
 - rspì˜ ê°’ì´ 205(ê°€ìœ„ ë°”ìœ„ ë³´)ë¼ë©´ 052(ë°”ìœ„ ë³´ ê°€ìœ„)ë¥¼ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 < rspì˜ ê¸¸ì´ â‰¤ 100
 - rspì™€ ê¸¸ì´ê°€ ê°™ì€ ë¬¸ìì—´ì„ return í•©ë‹ˆë‹¤.
 - rspëŠ” ìˆ«ì 0, 2, 5ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 
 */


func Solution9(_ rsp:String) -> String {
    let mapping: [String: String] = ["2": "0", "0": "5", "5": "2"]
    
    return rsp.map { mapping[String($0)] ?? "?" }.joined()
}

/*:
 ## ì„¤ëª…
 - ê° ì¼€ì´ìŠ¤ ë³„ë¡œ ë¦¬í„´í•´ì•¼ í•˜ëŠ” ê²ƒì´ ì •í•´ì ¸ ìˆê¸° ë•Œë¬¸ì— key value ë§¤í•‘ì„ ì‚¬ìš©í•´ì„œ 2ëŠ” 0, 0ì€ 5, 5ëŠ” 2ë¡œ ì¹˜í™˜ì„ í•´ì¤Œ
 - rspì˜ ê° ë¬¸ìì— ëŒ€í•´ mapping ë”•ì…”ë„ˆë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë³€í™˜í•˜ê³ , ë³€í™˜ëœ ë¬¸ìë“¤ì„ joined()ë¥¼ ì‚¬ìš©í•´ì„œ ë‹¤ì‹œ í•©ì³ì„œ return
 */

/*:
 ## ğŸ“Œ ì§ìˆ˜ì˜ í•©
 MARK: ì§ìˆ˜ì˜ í•©
 
 - ì •ìˆ˜ nì´ ì£¼ì–´ì§ˆ ë•Œ, nì´í•˜ì˜ ì§ìˆ˜ë¥¼ ëª¨ë‘ ë”í•œ ê°’ì„ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ë§Œì•½ nì´ 10ì´ë¼ë©´ 2 + 4 + 6 + 8 + 10 = 30ì´ë¯€ë¡œ 30ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 < n â‰¤ 1000
 */

func solution9(_ n:Int) -> Int {
    var sum = 0
    for i in 1...n {
        if i % 2 == 0 {
            sum += i
        }
    }
    return sum
}

/*:
 ## ì„¤ëª…
 - ë”í•œ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(sum)ë¥¼ ì„ ì–¸í•˜ê³  0ìœ¼ë¡œ ì´ˆê¸°í™”
 - forë¬¸ê³¼ ifë¬¸ì„ ì´ìš©í•´ì„œ 1ë¶€í„° ì •ìˆ˜ nê¹Œì§€ i ë¥¼ 2ë¡œ ë‚˜ëˆ„ì–´ì„œ 0ì´ ë˜ëŠ” ê°’ë“¤ë§Œ sum ë³€ìˆ˜ì— ë”í•´ì¤Œ
 - í•´ë‹¹ ê°’ë“¤ì´ ë‹¤ ë”í•´ì§„ sum ë³€ìˆ˜ë¥¼ return
 */


/*:
 ## ğŸ“Œ ë§ˆì§€ë§‰ ë‘ ì›ì†Œ
 MARK: ë§ˆì§€ë§‰ ë‘ ì›ì†Œ
 
 - ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§ˆ ë•Œ, ë§ˆì§€ë§‰ ì›ì†Œê°€ ê·¸ì „ ì›ì†Œë³´ë‹¤ í¬ë©´ ë§ˆì§€ë§‰ ì›ì†Œì—ì„œ ê·¸ì „ ì›ì†Œë¥¼ ëº€ ê°’ì„ ë§ˆì§€ë§‰ ì›ì†Œê°€ ê·¸ì „ ì›ì†Œë³´ë‹¤ í¬ì§€ ì•Šë‹¤ë©´ ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ë‘ ë°°í•œ ê°’ì„ ì¶”ê°€í•˜ì—¬ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [2, 1, 6]ë¼ê³  ì£¼ì–´ì¡Œë‹¤ë©´ ë§ˆì§€ë§‰ ì›ì†Œì¸ 6ì´ ê·¸ ì „ ì›ì†Œì¸ 1ë³´ë‹¤ í¬ê¸° ë•Œë¬¸ì— 6 - 1ì¸ 5ë¥¼ ì¶”ê°€í•œ [2, 1, 6, 5]ë¥¼ ë¦¬í„´
 - num_listê°€ [5, 2, 1, 7, 5]ë¼ê³  ì£¼ì–´ì¡Œë‹¤ë©´ ë§ˆì§€ë§‰ ì›ì†Œì¸ 5ê°€ ê·¸ ì „ ì›ì†Œì¸ 7ë³´ë‹¤ í¬ì§€ ì•Šê¸° ë•Œë¬¸ì— 5ì˜ 2ë°°ì¸ 10ì„ ì¶”ê°€í•œ [5, 2, 1, 7, 5, 10]ì„ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 */


func solution10(_ num_list:[Int]) -> [Int] {
    let lastValue = num_list[num_list.count - 1]
    let secondLastValue = num_list[num_list.count - 2]
    var subValue = lastValue - secondLastValue
    
    if lastValue > secondLastValue {
        return num_list + [subValue]
    } else {
        return num_list + [lastValue * 2]
    }
}

/*:
 ## ì„¤ëª…
 - ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ë‹´ì„ ë³€ìˆ˜(lastValue)ì™€ ë§ˆì§€ë§‰ ì›ì†Œì—ì„œ ê·¸ ì „ ì›ì†Œì˜ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(secondLastValue)ë¥¼ ì„ ì–¸í•´ì£¼ê³  ë‘ ê°’ì„ ëº€ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(subValue)ë¥¼ ì„ ì–¸í•¨
 - ifë¬¸ìœ¼ë¡œ ë§ˆì§€ë§‰ ì›ì†Œê°€ ë” í¬ë‹¤ë©´ ê¸°ì¡´ ë°°ì—´(num_list)ì— ë‘ ê°’ì€ ëº€ ë³€ìˆ˜ë¥¼ ì¶”ê°€í•´ì£¼ê³  return
 - ê·¸ ì™¸ë¼ë©´ ê¸°ì¡´ ë°°ì—´ì— ë§ˆì§€ë§‰ ì›ì†Œì— 2ë°°ë¥¼ í•œ ê°’ì„ ë¦¬í„´
 */



/*:
 ## ğŸ“Œ í™€ìˆ˜ vs ì§ìˆ˜
 MARK: í™€ìˆ˜ vs ì§ìˆ˜
 
 - ì •ìˆ˜ê°€ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. num_listì˜ í™€ìˆ˜ë§Œ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì¸ ìˆ˜ì™€ ì§ìˆ˜ë§Œ ìˆœì„œëŒ€ë¡œ ì´ì–´ ë¶™ì¸ ìˆ˜ì˜ í•©ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [3, 4, 5, 2, 1]ë¡œ ì£¼ì–´ì¡Œë‹¤ë©´ í™€ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 351ì´ê³  ì§ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 42ì…ë‹ˆë‹¤. ë‘ ìˆ˜ì˜ í•©ì€ 393ì…ë‹ˆë‹¤.
 - num_listê°€ [5, 7, 8, 3]ìœ¼ë¡œ ì£¼ì–´ì¡Œë‹¤ë©´ í™€ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 573ì´ê³  ì§ìˆ˜ë§Œ ì´ì–´ ë¶™ì¸ ìˆ˜ëŠ” 8ì…ë‹ˆë‹¤. ë‘ ìˆ˜ì˜ í•©ì€ 581ì…ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - num_listì—ëŠ” ì ì–´ë„ í•œ ê°œì”©ì˜ ì§ìˆ˜ì™€ í™€ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.
 */


func solution11(_ num_list:[Int]) -> Int {
    var oddNum = num_list.filter { (number: Int) -> Bool in
        return number % 2 == 1
    }
    var evenNum = num_list.filter { (number: Int) -> Bool in
        return number % 2 == 0
    }
    
    let oddResult = oddNum.reduce(0) { accumulated, current in
        return accumulated * 10 + current
    }
    
    let evenResult = evenNum.reduce(0) { accumulated, current in
        return accumulated * 10 + current
    }
    
    return oddResult + evenResult
}

/*:
 ## ì„¤ëª…
 - í™€ìˆ˜ì™€ ì§ìˆ˜ë¥¼ ë³„ë„ë¡œ í•„í„°ë§í•˜ì—¬ ë‘ ë°°ì—´ë¡œ ë¶„ë¦¬í•¨
 - í™€ìˆ˜ë“¤ì„ í•˜ë‚˜ì˜ ìˆ«ìë¡œ ì´ì–´ë¶™ì„ (ì˜ˆ: [1,3,5] â†’ 135)
 - reduce í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ê° ìˆ«ìë¥¼ 10ì˜ ìë¦¬ì”© ì˜¬ë ¤ê°€ë©° ê³„ì‚°
 - ì§ìˆ˜ë“¤ë„ ê°™ì€ ë°©ì‹ìœ¼ë¡œ í•˜ë‚˜ì˜ ìˆ«ìë¡œ ì´ì–´ë¶™ì„ (ì˜ˆ: [2,4] â†’ 24)
 - ë‘ ê²°ê³¼ê°’ì„ ë”í•´ì„œ ìµœì¢… ë‹µì„ ë°˜í™˜í•¨
 */


/*:
 ## ğŸ“Œ ë¬¸ìì—´ ì•ì˜ nê¸€ì
 MARK: ë¬¸ìì—´ ì•ì˜ nê¸€ì
 
 - ë¬¸ìì—´ my_stringê³¼ ì •ìˆ˜ nì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_stringì˜ ì•ì˜ nê¸€ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - my_stringì€ ìˆ«ìì™€ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 - 1 â‰¤ n â‰¤ my_stringì˜ ê¸¸ì´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - num_listì—ëŠ” ì ì–´ë„ í•œ ê°œì”©ì˜ ì§ìˆ˜ì™€ í™€ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.
 */



func solution12(_ my_string:String, _ n:Int) -> String {
    let result = String(my_string.prefix(n))
    return result
}

/*:
 ## ì„¤ëª…
 - prefix ë©”ì„œë“œëŠ” ì•ì—ì„œë¶€í„° nê°œì˜ ë¬¸ìë¥¼ ê°€ì ¸ì˜¤ê¸° ë•Œë¬¸ì— prefixë¥¼ ì‚¬ìš©í•´ì„œ nê°œ ë§Œí¼ ê°€ì ¸ì˜¤ê³  ê°€ì ¸ì˜¨ ê°’ì„ ë³€ìˆ˜(result)ì— ë‹´ê³  í•´ë‹¹ ë³€ìˆ˜ë¥¼ return
 */

/*:
 ## ğŸ“Œ í•  ì¼ ëª©ë¡
 MARK: í•  ì¼ ëª©ë¡
 
 - ì˜¤ëŠ˜ í•´ì•¼ í•  ì¼ì´ ë‹´ê¸´ ë¬¸ìì—´ ë°°ì—´ todo_listì™€ ê°ê°ì˜ ì¼ì„ ì§€ê¸ˆ ë§ˆì³¤ëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” boolean ë°°ì—´ finishedê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, todo_listì—ì„œ ì•„ì§ ë§ˆì¹˜ì§€ ëª»í•œ ì¼ë“¤ì„ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - todo_list, finished, resultê°€ ê°ê° ["problemsolving", "practiceguitar", "swim", "studygraph"]    [true, false, true, false]    ["practiceguitar", "studygraph"]
 - todo_list ì¤‘ì—ì„œ "problemsolving"ê³¼ "swim"ì€ ë§ˆì³¤ê³ , "practiceguitar"ì™€ "studygraph"ëŠ” ì•„ì§ ë§ˆì¹˜ì§€ ëª»í–ˆìœ¼ë¯€ë¡œ todo_listì—ì„œ ë‚˜ì˜¨ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ ["practiceguitar", "studygraph"]ë¥¼ return í•©ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ todo_listì˜ ê¸¸ì´ 1 â‰¤ 100
 - 2 â‰¤ todo_listì˜ ì›ì†Œì˜ ê¸¸ì´ â‰¤ 20
 - todo_listì˜ ì›ì†ŒëŠ” ì˜ì†Œë¬¸ìë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - todo_listì˜ ì›ì†ŒëŠ” ëª¨ë‘ ì„œë¡œ ë‹¤ë¦…ë‹ˆë‹¤.
 - finished[i]ëŠ” true ë˜ëŠ” falseì´ê³  trueëŠ” todo_list[i]ë¥¼ ë§ˆì³¤ìŒì„, falseëŠ” ì•„ì§ ë§ˆì¹˜ì§€ ëª»í–ˆìŒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
 - ì•„ì§ ë§ˆì¹˜ì§€ ëª»í•œ ì¼ì´ ì ì–´ë„ í•˜ë‚˜ ìˆìŠµë‹ˆë‹¤.
 */


func solution13(_ todo_list:[String], _ finished:[Bool]) -> [String] {
    var result: [String] = []
    
    for (index, isFinished) in finished.enumerated() {
        if !isFinished {
            result.append(todo_list[index])
        }
    }
    return result
}

/*:
 ## ì„¤ëª…
 - todo_listì™€ finishedì˜ ì¸ë±ìŠ¤ë¥¼ ì´ìš©
 - enumerated()ë¥¼ ì‚¬ìš©í•´ì„œ ë°°ì—´ì˜ ê° ìš”ì†Œì— ëŒ€í•´ ì¸ë±ìŠ¤ì™€ ìš”ì†Œ ê°’ì„ í•¨ê»˜ ì œê³µí•˜ëŠ” ì‹œí€€ìŠ¤ë¥¼ ë°˜í™˜
 - ë§Œì•½ finished ë°°ì—´ì´ [true, false, true] ë¼ë©´
 - ì²« ë²ˆì§¸ ë°˜ë³µì—ì„œëŠ” index = 0, isFinished = true
 - ë‘ ë²ˆì§¸ ë°˜ë³µì—ì„œëŠ” index = 1, isFinished = false
 - ì„¸ ë²ˆì§¸ ë°˜ë³µì—ì„œëŠ” index = 2, isFinished = true
 - if ì¡°ê±´ë¬¸ì„ ì‚¬ìš©í•´ì„œ isFinishedì˜ ê°’ì´ falseì¼ ë•Œë§Œ ë‚´ë¶€ ì½”ë“œë¥¼ ì‹¤í–‰
 - todo_list[index]ë¡œ í˜„ì¬ ì¸ë±ìŠ¤ì— í•´ë‹¹í•˜ëŠ” í•  ì¼ í•­ë³µì— ì ‘ê·¼
 - ê·¸ í•­ëª©ì„ result ë°°ì—´ì— ì¶”ê°€í•œ í›„ resultë¥¼ return
 */


/*:
 ## ğŸ“Œ në³´ë‹¤ ì»¤ì§ˆ ë•Œê¹Œì§€ ë”í•˜ê¸°
 MARK: në³´ë‹¤ ì»¤ì§ˆ ë•Œê¹Œì§€ ë”í•˜ê¸°
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - numbers, n, resultê°€ ê°ê° [34, 5, 71, 29, 100, 34], 123, 139ë¡œ ì£¼ì–´ì¡Œë‹¤ë©´
 - 29ë¥¼ ë”í•œ ë’¤ì— sum ê°’ì€ 139ì´ê³  'n' ê°’ì¸ 123ë³´ë‹¤ í¬ë¯€ë¡œ 139ë¥¼ return í•©ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ numbersì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ numbersì˜ ì›ì†Œ â‰¤ 100
 - 0 â‰¤ n < numbersì˜ ëª¨ë“  ì›ì†Œì˜ í•©
 */

func solution14(_ numbers:[Int], _ n:Int) -> Int {
    var sum = 0
    for numbers in numbers {
        sum += numbers
        if sum > n {
            break
        }
    }
    return sum
}

/*:
 ## ì„¤ëª…
 - numbersì˜ í•©ì„ ì €ì¥í•  sum ë³€ìˆ˜ ì„ ì–¸
 - forë¬¸ì„ ì´ìš©í•´ì„œ numbersë¥¼ ìˆœì„œëŒ€ë¡œ ë”í•´ì£¼ê³  sumì— í•©ì„ ì €ì¥
 - ifë¬¸ì„ ì‚¬ìš©í•´ì„œ sumì˜ ê°’ì´ në³´ë‹¤ ì»¤ì§€ë©´ ì¤‘ë‹¨
 - sumì„ return
 */


/*:
 ## ğŸ“Œ ì¹´ìš´íŠ¸ ì—…
 MARK: ì¹´ìš´íŠ¸ ì—…
 
 - ì •ìˆ˜ start_numì™€ end_numê°€ ì£¼ì–´ì§ˆ ë•Œ, start_numë¶€í„° end_numê¹Œì§€ì˜ ìˆ«ìë¥¼ ì°¨ë¡€ë¡œ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - start_numì´ 3ì´ê³  end_numì´ 10ì´ë¼ë©´ [3, 4, 5, 6, 7, 8, 9, 10]ì„ ë‹´ì€ ë°°ì—´ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ start_num â‰¤ end_num â‰¤ 50
 */

func solution15(_ start_num:Int, _ end_num:Int) -> [Int] {
    return Array(start_num...end_num)
}

/*:
 ## ì„¤ëª…
 - start_num...end_numìœ¼ë¡œ ì‹œì‘ ìˆ«ìë¶€í„° ë ìˆ«ìê¹Œì§€ì˜ ë‹«íŒ ë²”ìœ„ë¥¼ ìƒì„±
 - Array()ëŠ” ì´ ë²”ìœ„ë¥¼ ë°°ì—´ë¡œ ë°˜í™˜í•˜ë¯€ë¡œ Array(start_num...end_num) ì„ return
 */


/*:
 ## ğŸ“Œ ì¹´ìš´íŠ¸ ë‹¤ìš´
 MARK: ì¹´ìš´íŠ¸ ë‹¤ìš´
 
 - ì •ìˆ˜ start_numì™€ end_numê°€ ì£¼ì–´ì§ˆ ë•Œ, start_numì—ì„œ end_numê¹Œì§€ 1ì”© ê°ì†Œí•˜ëŠ” ìˆ˜ë“¤ì„ ì°¨ë¡€ë¡œ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - start_numì´ 10ì´ê³  end_numì´ 3ì´ë¼ë©´ [10, 9, 8, 7, 6, 5, 4, 3]ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ end_num â‰¤ start_num â‰¤ 50
 */


func solution16(_ start_num:Int, _ end_num:Int) -> [Int] {
    var a: [Int] = []
    
    for i in end_num...start_num {
        a.append(i)
    }
    return a.reversed()
}


/*:
 ## ì„¤ëª…
 - forë¬¸ì„ ì‚¬ìš©í•´ì„œ end_numë¶€í„° start_numê¹Œì§€ ì‹¤í–‰
 - ì‹¤í–‰ëœ ê°’ì„ ì €ì¥í•  ë³€ìˆ˜(a)ë¥¼ ì„ ì–¸ (ë‹¨, ë°°ì—´ë¡œ ê°’ì„ ì €ì¥í•´ì•¼ í•˜ë¯€ë¡œ ë¹ˆ ë°°ì—´ë¡œ ì„ ì–¸)
 - append í•¨ìˆ˜ë¡œ ië¥¼ aë°°ì—´ì— ì €ì¥
 - aë¥¼ ê·¸ëŒ€ë¡œ ë¦¬í„´í•˜ë©´ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ê°’ì´ ë¦¬í„´ë˜ë¯€ë¡œ reversed() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ê°’ì„ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ë³€ê²½í•œ ë’¤ í•´ë‹¹ ê°’ì„ ë¦¬í„´
 */

/*:
 ## ğŸ“Œ në²ˆì§¸ ì›ì†Œë¶€í„°
 MARK: në²ˆì§¸ ì›ì†Œë¶€í„°
 
 - ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸ num_listì™€ ì •ìˆ˜ nì´ ì£¼ì–´ì§ˆ ë•Œ, n ë²ˆì§¸ ì›ì†Œë¶€í„° ë§ˆì§€ë§‰ ì›ì†Œê¹Œì§€ì˜ ëª¨ë“  ì›ì†Œë¥¼ ë‹´ì€ ë¦¬ìŠ¤íŠ¸ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [5, 2, 1, 7, 5] ì´ê³  nì´ 2 ë¼ë©´ 2ë²ˆì§¸ë¶€í„° ë‚˜ë¨¸ì§€ ë°°ì—´ì˜ ê°’ì„ ë¦¬í„´í•´ì•¼ í•˜ë¯€ë¡œ [2, 1, 7, 5]ë¥¼ ë¦¬í„´
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 30
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - 1 â‰¤ n â‰¤ num_listì˜ ê¸¸ì´
 */

func solution17(_ num_list:[Int], _ n:Int) -> [Int] {
    var sliceArray = Array(num_list[(n - 1)...])
    
    return sliceArray
}

/*:
 ## ì„¤ëª…
 - num_list[(n - 1)...]ë¥¼ ì‚¬ìš©í•´ në²ˆì§¸ ì¸ë±ìŠ¤(ë°°ì—´ì€ 0ë¶€í„° ì‹œì‘í•˜ë¯€ë¡œ n-1)ë¶€í„° ëê¹Œì§€ì˜ ë¶€ë¶„ ë°°ì—´ì„ ìƒì„±
 - ìƒì„±ëœ ë¶€ë¶„ ë°°ì—´ì„ Array()ë¡œ ë³€í™˜í•˜ì—¬ ìƒˆë¡œìš´ ë°°ì—´ sliceArrayì— ì €ì¥
 - ìµœì¢…ì ìœ¼ë¡œ sliceArrayë¥¼ ë°˜í™˜í•˜ì—¬ ì›ë³¸ ë°°ì—´ì˜ në²ˆì§¸ ìš”ì†Œë¶€í„° ëê¹Œì§€ì˜ ìš”ì†Œë“¤ì„ í¬í•¨í•˜ëŠ” ìƒˆ ë°°ì—´ì„ return
 */


/*:
 ## ğŸ“Œ ë¬¸ìì—´ ë°”ê¿”ì„œ ì°¾ê¸°
 MARK: ë¬¸ìì—´ ë°”ê¿”ì„œ ì°¾ê¸°
 
 - ë¬¸ì "A"ì™€ "B"ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ myStringê³¼ patê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. myStringì˜ "A"ë¥¼ "B"ë¡œ, "B"ë¥¼ "A"ë¡œ ë°”ê¾¼ ë¬¸ìì—´ì˜ ì—°ì†í•˜ëŠ” ë¶€ë¶„ ë¬¸ìì—´ ì¤‘ patì´ ìˆìœ¼ë©´ 1ì„ ì•„ë‹ˆë©´ 0ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myStringì´ "ABBAA", patì´ "AABB" ë¼ë©´ "ABBAA"ì—ì„œ "A"ì™€ "B"ë¥¼ ì„œë¡œ ë°”ê¾¸ë©´ "BAABB"ê°€ ë˜ëŠ”ë° ì—¬ê¸°ì—ëŠ” ë¶€ë¶„ë¬¸ìì—´ "AABB"ê°€ ìˆê¸° ë•Œë¬¸ì— 1ì„ returní•¨
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 100
 - 1 â‰¤ patì˜ ê¸¸ì´ â‰¤ 10
 - myStringê³¼ patëŠ” ë¬¸ì "A"ì™€ "B"ë¡œë§Œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.
 */


func solution18(_ myString:String, _ pat:String) -> Int {
    let converted = myString.map { char -> Character in
        if char == "A" {
            return "B"
        } else if char == "B" {
            return "A"
        } else {
            return char
        }
    }
    
    let convertedString = String(converted)
    
    if convertedString.contains(pat) {
        return 1
    } else {
        return 0
    }
}


/*:
 ## ì„¤ëª…
 - myStringì˜ ê° ë¬¸ìë¥¼ ìˆœíšŒí•˜ë©´ì„œ AëŠ” Bë¡œ BëŠ” Aë¡œ ë³€í™˜
 - map í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ê° ë¬¸ìë¥¼ ë³€í™˜í•˜ê³  ë³€í™˜ëœ ë¬¸ì ë°°ì—´ì„ Stringìœ¼ë¡œ ë³€í™˜
 - contains ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì„œ ë³€í™˜ëœ ë¬¸ìì—´ì— patì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
 - if elseë¬¸ìœ¼ë¡œ ì¡´ì¬í•œë‹¤ë©´ 1ì„, ì—†ë‹¤ë©´ 0ì„ return
 */


/*:
 ## ğŸ“Œ ê°€ê¹Œìš´ 1 ì°¾ê¸°
 MARK: ê°€ê¹Œìš´ 1 ì°¾ê¸°
 
 - ì •ìˆ˜ ë°°ì—´ arrê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ì´ë•Œ arrì˜ ì›ì†ŒëŠ” 1 ë˜ëŠ” 0ì…ë‹ˆë‹¤. ì •ìˆ˜ idxê°€ ì£¼ì–´ì¡Œì„ ë•Œ, idxë³´ë‹¤ í¬ë©´ì„œ ë°°ì—´ì˜ ê°’ì´ 1ì¸ ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ë¥¼ ì°¾ì•„ì„œ ë°˜í™˜í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”. ë‹¨, ë§Œì•½ ê·¸ëŸ¬í•œ ì¸ë±ìŠ¤ê°€ ì—†ë‹¤ë©´ -1ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - arrì´ [0, 0, 0, 1]ì´ê³  idxê°€ 1ì´ë¼ë©´ 1ë³´ë‹¤ í¬ë©´ì„œ ì›ì†Œê°€ 1ì¸ ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ëŠ” 3ì´ë¯€ë¡œ 3ì„ return
 
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 3 â‰¤ arrì˜ ê¸¸ì´ â‰¤ 100'000
 - arrì˜ ì›ì†ŒëŠ” ì „ë¶€ 1 ë˜ëŠ” 0ì…ë‹ˆë‹¤.
 
 */

func solution19(_ arr:[Int], _ idx:Int) -> Int {
    for i in (idx)..<arr.count {
        if arr[i] == 1 {
            return i
        }
    }
    return -1
}
/*:
 ## ì„¤ëª…
 
 - ì •ìˆ˜ ë°°ì—´ arrê°€ ì£¼ì–´ì§€ê³ , ì›ì†ŒëŠ” 1 ë˜ëŠ” 0ìœ¼ë¡œ êµ¬ì„±ë¨
 - ì •ìˆ˜ idxê°€ ì£¼ì–´ì¡Œì„ ë•Œ, idxë¶€í„° ë°°ì—´ì„ ìˆœíšŒí•˜ë©´ì„œ ê°’ì´ 1ì¸ ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ë¥¼ ì°¾ìŒ
 - for ë°˜ë³µë¬¸ì„ ì‚¬ìš©í•´ idxë¶€í„° ë°°ì—´ì˜ ëê¹Œì§€ ìˆœì°¨ì ìœ¼ë¡œ í™•ì¸
 - ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì²« ë²ˆì§¸ ì¸ë±ìŠ¤ë¥¼ ë°œê²¬í•˜ë©´ ì¦‰ì‹œ í•´ë‹¹ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜
 - ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì¸ë±ìŠ¤ê°€ ì—†ëŠ” ê²½ìš° -1ì„ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ê°„ë‹¨í•œ ì‹ ê³„ì‚°í•˜ê¸°
 MARK: ê°„ë‹¨í•œ ì‹ ê³„ì‚°í•˜ê¸°
 
 - ë¬¸ìì—´ binomialì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. binomialì€ "a op b" í˜•íƒœì˜ ì´í•­ì‹ì´ê³  aì™€ bëŠ” ìŒì´ ì•„ë‹Œ ì •ìˆ˜, opëŠ” '+', '-', '*' ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ì‹ì„ ê³„ì‚°í•œ ì •ìˆ˜ë¥¼ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - binomialì´ "43 + 12" ë¼ë©´ 55ë¥¼ return
 - binomialì´ "0 - 7777" ë¼ë©´ -7777ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ a, b â‰¤ 40,000
 - 0ì„ ì œì™¸í•˜ê³  a, bëŠ” 0ìœ¼ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 */


import Foundation

func solution20(_ binomial:String) -> Int {
    let components = binomial.split(separator: " ")
    
    if components.count == 3,
       let a = Int(components[0]),
       let b = Int(components[2]) {
        let op = String(components[1])
        
        switch op {
        case "+":
            return a + b
        case "-":
            return a - b
        case "*":
            return a * b
        default:
            return 0
        }
    }
    return 0
}

/*:
 ## ì„¤ëª…
 - binomial ë¬¸ìì—´ì„ ê³µë°± ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ìœ„í•´ components ìƒìˆ˜ë¥¼ ì„ ì–¸
 - if letë¬¸ë²•ìœ¼ë¡œ componentsì˜ ê°œìˆ˜ê°€ 3ê°œë¼ë©´ ê°ê°ì˜ ìš”ì†Œë¥¼ a, b, op ë³€ìˆ˜ì— ëŒ€ì…(ì¡°ê±´ì‹ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´ binomialì€ í˜•íƒœê°€ ê³ ì •ë˜ì–´ ìˆìœ¼ë¯€ë¡œ í•­ìƒ ê°œìˆ˜ê°€ 3ì„)
    - ë‹¨, ì´ë•Œ aì™€ bëŠ” Intë¡œ íƒ€ì… ë³€í™˜ì„ ì§„í–‰
 - switch caseë¬¸ìœ¼ë¡œ ê°ê°ì˜ ì—°ì‚°ì— ë§ê²Œ ê³„ì‚°ì„ ì§„í–‰í•˜ê³  í•´ë‹¹ ê°’ì„ return
 */


/*:
 ## ğŸ“Œ ë¬¸ìì—´ ì˜ë¼ì„œ ì •ë ¬í•˜ê¸°
 MARK: ë¬¸ìì—´ ì˜ë¼ì„œ ì •ë ¬í•˜ê¸°
 
 - ë¬¸ìì—´ myStringì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. "x"ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•´ë‹¹ ë¬¸ìì—´ì„ ì˜ë¼ë‚´ ë°°ì—´ì„ ë§Œë“  í›„ ì‚¬ì „ìˆœìœ¼ë¡œ ì •ë ¬í•œ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”. ë‹¨, ë¹ˆ ë¬¸ìì—´ì€ ë°˜í™˜í•  ë°°ì—´ì— ë„£ì§€ ì•ŠìŠµë‹ˆë‹¤.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myStringì´ "axbxcxdx" ì´ë¼ë©´ return ê°’ì€ ["a","b","c","d"]ì´ ë˜ì–´ì•¼ í•¨
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myString â‰¤ 100,000
    - myStringì€ ì•ŒíŒŒë²³ ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.
 */

func solution21(_ myString:String) -> [String] {
    let cutString = myString.components(separatedBy: "x").filter { !$0.isEmpty}
    return cutString.sorted()
}

/*:
 ## ì„¤ëª…
 - myStringì„ xë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë¬¸ìì—´ì„ ì˜ë¼ë‚´ì•¼ í•˜ê¸° ë•Œë¬¸ì— componentsë¥¼ ì‚¬ìš©í•´ì„œ ë¬¸ìì—´ì„ ì˜ë¼ëƒ„
 - ë¬¸ì œì—ì„œ ë¹ˆ ë¬¸ìì—´ì€ ë°˜í™˜í•  ë°°ì—´ì— ë„£ì§€ ì•ŠëŠ”ë‹¤ê³  í–ˆìœ¼ë¯€ë¡œ filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ë¹ˆ ë¬¸ìì—´ì„ ì œì™¸í•˜ê³  ëª¨ë‘ ë½‘ì•„ëƒ„
 - ì¡°ê±´ì— ë§ê²Œ ì˜ë¼ë‚¸ ë°°ì—´ì„ cutString ë³€ìˆ˜ì— ëŒ€ì…í•˜ê³  í•´ë‹¹ ë³€ìˆ˜ë¥¼ sorted()ë¥¼ ì‚¬ìš©í•´ì„œ ì‚¬ì „ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê³  í•´ë‹¹ ê°’ì„ return
 */


/*:
 ## ğŸ“Œ íŠ¹ì •í•œ ë¬¸ìë¥¼ ëŒ€ë¬¸ìë¡œ ë°”ê¾¸ê¸°
 MARK: íŠ¹ì •í•œ ë¬¸ìë¥¼ ëŒ€ë¬¸ìë¡œ ë°”ê¾¸ê¸°
 
 - ì˜ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ my_stringê³¼ ì˜ì†Œë¬¸ì 1ê¸€ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ alpê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_stringì—ì„œ alpì— í•´ë‹¹í•˜ëŠ” ëª¨ë“  ê¸€ìë¥¼ ëŒ€ë¬¸ìë¡œ ë°”ê¾¼ ë¬¸ìì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 -
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 */

func solution22(_ my_string:String, _ alp:String) -> String {
    var upperString = ""
    for ch in my_string {
        if ch == Character(alp) {
            upperString += ch.uppercased()
        } else {
            upperString += String(ch)
        }
    }
    
    return upperString
}

/*:
 ## ì„¤ëª…
 - my_stringì—ì„œ í•œ ê¸€ìì”© ìˆœíšŒí•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— forë¬¸ì„ ì‚¬ìš©í•´ì„œ ë¬¸ìì—´ì˜ ê° ë¬¸ìë¥¼ í™•ì¸
 - ê° ë¬¸ìë¥¼ alpì™€ ë¹„êµí•˜ê¸° ìœ„í•´ Character(alp)ë¡œ íƒ€ì…ì„ ë§ì¶”ê³  ë¹„êµ
 - if elseë¬¸ì„ ì‚¬ìš©í•´ì„œ ë§Œì•½ ë¬¸ìê°€ alpì™€ ê°™ë‹¤ê³  uppercased()ë¥¼ ì‚¬ìš©í•´ì„œ í•´ë‹¹ ë¬¸ìë¥¼ ëŒ€ë¬¸ìë¡œ ë³€í™˜í•œ ë’¤ upperStringì— ë¶™ì„
 - ë‹¤ë¥´ë©´ ì›ë˜ ë¬¸ìë¥¼ ê·¸ëŒ€ë¡œ upperStringì— ë¶™ì„
 - ë§ˆì§€ë§‰ìœ¼ë¡œ upperStringì„ return
 */


/*:
 ## ğŸ“Œ 1ë¡œ ë§Œë“¤ê¸°
 MARK: 1ë¡œ ë§Œë“¤ê¸°
 
 - ì •ìˆ˜ê°€ ìˆì„ ë•Œ, ì§ìˆ˜ë¼ë©´ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê³ , í™€ìˆ˜ë¼ë©´ 1ì„ ëº€ ë’¤ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ë©´, ë§ˆì§€ë§‰ì—” 1ì´ ë©ë‹ˆë‹¤. ì •ìˆ˜ë“¤ì´ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§ˆ ë•Œ, num_listì˜ ëª¨ë“  ì›ì†Œë¥¼ 1ë¡œ ë§Œë“¤ê¸° ìœ„í•´ì„œ í•„ìš”í•œ ë‚˜ëˆ„ê¸° ì—°ì‚°ì˜ íšŸìˆ˜ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - my_stringì´ "programmers", alpê°€ "p"ë¼ë©´ resultëŠ” "Programmers"
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 3 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 15
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 30
 */

func solution23(_ num_list:[Int]) -> Int {
    var totalCount = 0
    
    for num in num_list {
        var n = num
        while n > 1 {
            n /= 2
            totalCount += 1
        }
    }
    return totalCount
}

/*:
 ## ì„¤ëª…
 - ì—°ì‚° íšŸìˆ˜ë¥¼ ì €ì¥í•  ë³€ìˆ˜ totalCountë¥¼ ì„ ì–¸
 - forë¬¸ìœ¼ë¡œ ë¦¬ìŠ¤íŠ¸ ì•ˆì˜ ìˆ«ì í•˜ë‚˜ì”© ë°˜ë³µ
 - í˜„ì¬ ìˆ«ìë¥¼ ì„ì‹œ ë³€ìˆ˜ë¡œ ì €ì¥ (Swiftì—ì„œ forë£¨í”„ ë³€ìˆ˜(ì—¬ê¸°ì—ì„œëŠ” num)ëŠ” letì´ê¸° ë•Œë¬¸
 - 1ì„ ë§Œë“œëŠ” ê²Œ ëª©ì ì´ë¯€ë¡œ whileë¬¸ìœ¼ë¡œ nì´ 1ë³´ë‹¤ í´ ë™ì•ˆ ê³„ì† ë°˜ë³µ
 - nì„ 2ë¡œ ë‚˜ëˆ”(í™€ìˆ˜ì¸ ê²½ìš°ëŠ” ìì—°ìŠ¤ëŸ½ê²Œ n - 1ì´ ëœ í›„ ë‚˜ëˆ„ëŠ” ê²ƒê³¼ ê°™ê¸° ë•Œë¬¸ì— ë³„ë„ ì²˜ë¦¬ x)
 - ì—°ì‚°ì´ ì§„í–‰ ëìœ¼ë¯€ë¡œ totalCountì— 1ì„ ì¦ê°€
 - totalCountë¥¼ return
 */


/*:
 ## ğŸ“Œ ê¸¸ì´ì— ë”°ë¥¸ ì—°ì‚°
 MARK: ê¸¸ì´ì— ë”°ë¥¸ ì—°ì‚°
 
 - ì •ìˆ˜ê°€ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§ˆ ë•Œ, ë¦¬ìŠ¤íŠ¸ì˜ ê¸¸ì´ê°€ 11 ì´ìƒì´ë©´ ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ëª¨ë“  ì›ì†Œì˜ í•©ì„ 10 ì´í•˜ì´ë©´ ëª¨ë“  ì›ì†Œì˜ ê³±ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [2,3,4,5]ë¼ë©´ 120ì„ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 20
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9
 - num_listì˜ ì›ì†Œë¥¼ ëª¨ë‘ ê³±í–ˆì„ ë•Œ 2,147,483,647ë¥¼ ë„˜ëŠ” ì…ë ¥ì€ ì£¼ì–´ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.

 */

func solution24(_ num_list:[Int]) -> Int {
    let count = num_list.count
    var sum = 0
    var product = 0
    
    if count >= 11 {
        sum = num_list.reduce(0, +)
        return sum
    } else {
        product = num_list.reduce(1, *)
        return product
    }
}

/*:
 ## ì„¤ëª…
 - num_listì˜ ê¸¸ì´ë¥¼ ë‹´ì„ ë³€ìˆ˜ì™€ num_listì˜ í•©, ê³±ì„ ë‹´ì„ ë³€ìˆ˜ë¥¼ ê°ê° ì„ ì–¸
 - ifë¬¸ìœ¼ë¡œ num_listì˜ ê¸¸ì´ê°€ 11 ì´ìƒì´ë¼ë©´ reduce í•¨ìˆ˜ë¡œ 0ë¶€í„° ì­‰ ëª¨ì•„ì„œ ë”í•´ì£¼ê³  sumì„ return
 - ê·¸ ì™¸ì˜ ì¡°ê±´ì€ reduce í•¨ìˆ˜ë¡œ 1ë¶€í„° ëª¨ì•„ì„œ ê³±í•´ì£¼ê³  í•´ë‹¹ ê°’ì„ returní•¨
    - 0ë¶€í„° ëª¨ìœ¼ì§€ ì•Šì€ ì´ìœ ëŠ” 0ì„ í¬í•¨í•˜ëŠ” ìˆœê°„ 0ë„ ê°™ì´ ê³±í•´ì§€ê¸° ë•Œë¬¸ì— ê²°ê³¼ ê°’ì´ í•­ìƒ 0ì´ ë‚˜ì˜´
 */



/*:
 ## ğŸ“Œ ëŒ€ë¬¸ìë¡œ ë°”ê¾¸ê¸°
 MARK: ëŒ€ë¬¸ìë¡œ ë°”ê¾¸ê¸°
 
 - ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ myStringì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. ëª¨ë“  ì•ŒíŒŒë²³ì„ ëŒ€ë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myString ì´ "aBcDeFg"ë¼ë©´ "ABCDEFG"ë¥¼ ë¦¬í„´
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 100,000
    - myStringì€ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.


 */

func solution25(_ myString:String) -> String {
    let Change = myString.uppercased()
    
    return Change
}

/*:
 ## ì„¤ëª…
 - uppercased() í•¨ìˆ˜ëŠ” ì†Œë¬¸ìë¥¼ ëŒ€ë¬¸ìë¡œ ë³€ê²½í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë¯€ë¡œ í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì´ìš©
 - myStringì— uppercased()ë¥¼ ì ìš©í•´ì£¼ê³  ì ìš©ëœ ê°’ì„ Change ë³€ìˆ˜ì— ë‹´ì€ í›„ í•´ë‹¹ ë³€ìˆ˜ë¥¼ return
 */


/*:
 ## ğŸ“Œ ì†Œë¬¸ìë¡œ ë°”ê¾¸ê¸°
 MARK: ì†Œë¬¸ìë¡œ ë°”ê¾¸ê¸°
 
 - ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ myStringì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. ëª¨ë“  ì•ŒíŒŒë²³ì„ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myString ì´ "aBcDeFg"ë¼ë©´ "abcdefg"ë¥¼ ë¦¬í„´
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 100,000
    - myStringì€ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.
 */

func solution26(_ myString:String) -> String {
    let change = myString.lowercased()
    
    return change
}

/*:
 ## ì„¤ëª…
 - lowercased() í•¨ìˆ˜ëŠ” ëŒ€ë¬¸ìë¥¼ ì†Œë¬¸ìë¡œ ë³€ê²½í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë¯€ë¡œ í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì´ìš©
 - myStringì— lowercased()ë¥¼ ì ìš©í•´ì£¼ê³  ì ìš©ëœ ê°’ì„ change ë³€ìˆ˜ì— ë‹´ì€ í›„ í•´ë‹¹ ë³€ìˆ˜ë¥¼ return
 */



/*:
 ## ğŸ“Œ ì›í•˜ëŠ” ë¬¸ìì—´ ì°¾ê¸°
 MARK: ì›í•˜ëŠ” ë¬¸ìì—´ ì°¾ê¸°
 
 - ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ myStringê³¼ patì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. myStringì˜ ì—°ì†ëœ ë¶€ë¶„ ë¬¸ìì—´ ì¤‘ patì´ ì¡´ì¬í•˜ë©´ 1ì„ ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ 0ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”. ë‹¨, ì•ŒíŒŒë²³ ëŒ€ë¬¸ìì™€ ì†Œë¬¸ìëŠ” êµ¬ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myString ì´ "AbCdEfG" ì´ê³  patì´ "aBc"ë¼ë©´ 1ì„ return
 - myString ì´ "aaAA" ì´ê³  patì´ "aaaaa"ë¼ë©´ 0ì„ ë¦¬í„´
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 100,000
 - 1 â‰¤ patì˜ ê¸¸ì´ â‰¤ 300
 - myStringê³¼ patì€ ëª¨ë‘ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.

 */

func solution27(_ myString:String, _ pat:String) -> Int {
    let lowercaseString = myString.lowercased()
    let lowercasePat = pat.lowercased()
    
    return lowercaseString.contains(lowercasePat) ? 1 : 0
}

/*:
 ## ì„¤ëª…
 - lowercased() í•¨ìˆ˜ëŠ” ëŒ€ë¬¸ìë¥¼ ì†Œë¬¸ìë¡œ ë³€ê²½í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë¯€ë¡œ í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì´ìš©
 - ë‘ ë¬¸ìì—´ì„ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ì—¬ ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´ ë¹„êµ
 - contains ë©”ì„œë“œë¡œ ë¬¸ìì—´ í¬í•¨ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ì—¬ ê²°ê³¼ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ A ê°•ì¡°í•˜ê¸°
 MARK: A ê°•ì¡°í•˜ê¸°
 
 - ë¬¸ìì—´ myStringì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. myStringì—ì„œ ì•ŒíŒŒë²³ "a"ê°€ ë“±ì¥í•˜ë©´ ì „ë¶€ "A"ë¡œ ë³€í™˜í•˜ê³ , "A"ê°€ ì•„ë‹Œ ëª¨ë“  ëŒ€ë¬¸ì ì•ŒíŒŒë²³ì€ ì†Œë¬¸ì ì•ŒíŒŒë²³ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myStringì´ "abstract algebra" ë¼ë©´ "AbstrAct AlgebrA"ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStringì˜ ê¸¸ì´ â‰¤ 20
     - myStringì€ ì•ŒíŒŒë²³ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.

 */

func solution28(_ myString:String) -> String {
    let lowercase = myString.lowercased()
    let result = lowercase.map { $0 == "a" ? "A" : String($0)} .joined()
    
    return result
    
    
    // ë” íš¨ìœ¨ì ì¸ ë‹¤ë¥¸ í’€ì´
    func anotherSolution28(_ myString:String) -> String {
        return myString.lowercased().replacingOccurrences(of: "a", with: "A")
    }
}

/*:
 ## ì„¤ëª…
 - lowercased() í•¨ìˆ˜ë¡œ ì „ì²´ ë¬¸ìì—´ì„ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ê³  lowercase ë³€ìˆ˜ì— ì €ì¥
 - lowercaseì— ìˆëŠ” ë¬¸ìì—´ ì¤‘ì—ì„œ mapí•¨ìˆ˜ë¡œ ì†Œë¬¸ì aê°€ ìˆë‹¤ë©´ ëŒ€ë¬¸ì Aë¡œ ë³€í™˜í•˜ê³  joined() í•¨ìˆ˜ë¡œ ë‹¤ì‹œ lowercaseì— ë„£ìŒ
 - í•´ë‹¹ ê²°ê³¼ë¥¼ return
 */



/*:
 ## ğŸ“Œ ad ì œê±°í•˜ê¸°
 MARK: ad ì œê±°í•˜ê¸°
 
 - ë¬¸ìì—´ ë°°ì—´ strArrê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ë°°ì—´ ë‚´ì˜ ë¬¸ìì—´ ì¤‘ "ad"ë¼ëŠ” ë¶€ë¶„ ë¬¸ìì—´ì„ í¬í•¨í•˜ê³  ìˆëŠ” ëª¨ë“  ë¬¸ìì—´ì„ ì œê±°í•˜ê³  ë‚¨ì€ ë¬¸ìì—´ì„ ìˆœì„œë¥¼ ìœ ì§€í•˜ì—¬ ë°°ì—´ë¡œ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - strArrê°€ ["and","notad","abcd"]ì´ë¼ë©´ ["and", "abcd"]ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ strArrì˜ ê¸¸ì´ â‰¤ 1,000
    - 1 â‰¤ strArrì˜ ì›ì†Œì˜ ê¸¸ì´ â‰¤ 20
    - strArrì˜ ì›ì†ŒëŠ” ì•ŒíŒŒë²³ ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ì…ë‹ˆë‹¤.

 */

func solution29(_ strArr:[String]) -> [String] {
    let result = strArr.filter{ !$0.contains("ad") }
    
    return result
}
/*:
 ## ì„¤ëª…
 - filterë¡œ ë°°ì—´ì—ì„œ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìš”ì†Œë§Œ ë‚¨ê¹€
 - contains("ad")ëŠ” ë¬¸ìì—´ ì•ˆì— "ad"ë¼ëŠ” ë¶€ë¶„ ë¬¸ìì—´ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ë¥¼ ê²€ì‚¬
 - !$0.contains("ad")ëŠ” "ad"ê°€ ì—†ëŠ” ë¬¸ìì—´ë§Œ ë‚¨ê²Œ ë¨
 */


/*:
 ## ğŸ“Œ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê¸° 1
 MARK: ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê¸° 1
 
 - ë‹¨ì–´ê°€ ê³µë°± í•œ ê°œë¡œ êµ¬ë¶„ë˜ì–´ ìˆëŠ” ë¬¸ìì—´ my_stringì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_stringì— ë‚˜ì˜¨ ë‹¨ì–´ë¥¼ ì•ì—ì„œë¶€í„° ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - my_stringì´ "i love you" ë¼ë©´ ["i", "love", "you"]ì„ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - my_stringì€ ì˜ì†Œë¬¸ìì™€ ê³µë°±ìœ¼ë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
 - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
 - my_stringì˜ ë§¨ ì•ê³¼ ë§¨ ë’¤ì— ê¸€ìëŠ” ê³µë°±ì´ ì•„ë‹™ë‹ˆë‹¤.

 */

func solution30(_ my_string:String) -> [String] {
    let words = my_string.split(separator: " ").map { String($0)}
    return words
}

/*:
 ## ì„¤ëª…
 - split()ì„ ì‚¬ìš©í•´ì„œ ê³µë°±ì„ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ”
 - String ë°°ì—´ë¡œ ë°˜í™˜ì„ í•´ì•¼ í•˜ë¯€ë¡œ map í•¨ìˆ˜ë¥¼ ì‚¬ìš©
 - í•´ë‹¹ ê°’ì„ ì €ì¥í•œ words ë³€ìˆ˜ë¥¼ return
 */


/*:
 ## ğŸ“Œ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê¸° 2
 MARK: ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•˜ê¸° 2
 
 - ë‹¨ì–´ê°€ ê³µë°± í•œ ê°œ ì´ìƒìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ìˆëŠ” ë¬¸ìì—´ my_stringì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, my_stringì— ë‚˜ì˜¨ ë‹¨ì–´ë¥¼ ì•ì—ì„œë¶€í„° ìˆœì„œëŒ€ë¡œ ë‹´ì€ ë¬¸ìì—´ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - my_stringì´ " i    love  you" ë¼ë©´ ["i", "love", "you"]ì„ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
  - my_stringì€ ì˜ì†Œë¬¸ìì™€ ê³µë°±ìœ¼ë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
  - 1 â‰¤ my_stringì˜ ê¸¸ì´ â‰¤ 1,000
  - my_stringì˜ ë§¨ ì•ê³¼ ë§¨ ë’¤ì—ë„ ê³µë°±ì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  - my_stringì—ëŠ” ë‹¨ì–´ê°€ í•˜ë‚˜ ì´ìƒ ì¡´ì¬í•©ë‹ˆë‹¤.

 */

func solution31(_ my_string:String) -> [String] {
    let words = my_string.split(separator: " ").map { String($0)}
    return words
}

/*:
 ## ì„¤ëª…
 - Swiftì˜ splitì€ ê³µë°± ì—¬ëŸ¬ ê°œê°€ ë¶™ì–´ ìˆì–´ë„ ê°ê° ë¶„ë¦¬ë˜ê¸° ë•Œë¬¸ì— ìœ„ ë¬¸ì œì™€ ë™ì¼í•˜ê²Œ splitì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
 */



/*:
 ## ğŸ“Œ ì£¼ì‚¬ìœ„ ê²Œì„ 1
 MARK: ì£¼ì‚¬ìœ„ ê²Œì„ 1
 
 - 1ë¶€í„° 6ê¹Œì§€ ìˆ«ìê°€ ì íŒ ì£¼ì‚¬ìœ„ê°€ ë‘ ê°œ ìˆìŠµë‹ˆë‹¤. ë‘ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¸ì„ ë•Œ ë‚˜ì˜¨ ìˆ«ìë¥¼ ê°ê° a, bë¼ê³  í–ˆì„ ë•Œ ì–»ëŠ” ì ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
    - aì™€ bê°€ ëª¨ë‘ í™€ìˆ˜ë¼ë©´ a2 + b2 ì ì„ ì–»ìŠµë‹ˆë‹¤.
    - aì™€ b ì¤‘ í•˜ë‚˜ë§Œ í™€ìˆ˜ë¼ë©´ 2 Ã— (a + b) ì ì„ ì–»ìŠµë‹ˆë‹¤.
    - aì™€ b ëª¨ë‘ í™€ìˆ˜ê°€ ì•„ë‹ˆë¼ë©´ |a - b| ì ì„ ì–»ìŠµë‹ˆë‹¤.
 - ë‘ ì •ìˆ˜ aì™€ bê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ì–»ëŠ” ì ìˆ˜ë¥¼ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - aê°€ 3 bê°€ 5ë¼ë©´ 34ë¥¼ return
 - aê°€ 6 bê°€ 1ë¼ë©´ 14ë¥¼ return
 - aê°€ 2 bê°€ 4ë¼ë©´ 2ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
  - aì™€ bëŠ” 1 ì´ìƒ 6 ì´í•˜ì˜ ì •ìˆ˜ì…ë‹ˆë‹¤.

 */

func solution32(_ a:Int, _ b:Int) -> Int {
    if (a % 2 == 1 && b % 2 == 1) {
        return (a * a) + (b * b)
    } else if (a % 2 == 1 && b % 2 == 0) || (a % 2 == 0 && b % 2 == 1) {
        return 2 * (a + b)
    } else {
        return abs(a - b)
    }
}

/*:
 ## ì„¤ëª…
 - if else ë¬¸ì„ ì‚¬ìš©í•´ ì„¸ ê°€ì§€ ì¼€ì´ìŠ¤ë¡œ ë¶„ê¸° ì²˜ë¦¬
 - ì²« ë²ˆì§¸ ì¡°ê±´ì€ aì™€ bê°€ ëª¨ë‘ í™€ìˆ˜ì¼ ë•Œ í•´ë‹¹ -> && (AND ì—°ì‚°ì)ë¥¼ ì‚¬ìš©í•´ ë‘ ì¡°ê±´ì´ ëª¨ë‘ ì°¸ì¼ ë•Œë§Œ ì‹¤í–‰
 - ë‘ ë²ˆì§¸ ì¡°ê±´ì€ aì™€ b ì¤‘ í•˜ë‚˜ë§Œ í™€ìˆ˜ì¼ ë•Œ í•´ë‹¹ â†’ || (OR ì—°ì‚°ì)ë¥¼ ì‚¬ìš©í•´ ë‘˜ ì¤‘ í•˜ë‚˜ë§Œ ì°¸ì´ë©´ ì‹¤í–‰ë¨
    - (a % 2 == 1 && b % 2 == 0) ë˜ëŠ” (a % 2 == 0 && b % 2 == 1) ì¤‘ í•˜ë‚˜ë¼ë„ ì°¸ì´ë©´ í•´ë‹¹
 - ì„¸ ë²ˆì§¸ ì¡°ê±´ì€ aì™€ bê°€ ëª¨ë‘ ì§ìˆ˜ì¼ ë•Œ í•´ë‹¹ë˜ë©°, ìœ„ ì¡°ê±´ì— í•´ë‹¹í•˜ì§€ ì•ŠëŠ” ë‚˜ë¨¸ì§€ ê²½ìš°ë¥¼ ì²˜ë¦¬
 - ì´ë•Œ abs(a - b)ëŠ” aì™€ bì˜ ì°¨ì´ë¥¼ ì ˆëŒ“ê°’ìœ¼ë¡œ ë°˜í™˜í•¨ (ìŒìˆ˜ ë°©ì§€)
 */


/*:
 ## ğŸ“Œ ìˆ«ì ì§ê¿
 MARK: ìˆ«ì ì§ê¿
 
 - ë‘ ì •ìˆ˜ X, Yì˜ ì„ì˜ì˜ ìë¦¬ì—ì„œ ê³µí†µìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ì •ìˆ˜ k(0 â‰¤ k â‰¤ 9)ë“¤ì„ ì´ìš©í•˜ì—¬ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ì •ìˆ˜ë¥¼ ë‘ ìˆ˜ì˜ ì§ê¿ì´ë¼ í•©ë‹ˆë‹¤(ë‹¨, ê³µí†µìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ì •ìˆ˜ ì¤‘ ì„œë¡œ ì§ì§€ì„ ìˆ˜ ìˆëŠ” ìˆ«ìë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤). X, Yì˜ ì§ê¿ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´, ì§ê¿ì€ -1ì…ë‹ˆë‹¤. X, Yì˜ ì§ê¿ì´ 0ìœ¼ë¡œë§Œ êµ¬ì„±ë˜ì–´ ìˆë‹¤ë©´, ì§ê¿ì€ 0ì…ë‹ˆë‹¤.
 
 - ì˜ˆë¥¼ ë“¤ì–´, X = 3403ì´ê³  Y = 13203ì´ë¼ë©´, Xì™€ Yì˜ ì§ê¿ì€ Xì™€ Yì—ì„œ ê³µí†µìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” 3, 0, 3ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ì •ìˆ˜ì¸ 330ì…ë‹ˆë‹¤. ë‹¤ë¥¸ ì˜ˆì‹œë¡œ X = 5525ì´ê³  Y = 1255ì´ë©´ Xì™€ Yì˜ ì§ê¿ì€ Xì™€ Yì—ì„œ ê³µí†µìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” 2, 5, 5ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ì •ìˆ˜ì¸ 552ì…ë‹ˆë‹¤(Xì—ëŠ” 5ê°€ 3ê°œ, Yì—ëŠ” 5ê°€ 2ê°œ ë‚˜íƒ€ë‚˜ë¯€ë¡œ ë‚¨ëŠ” 5 í•œ ê°œëŠ” ì§ ì§€ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.) ë‘ ì •ìˆ˜ X, Yê°€ ì£¼ì–´ì¡Œì„ ë•Œ, X, Yì˜ ì§ê¿ì„ returní•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - XëŠ” "100", YëŠ” "2345"ë©´ -1ì„ return
 - XëŠ” "100", YëŠ” "203045"ë©´ 0ì„ return
 - XëŠ” "100", YëŠ” "123450"ë©´ 10ì„ return
 
 - aê°€ 6 bê°€ 1ë¼ë©´ 14ë¥¼ return
 - aê°€ 2 bê°€ 4ë¼ë©´ 2ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 3 â‰¤ X, Yì˜ ê¸¸ì´(ìë¦¿ìˆ˜) â‰¤ 3,000,000ì…ë‹ˆë‹¤.
 - X, YëŠ” 0ìœ¼ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - X, Yì˜ ì§ê¿ì€ ìƒë‹¹íˆ í° ì •ìˆ˜ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë¬¸ìì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

 */

func solution33(_ X:String, _ Y:String) -> String {
    var countX = Array(repeating: 0, count: 10)
    var countY = Array(repeating: 0, count: 10)
    
    for ch in X {
        if let digit = ch.wholeNumberValue {
            countX[digit] += 1
        }
    }
    for ch in Y {
        if let digit = ch.wholeNumberValue {
            countY[digit] += 1
        }
    }
    var result = ""
    
    for i in stride(from: 9, through: 0, by: -1) {
        let commonCount = min(countX[i], countY[i])
        if commonCount > 0 {
            result += String(repeating: "\(i)", count: commonCount)
        }
    }
    
    if result.isEmpty {
        return "-1"
    } else if result.first == "0" {
        return "0"
    } else {
        return result
    }
}

/*:
 ## ì„¤ëª…
 - ë‘ ë¬¸ìì—´ Xì™€ Yì—ì„œ ê° ìˆ«ì(0~9)ì˜ ë“±ì¥ íšŸìˆ˜ë¥¼ ë°°ì—´(countX, countY)ì— ì €ì¥
 - ê° ìˆ«ìë§ˆë‹¤ ë“±ì¥ íšŸìˆ˜ë¥¼ ê¸°ë¡í•˜ë©´, ìˆ«ìë³„ë¡œ ì–¼ë§ˆë‚˜ ê²¹ì¹˜ëŠ”ì§€ ë¹ ë¥´ê²Œ ì•Œ ìˆ˜ ìˆìŒ
 - ì´í›„ 9ë¶€í„° 0ê¹Œì§€ ìˆ«ìë¥¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ íƒìƒ‰
    - ê°€ì¥ í° ìˆ˜ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ë†’ì€ ìˆ«ìë¶€í„° ê²°ê³¼ ë¬¸ìì—´ì— ì¶”ê°€
 - ê° ìˆ«ì iì— ëŒ€í•´ Xì™€ Y ëª¨ë‘ì—ì„œ ë‚˜íƒ€ë‚˜ëŠ” ê°œìˆ˜ì˜ ìµœì†Ÿê°’(min)ì„ ê³„ì‚°í•˜ì—¬ ì§ ì§€ì„ ìˆ˜ ìˆëŠ” ê°œìˆ˜ë¥¼ êµ¬í•¨
    - ì˜ˆ: Xì— 5ê°€ 3ë²ˆ, Yì— 5ê°€ 2ë²ˆ â†’ ì§ ì§€ì„ ìˆ˜ ìˆëŠ” 5ëŠ” 2ê°œ
    - ì´ë•Œ String(repeating: "\(i)", count: ê°œìˆ˜)ë¥¼ ì‚¬ìš©í•´ í•´ë‹¹ ìˆ«ìë¥¼ ì—¬ëŸ¬ ë²ˆ ë¶™ì„
 - ìµœì¢…ì ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ ë¬¸ìì—´ resultê°€ ë‹¤ìŒ ì¡°ê±´ ì¤‘ í•˜ë‚˜ì— í•´ë‹¹í•  ê²½ìš° ì˜ˆì™¸ ì²˜ë¦¬
    - ì•„ë¬´ ìˆ«ìë„ ì§ì§€ì–´ì§€ì§€ ì•Šì€ ê²½ìš° â†’ resultëŠ” ë¹ˆ ë¬¸ìì—´("") â†’ "-1" ë°˜í™˜
    - ê²°ê³¼ê°€ "000..."ì²˜ëŸ¼ 0ìœ¼ë¡œë§Œ êµ¬ì„±ëœ ê²½ìš° â†’ "0" ë°˜í™˜
 - ìœ„ ë‘ ê²½ìš° ì™¸ì—ëŠ” result ë¬¸ìì—´ì„ ê·¸ëŒ€ë¡œ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ì›ì†Œë“¤ì˜ ê³±ê³¼ í•©
 MARK: ì›ì†Œë“¤ì˜ ê³±ê³¼ í•©
 
 - ì •ìˆ˜ê°€ ë‹´ê¸´ ë¦¬ìŠ¤íŠ¸ num_listê°€ ì£¼ì–´ì§ˆ ë•Œ, ëª¨ë“  ì›ì†Œë“¤ì˜ ê³±ì´ ëª¨ë“  ì›ì†Œë“¤ì˜ í•©ì˜ ì œê³±ë³´ë‹¤ ì‘ìœ¼ë©´ 1ì„ í¬ë©´ 0ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
  
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [3, 4, 5, 2, 1]ì´ë¼ë©´ 1ì„ return
 - num_listê°€ [5, 7, 8, 3]ì´ë¼ë©´ 0ì„ return
 
 - aê°€ 6 bê°€ 1ë¼ë©´ 14ë¥¼ return
 - aê°€ 2 bê°€ 4ë¼ë©´ 2ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ num_listì˜ ê¸¸ì´ â‰¤ 10
 - 1 â‰¤ num_listì˜ ì›ì†Œ â‰¤ 9

 */

func solution34(_ num_list: [Int]) -> Int {
    let product = num_list.reduce(1, *)
    let sum = num_list.reduce(0, +)
    
    return product < sum * sum ? 1 : 0
}

/*:
 ## ì„¤ëª…
 - ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ëª¨ë“  ì›ì†Œë“¤ì˜ ê³±(product)ì„ reduce(1, *)ë¡œ ê³„ì‚°
   - ê³±ì…ˆì˜ í•­ë“±ì› 1ì„ ì´ˆê¸°ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ì›ì†Œë¥¼ ê³±í•¨

 - ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ëª¨ë“  ì›ì†Œë“¤ì˜ í•©(sum)ì„ reduce(0, +)ë¡œ ê³„ì‚°
   - ë§ì…ˆì˜ í•­ë“±ì› 0ì„ ì´ˆê¸°ê°’ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ì›ì†Œë¥¼ ë”í•¨

 - ì¡°ê±´ ë¹„êµ:
   - product < sum * sum ì¸ì§€ ê²€ì‚¬
   - ì¦‰, ì›ì†Œì˜ ê³±ì´ ì›ì†Œì˜ í•©ì˜ ì œê³±ë³´ë‹¤ ì‘ìœ¼ë©´ 1 ë°˜í™˜ (ì‚¼í•­ ì—°ì‚°ìë¥¼ ì‚¬ìš©)
   - ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ 0 ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ìˆ«ì ë¬¸ìì—´ê³¼ ì˜ë‹¨ì–´
 MARK: ìˆ«ì ë¬¸ìì—´ê³¼ ì˜ë‹¨ì–´
 
 - ë„¤ì˜¤ì™€ í”„ë¡œë„ê°€ ìˆ«ìë†€ì´ë¥¼ í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë„¤ì˜¤ê°€ í”„ë¡œë„ì—ê²Œ ìˆ«ìë¥¼ ê±´ë„¬ ë•Œ ì¼ë¶€ ìë¦¿ìˆ˜ë¥¼ ì˜ë‹¨ì–´ë¡œ ë°”ê¾¼ ì¹´ë“œë¥¼ ê±´ë„¤ì£¼ë©´ í”„ë¡œë„ëŠ” ì›ë˜ ìˆ«ìë¥¼ ì°¾ëŠ” ê²Œì„ì…ë‹ˆë‹¤.

 - ë‹¤ìŒì€ ìˆ«ìì˜ ì¼ë¶€ ìë¦¿ìˆ˜ë¥¼ ì˜ë‹¨ì–´ë¡œ ë°”ê¾¸ëŠ” ì˜ˆì‹œì…ë‹ˆë‹¤.

 - 1478 â†’ "one4seveneight"
 - 234567 â†’ "23four5six7"
 - 10203 â†’ "1zerotwozero3"
 - ì´ë ‡ê²Œ ìˆ«ìì˜ ì¼ë¶€ ìë¦¿ìˆ˜ê°€ ì˜ë‹¨ì–´ë¡œ ë°”ë€Œì–´ì¡Œê±°ë‚˜, í˜¹ì€ ë°”ë€Œì§€ ì•Šê³  ê·¸ëŒ€ë¡œì¸ ë¬¸ìì—´ sê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. sê°€ ì˜ë¯¸í•˜ëŠ” ì›ë˜ ìˆ«ìë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
  
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - num_listê°€ [3, 4, 5, 2, 1]ì´ë¼ë©´ 1ì„ return
 - num_listê°€ [5, 7, 8, 3]ì´ë¼ë©´ 0ì„ return
 
 - aê°€ 6 bê°€ 1ë¼ë©´ 14ë¥¼ return
 - aê°€ 2 bê°€ 4ë¼ë©´ 2ë¥¼ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ sì˜ ê¸¸ì´ â‰¤ 50
 - sê°€ "zero" ë˜ëŠ” "0"ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ê²½ìš°ëŠ” ì£¼ì–´ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.
 - return ê°’ì´ 1 ì´ìƒ 2,000,000,000 ì´í•˜ì˜ ì •ìˆ˜ê°€ ë˜ëŠ” ì˜¬ë°”ë¥¸ ì…ë ¥ë§Œ së¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤.

 */

func solution35(_ s:String) -> Int {
    let numberWords: [String: String] = [
        "zero" : "0", "one" : "1", "two" : "2", "three" : "3", "four" : "4",
        "five" : "5", "six" : "6", "seven" : "7", "eight" : "8", "nine" : "9"
    ]
    
    var result = s
    
    for (word, digit) in numberWords {
        result = result.replacingOccurrences(of: word, with: digit)
    }
    return Int(result)!
}

/*:
 ## ì„¤ëª…
 - ë¨¼ì € numberWords ë”•ì…”ë„ˆë¦¬ ì„ ì–¸í•´ì„œ "ì˜ë‹¨ì–´" -> "ìˆ«ì" í˜•íƒœë¡œ ë³€í™˜ ê·œì¹™ì„ ì €ì¥
 - result ë³€ìˆ˜ì— s ë§¤ê°œë³€ìˆ˜ë¥¼ ë³µì‚¬í•´ì„œ ì‚¬ìš©(sëŠ” í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ì´ê¸° ë•Œë¬¸ì— ìƒìˆ˜ë¡œ ê°„ì£¼ë˜ë¯€ë¡œ ìˆ˜ì • ê°€ëŠ¥í•œ resultë¥¼ ì„ ì–¸)
 - for ë£¨í”„ë¥¼ í†µí•´ì„œ "zero"ë¶€í„° "nine"ê¹Œì§€ ì°¨ë¡€ë¡œ ë³€í™˜
 - replacingOccurrences(of: with:) í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ wordë¥¼ digitìœ¼ë¡œ ë°”ê¿ˆ
 - ë³€í™˜ì´ ëë‚˜ë©´ resultë¥¼ Intë¡œ í˜•ë³€í™˜ì„ í•˜ê³  ê°•ì œ ì–¸ë˜í•‘ì„ í•œ í›„ return
    - ê°•ì œ ì–¸ë˜í•‘ì„ í•˜ëŠ” ì´ìœ ëŠ” Int(...)ëŠ” í•­ìƒ ì˜µì…”ë„ íƒ€ì…ìœ¼ë¡œ ë°˜í™˜í•˜ê³  ì´ ë¬¸ì œì—ì„œëŠ” nilì´ ì—†ê¸° ë•Œë¬¸ì— ê°•ì œ ì–¸ë˜í•‘ì„ ì‚¬ìš©í•¨
    - ë§Œì•½ ë¬¸ì œì—ì„œ nilë„ í¬í•¨ì´ ëœë‹¤ë©´ if let or guard letì„ ì‚¬ìš©í•´ì„œ ì˜µì…”ë„ ë°”ì¸ë”©ì„ í•´ì•¼ í•¨
 */


/*:
 ## ğŸ“Œ 0 ë–¼ê¸°
 MARK: 0 ë–¼ê¸°
 
 - ì •ìˆ˜ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ n_strì´ ì£¼ì–´ì§ˆ ë•Œ, n_strì˜ ê°€ì¥ ì™¼ìª½ì— ì²˜ìŒìœ¼ë¡œ ë“±ì¥í•˜ëŠ” 0ë“¤ì„ ë—€ ë¬¸ìì—´ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - n_strì´ "0010"ì´ë¼ë©´ "10"ì„ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ n_str â‰¤ 10
 - n_strì´ "0"ìœ¼ë¡œë§Œ ì´ë£¨ì–´ì§„ ê²½ìš°ëŠ” ì—†ìŠµë‹ˆë‹¤.
 */

func solution36(_ n_str:String) -> String {
    let result = n_str.drop(while: { $0 == "0"})
    return String(result)
}

/*:
 ## ì„¤ëª…
 - drop(while:)ì„ ì‚¬ìš©í•´ì„œ ë¬¸ì í•˜ë‚˜í•˜ë‚˜ë¥¼ ë°›ì•„ì„œ "0"ì¼ ë•Œë§Œ 0ì„ ì œê±°í•˜ë„ë¡ ì¡°ê±´ì„ ì„¤ì •
 - (0ì´ ì—°ì†ìœ¼ë¡œ 2ë²ˆ ë‚˜ì˜¤ë©´, ì²« ë²ˆì§¸ 0ì—ì„œ í•´ë‹¹ ì¡°ê±´ì´ ì„±ê³µ í–ˆìœ¼ë¯€ë¡œ ë‘ ë²ˆì§¸ 0ì—ì„œë„ í•´ë‹¹ ë™ì‘ ìˆ˜í–‰)
 - 0ì´ ì•ˆ ë‚˜ì˜¤ëŠ” ìˆœê°„ë¶€í„°ëŠ” ë‚¨ì€ ë¬¸ìë“¤ì„ ìœ ì§€
 - í•´ë‹¹ ê²°ê³¼ëŠ” Substring íƒ€ì…ì´ë¯€ë¡œ resultë¥¼ String()ìœ¼ë¡œ ê°ì‹¸ì„œ return
 */


/*:
 ## ğŸ“Œ ë¬¸ìì—´ë¡œ ë³€í™˜
 MARK: ë¬¸ìì—´ë¡œ ë³€í™˜
 
 - ì •ìˆ˜ nì´ ì£¼ì–´ì§ˆ ë•Œ, nì„ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - n_strì´ "0010"ì´ë¼ë©´ "10"ì„ return
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ n â‰¤ 10000
 */

func solution37(_ n:Int) -> String {
    var stringNumber = String(n)
    return stringNumber
}

/*:
 ## ì„¤ëª…
 - ë¬¸ìì—´ë¡œ ë³€í™˜í•œ ê°’ì„ ë‹´ì„ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  í•´ë‹¹ ë³€ìˆ˜ì— String(n)ì„ ëŒ€ì…
 - í•´ë‹¹ ë³€ìˆ˜ë¥¼ return
 */

/*:
 ## ğŸ“Œ í–„ë²„ê±° ë§Œë“¤ê¸°
 MARK: í–„ë²„ê±° ë§Œë“¤ê¸°
 
 - í–„ë²„ê±° ê°€ê²Œì—ì„œ ì¼ì„ í•˜ëŠ” ìƒìˆ˜ëŠ” í–„ë²„ê±°ë¥¼ í¬ì¥í•˜ëŠ” ì¼ì„ í•©ë‹ˆë‹¤. í•¨ê»˜ ì¼ì„ í•˜ëŠ” ë‹¤ë¥¸ ì§ì›ë“¤ì´ í–„ë²„ê±°ì— ë“¤ì–´ê°ˆ ì¬ë£Œë¥¼ ì¡°ë¦¬í•´ ì£¼ë©´ ì¡°ë¦¬ëœ ìˆœì„œëŒ€ë¡œ ìƒìˆ˜ì˜ ì•ì— ì•„ë˜ì„œë¶€í„° ìœ„ë¡œ ìŒ“ì´ê²Œ ë˜ê³ , ìƒìˆ˜ëŠ” ìˆœì„œì— ë§ê²Œ ìŒ“ì—¬ì„œ ì™„ì„±ëœ í–„ë²„ê±°ë¥¼ ë”°ë¡œ ì˜®ê²¨ í¬ì¥ì„ í•˜ê²Œ ë©ë‹ˆë‹¤. ìƒìˆ˜ê°€ ì¼í•˜ëŠ” ê°€ê²ŒëŠ” ì •í•´ì§„ ìˆœì„œ(ì•„ë˜ì„œë¶€í„°, ë¹µ â€“ ì•¼ì±„ â€“ ê³ ê¸° - ë¹µ)ë¡œ ìŒ“ì¸ í–„ë²„ê±°ë§Œ í¬ì¥ì„ í•©ë‹ˆë‹¤. ìƒìˆ˜ëŠ” ì†ì´ êµ‰ì¥íˆ ë¹ ë¥´ê¸° ë•Œë¬¸ì— ìƒìˆ˜ê°€ í¬ì¥í•˜ëŠ” ë™ì•ˆ ì† ì¬ë£Œê°€ ì¶”ê°€ì ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ì¼ì€ ì—†ìœ¼ë©°, ì¬ë£Œì˜ ë†’ì´ëŠ” ë¬´ì‹œí•˜ì—¬ ì¬ë£Œê°€ ë†’ì´ ìŒ“ì—¬ì„œ ì¼ì´ í˜ë“¤ì–´ì§€ëŠ” ê²½ìš°ëŠ” ì—†ìŠµë‹ˆë‹¤.
 
 - ì˜ˆë¥¼ ë“¤ì–´, ìƒìˆ˜ì˜ ì•ì— ìŒ“ì´ëŠ” ì¬ë£Œì˜ ìˆœì„œê°€ [ì•¼ì±„, ë¹µ, ë¹µ, ì•¼ì±„, ê³ ê¸°, ë¹µ, ì•¼ì±„, ê³ ê¸°, ë¹µ]ì¼ ë•Œ, ìƒìˆ˜ëŠ” ì—¬ì„¯ ë²ˆì§¸ ì¬ë£Œê°€ ìŒ“ì˜€ì„ ë•Œ, ì„¸ ë²ˆì§¸ ì¬ë£Œë¶€í„° ì—¬ì„¯ ë²ˆì§¸ ì¬ë£Œë¥¼ ì´ìš©í•˜ì—¬ í–„ë²„ê±°ë¥¼ í¬ì¥í•˜ê³ , ì•„í™‰ ë²ˆì§¸ ì¬ë£Œê°€ ìŒ“ì˜€ì„ ë•Œ, ë‘ ë²ˆì§¸ ì¬ë£Œì™€ ì¼ê³± ë²ˆì§¸ ì¬ë£Œë¶€í„° ì•„í™‰ ë²ˆì§¸ ì¬ë£Œë¥¼ ì´ìš©í•˜ì—¬ í–„ë²„ê±°ë¥¼ í¬ì¥í•©ë‹ˆë‹¤. ì¦‰, 2ê°œì˜ í–„ë²„ê±°ë¥¼ í¬ì¥í•˜ê²Œ ë©ë‹ˆë‹¤.

 - ìƒìˆ˜ì—ê²Œ ì „í•´ì§€ëŠ” ì¬ë£Œì˜ ì •ë³´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ì •ìˆ˜ ë°°ì—´ ingredientê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ìƒìˆ˜ê°€ í¬ì¥í•˜ëŠ” í–„ë²„ê±°ì˜ ê°œìˆ˜ë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì‹œì˜¤.
 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ì¬ë£Œê°€ ì•„ë˜ì—ì„œë¶€í„° ìœ„ë¡œ ìŒ“ì´ê³ , ì •í•´ì§„ ìˆœì„œ [1, 2, 3, 1] (ë¹µ-ì•¼ì±„-ê³ ê¸°-ë¹µ)ì´ ë˜ë©´ í•˜ë‚˜ì˜ í–„ë²„ê±°ë¡œ ì¸ì‹í•˜ì—¬ í¬ì¥
 - í¬ì¥í•œ í–„ë²„ê±°ëŠ” ìŠ¤íƒì—ì„œ ì œê±°ë˜ê³ , ì´í›„ì—ë„ ìŒ“ì´ëŠ” ì¬ë£Œë¡œ ë‹¤ì‹œ í–„ë²„ê±°ë¥¼ ë§Œë“¦
 - ì£¼ì–´ì§„ 'ingredient' ë°°ì—´ì€ ì¬ë£Œê°€ ìŒ“ì´ëŠ” ìˆœì„œë¥¼ ë‚˜íƒ€ë‚´ë©°, ìƒìˆ˜ê°€ í¬ì¥í•œ í–„ë²„ê±°ì˜ ì´ ê°œìˆ˜ë¥¼ returní•´ì•¼ í•¨
 
 ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ ingredientì˜ ê¸¸ì´ â‰¤ 1,000,000
 - ingredientì˜ ì›ì†ŒëŠ” 1, 2, 3 ì¤‘ í•˜ë‚˜ì˜ ê°’ì´ë©°, ìˆœì„œëŒ€ë¡œ ë¹µ, ì•¼ì±„, ê³ ê¸°ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.
 */

func solution38(_ ingredient:[Int]) -> Int {
    var stack: [Int] = []
    var count = 0
    for ingredient in ingredient {
        stack.append(ingredient)
        if stack.count >= 4 && stack.suffix(4) == [1, 2, 3, 1] {
            stack.removeLast(4)
            count += 1
        }
    }
    return count
}

// ì‹œê°„ ë³µì¡ë„ ê°œì„  ë²„ì „
func solution38_1(_ ingredient:[Int]) -> Int {
    var stack: [Int] = []
    var count = 0
    for ingredient in ingredient {
        stack.append(ingredient)
        if stack.count >= 4 && stack.suffix(4) == [1, 2, 3, 1] {
            stack.removeLast(4)
            count += 1
        }
    }
    return count
}


/*:
 ## ì„¤ëª…
 - stack: í˜„ì¬ ìŒ“ì—¬ ìˆëŠ” ì¬ë£Œë“¤ì„ ì €ì¥í•˜ëŠ” ë°°ì—´
 - count: í¬ì¥í•œ í–„ë²„ê±°ì˜ ì´ ê°œìˆ˜
 - forë¬¸ê³¼ append()ë¥¼ ì‚¬ìš©í•´ì„œ ingredientë¥¼ stackì•ˆì— ìŒ“ìŒ
 - ifë¬¸ìœ¼ë¡œ ìŠ¤íƒì˜ ë§ˆì§€ë§‰ ì¬ë£Œê°€ [1, 2, 3, 1]ì´ ë˜ë©´ í•´ë‹¹ ìŠ¤íƒ 4ê°œë¥¼ ì œê±°í•˜ê³  countë¥¼ 1 ì¦ê°€ ì‹œí‚´
 - ìµœì¢…ì ìœ¼ë¡œ í¬ì¥í•œ í–„ë²„ê±°ì˜ ìˆ˜(count)ë¥¼ return
 */

/*:
 ## ì„¤ëª…
 - ë¬¸ìì—´ë¡œ ë³€í™˜í•œ ê°’ì„ ë‹´ì„ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  í•´ë‹¹ ë³€ìˆ˜ì— String(n)ì„ ëŒ€ì…
 - í•´ë‹¹ ë³€ìˆ˜ë¥¼ return
 */

/*:
 ## ğŸ“Œ ê°€ì¥ ë§ì´ ë°›ì€ ì„ ë¬¼
 MARK: ê°€ì¥ ë§ì´ ë°›ì€ ì„ ë¬¼
 
 - ì„ ë¬¼ì„ ì§ì ‘ ì „í•˜ê¸° í˜ë“¤ ë•Œ ì¹´ì¹´ì˜¤í†¡ ì„ ë¬¼í•˜ê¸° ê¸°ëŠ¥ì„ ì´ìš©í•´ ì¶•í•˜ ì„ ë¬¼ì„ ë³´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¹ì‹ ì˜ ì¹œêµ¬ë“¤ì´ ì´ë²ˆ ë‹¬ê¹Œì§€ ì„ ë¬¼ì„ ì£¼ê³ ë°›ì€ ê¸°ë¡ì„ ë°”íƒ•ìœ¼ë¡œ ë‹¤ìŒ ë‹¬ì— ëˆ„ê°€ ì„ ë¬¼ì„ ë§ì´ ë°›ì„ì§€ ì˜ˆì¸¡í•˜ë ¤ê³  í•©ë‹ˆë‹¤. ë‘ ì‚¬ëŒì´ ì„ ë¬¼ì„ ì£¼ê³ ë°›ì€ ê¸°ë¡ì´ ìˆë‹¤ë©´, ì´ë²ˆ ë‹¬ê¹Œì§€ ë‘ ì‚¬ëŒ ì‚¬ì´ì— ë” ë§ì€ ì„ ë¬¼ì„ ì¤€ ì‚¬ëŒì´ ë‹¤ìŒ ë‹¬ì— ì„ ë¬¼ì„ í•˜ë‚˜ ë°›ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ Aê°€ Bì—ê²Œ ì„ ë¬¼ì„ 5ë²ˆ ì¤¬ê³ , Bê°€ Aì—ê²Œ ì„ ë¬¼ì„ 3ë²ˆ ì¤¬ë‹¤ë©´ ë‹¤ìŒ ë‹¬ì—” Aê°€ Bì—ê²Œ ì„ ë¬¼ì„ í•˜ë‚˜ ë°›ìŠµë‹ˆë‹¤. ë‘ ì‚¬ëŒì´ ì„ ë¬¼ì„ ì£¼ê³ ë°›ì€ ê¸°ë¡ì´ í•˜ë‚˜ë„ ì—†ê±°ë‚˜ ì£¼ê³ ë°›ì€ ìˆ˜ê°€ ê°™ë‹¤ë©´, ì„ ë¬¼ ì§€ìˆ˜ê°€ ë” í° ì‚¬ëŒì´ ì„ ë¬¼ ì§€ìˆ˜ê°€ ë” ì‘ì€ ì‚¬ëŒì—ê²Œ ì„ ë¬¼ì„ í•˜ë‚˜ ë°›ìŠµë‹ˆë‹¤. ì„ ë¬¼ ì§€ìˆ˜ëŠ” ì´ë²ˆ ë‹¬ê¹Œì§€ ìì‹ ì´ ì¹œêµ¬ë“¤ì—ê²Œ ì¤€ ì„ ë¬¼ì˜ ìˆ˜ì—ì„œ ë°›ì€ ì„ ë¬¼ì˜ ìˆ˜ë¥¼ ëº€ ê°’ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ Aê°€ ì¹œêµ¬ë“¤ì—ê²Œ ì¤€ ì„ ë¬¼ì´ 3ê°œê³  ë°›ì€ ì„ ë¬¼ì´ 10ê°œë¼ë©´ Aì˜ ì„ ë¬¼ ì§€ìˆ˜ëŠ” -7ì…ë‹ˆë‹¤. Bê°€ ì¹œêµ¬ë“¤ì—ê²Œ ì¤€ ì„ ë¬¼ì´ 3ê°œê³  ë°›ì€ ì„ ë¬¼ì´ 2ê°œë¼ë©´ Bì˜ ì„ ë¬¼ ì§€ìˆ˜ëŠ” 1ì…ë‹ˆë‹¤. ë§Œì•½ Aì™€ Bê°€ ì„ ë¬¼ì„ ì£¼ê³ ë°›ì€ ì ì´ ì—†ê±°ë‚˜ ì •í™•íˆ ê°™ì€ ìˆ˜ë¡œ ì„ ë¬¼ì„ ì£¼ê³ ë°›ì•˜ë‹¤ë©´, ë‹¤ìŒ ë‹¬ì—” Bê°€ Aì—ê²Œ ì„ ë¬¼ì„ í•˜ë‚˜ ë°›ìŠµë‹ˆë‹¤. ë§Œì•½ ë‘ ì‚¬ëŒì˜ ì„ ë¬¼ ì§€ìˆ˜ë„ ê°™ë‹¤ë©´ ë‹¤ìŒ ë‹¬ì— ì„ ë¬¼ì„ ì£¼ê³ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤. ìœ„ì—ì„œ ì„¤ëª…í•œ ê·œì¹™ëŒ€ë¡œ ë‹¤ìŒ ë‹¬ì— ì„ ë¬¼ì„ ì£¼ê³ ë°›ì„ ë•Œ, ë‹¹ì‹ ì€ ì„ ë¬¼ì„ ê°€ì¥ ë§ì´ ë°›ì„ ì¹œêµ¬ê°€ ë°›ì„ ì„ ë¬¼ì˜ ìˆ˜ë¥¼ ì•Œê³  ì‹¶ìŠµë‹ˆë‹¤. ì¹œêµ¬ë“¤ì˜ ì´ë¦„ì„ ë‹´ì€ 1ì°¨ì› ë¬¸ìì—´ ë°°ì—´ friends ì´ë²ˆ ë‹¬ê¹Œì§€ ì¹œêµ¬ë“¤ì´ ì£¼ê³ ë°›ì€ ì„ ë¬¼ ê¸°ë¡ì„ ë‹´ì€ 1ì°¨ì› ë¬¸ìì—´ ë°°ì—´ giftsê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤. ì´ë•Œ, ë‹¤ìŒë‹¬ì— ê°€ì¥ ë§ì€ ì„ ë¬¼ì„ ë°›ëŠ” ì¹œêµ¬ê°€ ë°›ì„ ì„ ë¬¼ì˜ ìˆ˜ë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”.

 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - ëª¨ë“  ì¹œêµ¬ ìŒì— ëŒ€í•´ ë‹¤ìŒ ë‹¬ì— ëˆ„ê°€ ì„ ë¬¼ì„ ë°›ëŠ”ì§€ ê³„ì‚°í•¨
 - ëˆ„ê°€ ì„ ë¬¼ì„ ì–¼ë§ˆë‚˜ ë°›ëŠ”ì§€ë¥¼ ëª¨ë‘ ê³„ì‚°í•´ì„œ, ê·¸ ì¤‘ ê°€ì¥ ë§ì´ ë°›ì€ ìˆ˜ë¥¼ return
 
 - friendsê°€ ["muzi", "ryan", "frodo", "neo"]ì´ê³  giftsê°€ ["muzi frodo", "muzi frodo", "ryan muzi", "ryan muzi", "ryan muzi", "frodo muzi", "frodo ryan", "neo muzi"]ë¼ë©´ 2ë¥¼ return
  - friendsê°€ ["joy", "brad", "alessandro", "conan", "david"]ì´ê³  giftsê°€ ["alessandro brad", "alessandro joy", "alessandro conan", "david alessandro", "alessandro david"]ë¼ë©´ 4ë¥¼ return
  - friendsê°€ ["a", "b", "c"]ì´ê³  giftsê°€ ["a b", "b a", "c a", "a c", "a c", "c a"]ë¼ë©´ 0ì„ return
 
  ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 2 â‰¤ friendsì˜ ê¸¸ì´ = ì¹œêµ¬ë“¤ì˜ ìˆ˜ â‰¤ 50
 - friendsì˜ ì›ì†ŒëŠ” ì¹œêµ¬ì˜ ì´ë¦„ì„ ì˜ë¯¸í•˜ëŠ” ì•ŒíŒŒë²³ ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì§„ ê¸¸ì´ê°€ 10 ì´í•˜ì¸ ë¬¸ìì—´
 - 1 â‰¤ giftsì˜ ê¸¸ì´ â‰¤ 10,000
 - giftsì˜ ì›ì†ŒëŠ” "A B"í˜•íƒœì˜ ë¬¸ìì—´ì´ë©° AëŠ” ì„ ë¬¼ì„ ì¤€ ì¹œêµ¬, BëŠ” ì„ ë¬¼ì„ ë°›ì€ ì¹œêµ¬ë¥¼ ì˜ë¯¸

 */

func solution39(_ friends: [String], _ gifts: [String]) -> Int {
    // ì¹œêµ¬ ìˆ˜ë¥¼ ì €ì¥ (ì˜ˆ: ["muzi", "ryan", "frodo", "neo"]ë¼ë©´ n = 4)
    let n = friends.count
    
    // ì¹œêµ¬ ì´ë¦„ì„ ìˆ«ìë¡œ ë°”ê¿”ì£¼ëŠ” ì‚¬ì „ ë§Œë“¤ê¸°
    // ì˜ˆ: "muzi" -> 0, "ryan" -> 1, "frodo" -> 2, "neo" -> 3
    var nameToIndex: [String: Int] = [:]
    for (index, friend) in friends.enumerated() {
        nameToIndex[friend] = index
    }
    
    // ëˆ„ê°€ ëˆ„êµ¬ì—ê²Œ ì„ ë¬¼ì„ ëª‡ ê°œ ì¤¬ëŠ”ì§€ ê¸°ë¡í•˜ëŠ” í‘œ ë§Œë“¤ê¸°
    // giftRecord[0][1] = muziê°€ ryanì—ê²Œ ì¤€ ì„ ë¬¼ ê°œìˆ˜
    // ì²˜ìŒì—ëŠ” ëª¨ë“  ê°’ì´ 0ìœ¼ë¡œ ì„¤ì •ë¨
    var giftRecord = Array(repeating: Array(repeating: 0, count: n), count: n)
    
    // ê° ì¹œêµ¬ê°€ ì¤€ ì„ ë¬¼ê³¼ ë°›ì€ ì„ ë¬¼ì˜ ì´ ê°œìˆ˜ë¥¼ ì„¸ëŠ” ë°°ì—´
    var given = Array(repeating: 0, count: n)     // ì¤€ ì„ ë¬¼ ê°œìˆ˜
    var received = Array(repeating: 0, count: n)  // ë°›ì€ ì„ ë¬¼ ê°œìˆ˜
    
    // ì„ ë¬¼ ê¸°ë¡ì„ í•˜ë‚˜ì”© ì½ì–´ì„œ ì²˜ë¦¬í•˜ê¸°
    // ì˜ˆ: "muzi frodo"ë¼ë©´ muziê°€ frodoì—ê²Œ ì„ ë¬¼ì„ ì¤€ ê²ƒ
    for gift in gifts {
        // ê³µë°±ìœ¼ë¡œ ë‚˜ëˆ„ê¸°: "muzi frodo" -> ["muzi", "frodo"]
        let parts = gift.split(separator: " ")
        let giver = String(parts[0])      // ì„ ë¬¼ì„ ì¤€ ì‚¬ëŒ
        let receiver = String(parts[1])   // ì„ ë¬¼ì„ ë°›ì€ ì‚¬ëŒ
        
        // ì´ë¦„ì„ ìˆ«ìë¡œ ë°”ê¾¸ê¸°
        let giverIndex = nameToIndex[giver]!
        let receiverIndex = nameToIndex[receiver]!
        
        // ì„ ë¬¼ ê¸°ë¡ í‘œì— 1ê°œ ì¶”ê°€
        giftRecord[giverIndex][receiverIndex] += 1
        // ì¤€ ì‚¬ëŒì˜ "ì¤€ ì„ ë¬¼" ê°œìˆ˜ 1ê°œ ì¦ê°€
        given[giverIndex] += 1
        // ë°›ì€ ì‚¬ëŒì˜ "ë°›ì€ ì„ ë¬¼" ê°œìˆ˜ 1ê°œ ì¦ê°€
        received[receiverIndex] += 1
    }
    
    // ì„ ë¬¼ ì§€ìˆ˜ ê³„ì‚°í•˜ê¸° (ì¤€ ì„ ë¬¼ ê°œìˆ˜ - ë°›ì€ ì„ ë¬¼ ê°œìˆ˜)
    // ì˜ˆ: muziê°€ 5ê°œ ì£¼ê³  3ê°œ ë°›ì•˜ë‹¤ë©´ ì„ ë¬¼ì§€ìˆ˜ëŠ” 5-3=2
    var giftIndex = Array(repeating: 0, count: n)
    for i in 0..<n {
        giftIndex[i] = given[i] - received[i]
    }
    
    // ë‹¤ìŒ ë‹¬ì— ê° ì¹œêµ¬ê°€ ë°›ì„ ì„ ë¬¼ì˜ ìˆ˜ë¥¼ ì €ì¥í•  ë°°ì—´
    var nextMonthGifts = Array(repeating: 0, count: n)
    
    // ëª¨ë“  ì¹œêµ¬ ìŒì„ ë¹„êµí•´ì„œ ëˆ„ê°€ ì„ ë¬¼ì„ ë°›ì„ì§€ ê²°ì •í•˜ê¸°
    // i < jë¡œ í•˜ëŠ” ì´ìœ : ê°™ì€ ìŒì„ ë‘ ë²ˆ ë¹„êµí•˜ì§€ ì•Šê¸° ìœ„í•´
    for i in 0..<n {
        for j in (i+1)..<n {
            // iê°€ jì—ê²Œ ì¤€ ì„ ë¬¼ ê°œìˆ˜
            let iToJ = giftRecord[i][j]
            // jê°€ iì—ê²Œ ì¤€ ì„ ë¬¼ ê°œìˆ˜
            let jToI = giftRecord[j][i]
            
            if iToJ > jToI {
                // iê°€ jë³´ë‹¤ ë” ë§ì´ ì¤¬ë‹¤ë©´, iê°€ ì„ ë¬¼ì„ í•˜ë‚˜ ë°›ìŒ
                nextMonthGifts[i] += 1
            } else if jToI > iToJ {
                // jê°€ ië³´ë‹¤ ë” ë§ì´ ì¤¬ë‹¤ë©´, jê°€ ì„ ë¬¼ì„ í•˜ë‚˜ ë°›ìŒ
                nextMonthGifts[j] += 1
            } else {
                // ì£¼ê³ ë°›ì€ ê°œìˆ˜ê°€ ê°™ê±°ë‚˜ ì£¼ê³ ë°›ì€ ì ì´ ì—†ëŠ” ê²½ìš°
                // ì„ ë¬¼ ì§€ìˆ˜ê°€ ë” í° ì‚¬ëŒì´ ì„ ë¬¼ì„ ë°›ìŒ
                if giftIndex[i] > giftIndex[j] {
                    nextMonthGifts[i] += 1
                } else if giftIndex[j] > giftIndex[i] {
                    nextMonthGifts[j] += 1
                }
                // ì„ ë¬¼ ì§€ìˆ˜ë„ ë˜‘ê°™ë‹¤ë©´ ì•„ë¬´ë„ ì„ ë¬¼ì„ ì•ˆ ë°›ìŒ (ì•„ë¬´ê²ƒë„ ì•ˆ í•¨)
            }
        }
    }
    
    // ê°€ì¥ ë§ì´ ë°›ì„ ì„ ë¬¼ì˜ ê°œìˆ˜ë¥¼ ì°¾ì•„ì„œ ë°˜í™˜
    return nextMonthGifts.max() ?? 0
}
/*:
 ## ì„¤ëª…
 - ë¨¼ì € nameToIndex ë”•ì…”ë„ˆë¦¬ë¥¼ ì„ ì–¸í•´ì„œ ì¹œêµ¬ ì´ë¦„ì„ ìˆ«ì ì¸ë±ìŠ¤ë¡œ ë³€í™˜í•˜ëŠ” ë§¤í•‘ í…Œì´ë¸”ì„ ë§Œë“¦
 - giftRecord 2ì°¨ì› ë°°ì—´ì„ ì„ ì–¸í•´ì„œ ië²ˆì§¸ ì¹œêµ¬ê°€ jë²ˆì§¸ ì¹œêµ¬ì—ê²Œ ì¤€ ì„ ë¬¼ ê°œìˆ˜ë¥¼ ì €ì¥
   - Array(repeating: Array(repeating: 0, count: n), count: n)ë¡œ nÃ—n í¬ê¸°ì˜ 0ìœ¼ë¡œ ì´ˆê¸°í™”ëœ 2ì°¨ì› ë°°ì—´ ìƒì„±
 - given, received ë°°ì—´ì„ ì„ ì–¸í•´ì„œ ê° ì¹œêµ¬ê°€ ì¤€ ì„ ë¬¼ê³¼ ë°›ì€ ì„ ë¬¼ì˜ ì´ ê°œìˆ˜ë¥¼ ì¶”ì 
 - for ë£¨í”„ë¥¼ í†µí•´ gifts ë°°ì—´ì˜ ê° ì„ ë¬¼ ê¸°ë¡ì„ ì²˜ë¦¬
   - split(separator: " ")ë¥¼ ì‚¬ìš©í•´ì„œ "A B" í˜•íƒœì˜ ë¬¸ìì—´ì„ Aì™€ Bë¡œ ë¶„ë¦¬
   - nameToIndex ë”•ì…”ë„ˆë¦¬ë¥¼ ì‚¬ìš©í•´ì„œ ì´ë¦„ì„ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
   - giftRecord, given, received ë°°ì—´ì„ ì—…ë°ì´íŠ¸
 - giftIndex ë°°ì—´ì„ ê³„ì‚°í•´ì„œ ê° ì¹œêµ¬ì˜ ì„ ë¬¼ ì§€ìˆ˜(ì¤€ ì„ ë¬¼ - ë°›ì€ ì„ ë¬¼)ë¥¼ ì €ì¥
 - ì´ì¤‘ for ë£¨í”„ë¥¼ ì‚¬ìš©í•´ì„œ ëª¨ë“  ì¹œêµ¬ ìŒì„ ë¹„êµ (i < j ì¡°ê±´ìœ¼ë¡œ ì¤‘ë³µ ë°©ì§€)
   - ì§ì ‘ ì£¼ê³ ë°›ì€ ì„ ë¬¼ ìˆ˜ë¥¼ ë¹„êµí•´ì„œ ë” ë§ì´ ì¤€ ì‚¬ëŒì´ ì„ ë¬¼ì„ ë°›ìŒ
   - ê°™ë‹¤ë©´ ì„ ë¬¼ ì§€ìˆ˜ë¥¼ ë¹„êµí•´ì„œ ë†’ì€ ì‚¬ëŒì´ ì„ ë¬¼ì„ ë°›ìŒ
   - ì„ ë¬¼ ì§€ìˆ˜ë„ ê°™ë‹¤ë©´ ì•„ë¬´ë„ ì„ ë¬¼ì„ ë°›ì§€ ì•ŠìŒ
 - nextMonthGifts.max() ?? 0ì„ ì‚¬ìš©í•´ì„œ ê°€ì¥ ë§ì´ ë°›ì„ ì„ ë¬¼ì˜ ê°œìˆ˜ë¥¼ ë°˜í™˜
   - max()ëŠ” ì˜µì…”ë„ì„ ë°˜í™˜í•˜ë¯€ë¡œ nil coalescent operator(??)ë¥¼ ì‚¬ìš©í•´ì„œ nilì¸ ê²½ìš° 0ì„ ë°˜í™˜
 */


/*:
 ## ğŸ“Œ ì„¸ ê°œì˜ êµ¬ë¶„ì
 MARK: ì„¸ ê°œì˜ êµ¬ë¶„ì
 
 - ì„ì˜ì˜ ë¬¸ìì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ ë¬¸ì "a", "b", "c"ë¥¼ êµ¬ë¶„ìë¡œ ì‚¬ìš©í•´ ë¬¸ìì—´ì„ ë‚˜ëˆ„ê³ ì í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì£¼ì–´ì§„ ë¬¸ìì—´ì´ "baconlettucetomato"ë¼ë©´ ë‚˜ëˆ ì§„ ë¬¸ìì—´ ëª©ë¡ì€ ["onlettu", "etom", "to"] ê°€ ë©ë‹ˆë‹¤. ë¬¸ìì—´ myStrì´ ì£¼ì–´ì¡Œì„ ë•Œ ìœ„ ì˜ˆì‹œì™€ ê°™ì´ "a", "b", "c"ë¥¼ ì‚¬ìš©í•´ ë‚˜ëˆ ì§„ ë¬¸ìì—´ì„ ìˆœì„œëŒ€ë¡œ ì €ì¥í•œ ë°°ì—´ì„ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ ì£¼ì„¸ìš”. ë‹¨, ë‘ êµ¬ë¶„ì ì‚¬ì´ì— ë‹¤ë¥¸ ë¬¸ìê°€ ì—†ì„ ê²½ìš°ì—ëŠ” ì•„ë¬´ê²ƒë„ ì €ì¥í•˜ì§€ ì•Šìœ¼ë©°, returní•  ë°°ì—´ì´ ë¹ˆ ë°°ì—´ì´ë¼ë©´ ["EMPTY"]ë¥¼ return í•©ë‹ˆë‹¤.

 
 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - myStrì´ ["abcd"] ë¼ë©´ ["d"]ë¥¼ return
 - myStrì´ ["cabab"] ë¼ë©´ ["EMPTY"]ë¥¼ return
 
  ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ myStrì˜ ê¸¸ì´ â‰¤ 1,000,000
    - myStrì€ ì•ŒíŒŒë²³ ì†Œë¬¸ìë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´ ì…ë‹ˆë‹¤.

 */

func solution40(_ myStr:String) -> [String] {
    let result = myStr.components(separatedBy: CharacterSet(charactersIn: "abc"))
    let filtered = result.filter { !$0.isEmpty }
    
    return filtered.isEmpty ? ["EMPTY"] : filtered
}

/*:
 ## ì„¤ëª…
 - ["a", "b", "c"] ê¸°ì¤€ìœ¼ë¡œ ë¬¸ìì—´ì„ ë‚˜ëˆ„ê¸° ìœ„í•´ì„œ components(separatedBy:)ë¥¼ ì‚¬ìš©í•´ì„œ ë¬¸ìì—´ì„ a, b, c ê¸°ì¤€ìœ¼ë¡œ ì˜ë¼ì„œ ë°°ì—´ë¡œ ë§Œë“¦
 - componentsëŠ” ì—°ì†ëœ êµ¬ë¶„ìê°€ ìˆì„ ë•Œë‚˜ ì²˜ìŒì´ë‚˜ ëì— êµ¬ë¶„ìê°€ ìˆì„ ë•Œ, ê·¸ ì‚¬ì´ì— ê¸€ìê°€ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ì´ ê²°ê³¼ì— ìƒê¸°ë¯€ë¡œ filter í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ë¹ˆ ë¬¸ìì—´ì€ ì œê±°
 - filteredë¥¼ return, ë‹¨ ë¬¸ì œì—ì„œ return í•˜ëŠ” ë°°ì—´ì´ ë¹ˆ ë°°ì—´ì´ë¼ë©´ ["EMPTY"]ë¥¼ returní•´ì•¼ í•˜ë¯€ë¡œ ì‚¼í•­ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ì„œ ë¹ˆ ë°°ì—´ì´ë¼ë©´ ["EMPTY"]ë¥¼ return
 */

/*:
 ## ğŸ“Œ ì •ìˆ˜ ë¶€ë¶„
 MARK: ì •ìˆ˜ ë¶€ë¶„
 
 - ì‹¤ìˆ˜ floê°€ ë§¤ê°œ ë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, floì˜ ì •ìˆ˜ ë¶€ë¶„ì„ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.

 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - floê°€ 1.42 ë¼ë©´ 1ì„ return
 - floê°€ 69.32 ë¼ë©´ 69ë¥¼ return
 
  ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 0 â‰¤ flo â‰¤ 100

 */

func solution41(_ flo:Double) -> Int {
    let floInt = Int(flo)
    return floInt
}
/*:
 ## ì„¤ëª…
 - ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§„ ì‹¤ìˆ˜ 'flo'ì—ì„œ ì†Œìˆ˜ì  ì•„ë˜ë¥¼ ì œì™¸í•œ ì •ìˆ˜ ë¶€ë¶„ë§Œì„ êµ¬í•´ì•¼ í•˜ë¯€ë¡œ 'Int(flo)'ë¥¼ í†µí•´ ì‹¤ìˆ˜ë¥¼ ì •ìˆ˜í˜•ìœ¼ë¡œ ë³€í™˜
 - 'Double'ì„ 'Int'ë¡œ ë³€í™˜í•  ê²½ìš° ì†Œìˆ˜ì  ì´í•˜ê°€ ìë™ìœ¼ë¡œ ë²„ë ¤ì§€ê³  ë‚´ë¦¼(truncation) ë°©ì‹ìœ¼ë¡œ ë³€í™˜ë˜ë¯€ë¡œ ë³„ë„ì˜ ì¶”ê°€ ì²˜ë¦¬ ì—†ì´ ì •ìˆ˜ ë¶€ë¶„ë§Œ ì¶”ì¶œ ê°€ëŠ¥
 - ë³€í™˜ëœ ê°’ì„ ê·¸ëŒ€ë¡œ return
 */


/*:
 ## ğŸ“Œ ë§ì¹ í•˜ê¸°
 MARK: ë§ì¹ í•˜ê¸°
 
 - ì–´ëŠ í•™êµì— í˜ì¸íŠ¸ê°€ ì¹ í•´ì§„ ê¸¸ì´ê°€ në¯¸í„°ì¸ ë²½ì´ ìˆìŠµë‹ˆë‹¤. ë²½ì— ë™ì•„ë¦¬ Â· í•™íšŒ í™ë³´ë‚˜ íšŒì‚¬ ì±„ìš© ê³µê³  í¬ìŠ¤í„° ë“±ì„ ê²Œì‹œí•˜ê¸° ìœ„í•´ í…Œì´í”„ë¡œ ë¶™ì˜€ë‹¤ê°€ ì² ê±°í•  ë•Œ ë–¼ëŠ” ì¼ì´ ë§ê³  ê·¸ ê³¼ì •ì—ì„œ í˜ì¸íŠ¸ê°€ ë²—ê²¨ì§€ê³¤ í•©ë‹ˆë‹¤. í˜ì¸íŠ¸ê°€ ë²—ê²¨ì§„ ë²½ì´ ë³´ê¸° í‰í•´ì ¸ í•™êµëŠ” ë²½ì— í˜ì¸íŠ¸ë¥¼ ë§ì¹ í•˜ê¸°ë¡œ í–ˆìŠµë‹ˆë‹¤.
 
 ë„“ì€ ë²½ ì „ì²´ì— í˜ì¸íŠ¸ë¥¼ ìƒˆë¡œ ì¹ í•˜ëŠ” ëŒ€ì‹ , êµ¬ì—­ì„ ë‚˜ëˆ„ì–´ ì¼ë¶€ë§Œ í˜ì¸íŠ¸ë¥¼ ìƒˆë¡œ ì¹  í•¨ìœ¼ë¡œì¨ ì˜ˆì‚°ì„ ì•„ë¼ë ¤ í•©ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ ë²½ì„ 1ë¯¸í„° ê¸¸ì´ì˜ êµ¬ì—­ nê°œë¡œ ë‚˜ëˆ„ê³ , ê° êµ¬ì—­ì— ì™¼ìª½ë¶€í„° ìˆœì„œëŒ€ë¡œ 1ë²ˆë¶€í„° në²ˆê¹Œì§€ ë²ˆí˜¸ë¥¼ ë¶™ì˜€ìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  í˜ì¸íŠ¸ë¥¼ ë‹¤ì‹œ ì¹ í•´ì•¼ í•  êµ¬ì—­ë“¤ì„ ì •í–ˆìŠµë‹ˆë‹¤.

 ë²½ì— í˜ì¸íŠ¸ë¥¼ ì¹ í•˜ëŠ” ë¡¤ëŸ¬ì˜ ê¸¸ì´ëŠ” më¯¸í„°ì´ê³ , ë¡¤ëŸ¬ë¡œ ë²½ì— í˜ì¸íŠ¸ë¥¼ í•œ ë²ˆ ì¹ í•˜ëŠ” ê·œì¹™ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

 ë¡¤ëŸ¬ê°€ ë²½ì—ì„œ ë²—ì–´ë‚˜ë©´ ì•ˆ ë©ë‹ˆë‹¤.
 êµ¬ì—­ì˜ ì¼ë¶€ë¶„ë§Œ í¬í•¨ë˜ë„ë¡ ì¹ í•˜ë©´ ì•ˆ ë©ë‹ˆë‹¤.
 ì¦‰, ë¡¤ëŸ¬ì˜ ì¢Œìš°ì¸¡ ëì„ êµ¬ì—­ì˜ ê²½ê³„ì„  í˜¹ì€ ë²½ì˜ ì¢Œìš°ì¸¡ ëë¶€ë¶„ì— ë§ì¶˜ í›„ ë¡¤ëŸ¬ë¥¼ ìœ„ì•„ë˜ë¡œ ì›€ì§ì´ë©´ì„œ ë²½ì„ ì¹ í•©ë‹ˆë‹¤. í˜„ì¬ í˜ì¸íŠ¸ë¥¼ ì¹ í•˜ëŠ” êµ¬ì—­ë“¤ì„ ì™„ì „íˆ ì¹ í•œ í›„ ë²½ì—ì„œ ë¡¤ëŸ¬ë¥¼ ë–¼ë©°, ì´ë¥¼ ë²½ì„ í•œ ë²ˆ ì¹ í–ˆë‹¤ê³  ì •ì˜í•©ë‹ˆë‹¤.

 í•œ êµ¬ì—­ì— í˜ì¸íŠ¸ë¥¼ ì—¬ëŸ¬ ë²ˆ ì¹ í•´ë„ ë˜ê³  ë‹¤ì‹œ ì¹ í•´ì•¼ í•  êµ¬ì—­ì´ ì•„ë‹Œ ê³³ì— í˜ì¸íŠ¸ë¥¼ ì¹ í•´ë„ ë˜ì§€ë§Œ ë‹¤ì‹œ ì¹ í•˜ê¸°ë¡œ ì •í•œ êµ¬ì—­ì€ ì ì–´ë„ í•œ ë²ˆ í˜ì¸íŠ¸ì¹ ì„ í•´ì•¼ í•©ë‹ˆë‹¤. ì˜ˆì‚°ì„ ì•„ë¼ê¸° ìœ„í•´ ë‹¤ì‹œ ì¹ í•  êµ¬ì—­ì„ ì •í–ˆë“¯ ë§ˆì°¬ê°€ì§€ë¡œ ë¡¤ëŸ¬ë¡œ í˜ì¸íŠ¸ì¹ ì„ í•˜ëŠ” íšŸìˆ˜ë¥¼ ìµœì†Œí™”í•˜ë ¤ê³  í•©ë‹ˆë‹¤.

 ì •ìˆ˜ n, mê³¼ ë‹¤ì‹œ í˜ì¸íŠ¸ë¥¼ ì¹ í•˜ê¸°ë¡œ ì •í•œ êµ¬ì—­ë“¤ì˜ ë²ˆí˜¸ê°€ ë‹´ê¸´ ì •ìˆ˜ ë°°ì—´ sectionì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ ë¡¤ëŸ¬ë¡œ í˜ì¸íŠ¸ì¹ í•´ì•¼ í•˜ëŠ” ìµœì†Œ íšŸìˆ˜ë¥¼ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.



 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 - nì´ 8, mì´ 4, sectionì´ [2, 3, 6] ì´ë¼ë©´ 2ë¥¼ return
 - floê°€ 69.32 ë¼ë©´ 69ë¥¼ return
 
  ### ğŸ”¹ ì œí•œ ì‚¬í•­
 - 1 â‰¤ m â‰¤ n â‰¤ 100,000
 - 1 â‰¤ sectionì˜ ê¸¸ì´ â‰¤ n
    - 1 â‰¤ sectionì˜ ì›ì†Œ â‰¤ n
    - sectionì˜ ì›ì†ŒëŠ” í˜ì¸íŠ¸ë¥¼ ë‹¤ì‹œ ì¹ í•´ì•¼ í•˜ëŠ” êµ¬ì—­ì˜ ë²ˆí˜¸ì…ë‹ˆë‹¤.
    - sectionì—ì„œ ê°™ì€ ì›ì†Œê°€ ë‘ ë²ˆ ì´ìƒ ë‚˜íƒ€ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    - sectionì˜ ì›ì†ŒëŠ” ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

 */

func solution42(_ n:Int, _ m:Int, _ section:[Int]) -> Int {
    var count = 0
    var paintedEnd = 0
    
    for i in section {
        if i > paintedEnd {
            paintedEnd = i + m - 1
            count += 1
        }
    }
    return count
}

/*:
 ## ì„¤ëª…
 - section ë°°ì—´ì„ ì•ì—ì„œë¶€í„° ìˆœíšŒí•˜ë©´ì„œ, í˜„ì¬ êµ¬ì—­(i)ì´ ì´ë¯¸ ì¹ í•´ì§„ ë²”ìœ„(paintedEnd)ë³´ë‹¤ í¬ë©´ ë¡¤ëŸ¬ì§ˆì´ í•„ìš”í•¨
 - ë¡¤ëŸ¬ëŠ” më¯¸í„°ë¥¼ ì—°ì†ìœ¼ë¡œ ì¹ í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, í•´ë‹¹ êµ¬ì—­ë¶€í„° i + m - 1 ê¹Œì§€ ì¹ í•´ì§„ ê²ƒìœ¼ë¡œ ê°„ì£¼
 - ìƒˆë¡œ ì¹ í•  ë•Œë§ˆë‹¤ countë¥¼ ì¦ê°€ì‹œí‚´
 - ì´ë¯¸ ì¹ í•´ì§„ ë²”ìœ„ ì•ˆì— ìˆëŠ” êµ¬ì—­ì€ ì¶”ê°€ë¡œ ì¹ í•˜ì§€ ì•Šê³  ë„˜ì–´ê°
 - ì „ì²´ sectionì„ í•œ ë²ˆë§Œ ìˆœíšŒí•˜ë¯€ë¡œ ì‹œê°„ ë³µì¡ë„ëŠ” O(n)
 */


func solution(_ cards1:[String], _ cards2:[String], _ goal:[String]) -> String {
    var cards1 = cards1
    var cards2 = cards2
    
    for word in goal {
        if cards1.first == word {
            cards1.removeFirst()
        } else if cards2.first == word {
            cards2.removeFirst()
        } else {
            return "No"
        }
    }
    return "Yes"
}


/*:
 ## ğŸ“Œ ê°„ë‹¨í•œ ë…¼ë¦¬ ì—°ì‚°
 MARK: ê°„ë‹¨í•œ ë…¼ë¦¬ ì—°ì‚°
 
 - boolean ë³€ìˆ˜ x1, x2, x3, x4ê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë‹¤ìŒì˜ ì‹ì˜ true/falseë¥¼ return í•˜ëŠ” solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ ì£¼ì„¸ìš”.
    - (x1 âˆ¨ x2) âˆ§ (x3 âˆ¨ x4)


 ### ğŸ”¹ ë¬¸ì œ ì„¤ëª…
 * (x1 âˆ¨ x2) âˆ§ (x3 âˆ¨ x4)
 * Swift ë¬¸ë²•ìœ¼ë¡œëŠ” (x1 || x2) && (x3 || x4)ìœ¼ë¡œ í‘œí˜„

 ### ğŸ”¹ ì¡°ê±´
 - 'x1', 'x2', 'x3', 'x4'ëŠ” ëª¨ë‘ 'Bool' íƒ€ì…
 - ì—°ì‚°ì€ OR('||')ì™€ AND('&&')ë¡œ êµ¬ì„±ë˜ì–´ ìˆìŒ
     - '||'ëŠ” ë…¼ë¦¬í•©: ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë„ 'true'ë©´ 'true'
     - &&ëŠ” ë…¼ë¦¬ê³±: ë‘˜ ë‹¤ 'true'ì¼ ë•Œë§Œ 'true'

 ### ğŸ”¹ ë°˜í™˜ê°’
 - ì „ì²´ ë…¼ë¦¬ì‹ì˜ ê²°ê³¼ì¸ 'true' ë˜ëŠ” 'false'ë¥¼ return

 ### ğŸ”¹ ì…ì¶œë ¥ ì˜ˆì‹œ

 | x1    | x2    | x3    | x4    | ê²°ê³¼     |
 |-------|-------|-------|-------|----------|
 | false | true  | true  | true  | true     |
 | true  | false | false | false | false    |

 ### ğŸ”¹ ì˜ˆì‹œ ì„¤ëª…
 1. ì²« ë²ˆì§¸ ì¤„:
    '(false || true) && (true || true)' â†’ 'true && true' â†’ 'true' ë°˜í™˜

 2. ë‘ ë²ˆì§¸ ì¤„:
    '(true || false) && (false || false)' â†’ 'true && false' â†’ 'false' ë°˜í™˜
*/


func solution(_ x1:Bool, _ x2:Bool, _ x3:Bool, _ x4:Bool) -> Bool {
    return (x1 || x2) && (x3 || x4)
}
